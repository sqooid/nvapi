/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const NVAPI_DEFAULT_HANDLE: u32 = 0;
pub const NVAPI_GENERIC_STRING_MAX: u32 = 4096;
pub const NVAPI_LONG_STRING_MAX: u32 = 256;
pub const NVAPI_SHORT_STRING_MAX: u32 = 64;
pub const NVAPI_MAX_PHYSICAL_GPUS: u32 = 64;
pub const NVAPI_MAX_PHYSICAL_BRIDGES: u32 = 100;
pub const NVAPI_PHYSICAL_GPUS: u32 = 32;
pub const NVAPI_MAX_LOGICAL_GPUS: u32 = 64;
pub const NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES: u32 = 256;
pub const NVAPI_MAX_AVAILABLE_SLI_GROUPS: u32 = 256;
pub const NVAPI_MAX_GPU_TOPOLOGIES: u32 = 64;
pub const NVAPI_MAX_GPU_PER_TOPOLOGY: u32 = 8;
pub const NVAPI_MAX_DISPLAY_HEADS: u32 = 2;
pub const NVAPI_ADVANCED_DISPLAY_HEADS: u32 = 4;
pub const NVAPI_MAX_DISPLAYS: u32 = 128;
pub const NVAPI_MAX_ACPI_IDS: u32 = 16;
pub const NVAPI_MAX_VIEW_MODES: u32 = 8;
pub const NVAPI_SYSTEM_MAX_HWBCS: u32 = 128;
pub const NVAPI_SYSTEM_HWBC_INVALID_ID: u32 = 4294967295;
pub const NV_MAX_HEADS: u32 = 4;
pub const NVAPI_MAX_HEADS_PER_GPU: u32 = 32;
pub const NV_MAX_VID_STREAMS: u32 = 4;
pub const NV_MAX_VID_STREAMS_EX: u32 = 20;
pub const NV_MAX_VID_PROFILES: u32 = 4;
pub const NVAPI_MAX_AUDIO_DEVICES: u32 = 16;
pub const NV_MOSAIC_MAX_DISPLAYS: u32 = 64;
pub const NV_EDID_V1_DATA_SIZE: u32 = 256;
pub const NV_EDID_DATA_SIZE: u32 = 256;
pub const NVAPI_MAX_VIEW_TARGET: u32 = 2;
pub const NVAPI_ADVANCED_MAX_VIEW_TARGET: u32 = 4;
pub const NV_TIMING_H_SYNC_POSITIVE: u32 = 0;
pub const NV_TIMING_H_SYNC_NEGATIVE: u32 = 1;
pub const NV_TIMING_H_SYNC_DEFAULT: u32 = 1;
pub const NV_TIMING_V_SYNC_POSITIVE: u32 = 0;
pub const NV_TIMING_V_SYNC_NEGATIVE: u32 = 1;
pub const NV_TIMING_V_SYNC_DEFAULT: u32 = 0;
pub const NV_TIMING_PROGRESSIVE: u32 = 0;
pub const NV_TIMING_INTERLACED: u32 = 1;
pub const NV_TIMING_INTERLACED_EXTRA_VBLANK_ON_FIELD2: u32 = 1;
pub const NV_TIMING_INTERLACED_NO_EXTRA_VBLANK_ON_FIELD2: u32 = 2;
pub const NVAPI_MAX_DISPLAY_PATH: u32 = 2;
pub const NVAPI_ADVANCED_MAX_DISPLAY_PATH: u32 = 4;
pub const NVAPI_UNICODE_STRING_MAX: u32 = 2048;
pub const NVAPI_BINARY_DATA_MAX: u32 = 4096;
pub const NVAPI_MAX_GPU_CLOCKS: u32 = 32;
pub const NVAPI_MAX_GPU_PUBLIC_CLOCKS: u32 = 32;
pub const NVAPI_MAX_GPU_PERF_CLOCKS: u32 = 32;
pub const NVAPI_MAX_GPU_PERF_VOLTAGES: u32 = 16;
pub const NVAPI_MAX_GPU_PERF_PSTATES: u32 = 16;
pub const NVAPI_MAX_GPU_PSTATE20_PSTATES: u32 = 16;
pub const NVAPI_MAX_GPU_PSTATE20_CLOCKS: u32 = 8;
pub const NVAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES: u32 = 4;
pub const NVAPI_OGLEXPERT_DETAIL_NONE: u32 = 0;
pub const NVAPI_OGLEXPERT_DETAIL_ERROR: u32 = 1;
pub const NVAPI_OGLEXPERT_DETAIL_SWFALLBACK: u32 = 2;
pub const NVAPI_OGLEXPERT_DETAIL_BASIC_INFO: u32 = 4;
pub const NVAPI_OGLEXPERT_DETAIL_DETAILED_INFO: u32 = 8;
pub const NVAPI_OGLEXPERT_DETAIL_PERFORMANCE_WARNING: u32 = 16;
pub const NVAPI_OGLEXPERT_DETAIL_QUALITY_WARNING: u32 = 32;
pub const NVAPI_OGLEXPERT_DETAIL_USAGE_WARNING: u32 = 64;
pub const NVAPI_OGLEXPERT_DETAIL_ALL: u32 = 4294967295;
pub const NVAPI_OGLEXPERT_REPORT_NONE: u32 = 0;
pub const NVAPI_OGLEXPERT_REPORT_ERROR: u32 = 1;
pub const NVAPI_OGLEXPERT_REPORT_SWFALLBACK: u32 = 2;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_VERTEX: u32 = 4;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_GEOMETRY: u32 = 8;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_XFB: u32 = 16;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_RASTER: u32 = 32;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_FRAGMENT: u32 = 64;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_ROP: u32 = 128;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_FRAMEBUFFER: u32 = 256;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_PIXEL: u32 = 512;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_TEXTURE: u32 = 1024;
pub const NVAPI_OGLEXPERT_REPORT_OBJECT_BUFFEROBJECT: u32 = 2048;
pub const NVAPI_OGLEXPERT_REPORT_OBJECT_TEXTURE: u32 = 4096;
pub const NVAPI_OGLEXPERT_REPORT_OBJECT_PROGRAM: u32 = 8192;
pub const NVAPI_OGLEXPERT_REPORT_OBJECT_FBO: u32 = 16384;
pub const NVAPI_OGLEXPERT_REPORT_FEATURE_SLI: u32 = 32768;
pub const NVAPI_OGLEXPERT_REPORT_ALL: u32 = 4294967295;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_NONE: u32 = 0;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_CONSOLE: u32 = 1;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_DEBUGGER: u32 = 4;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_CALLBACK: u32 = 8;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_ALL: u32 = 4294967295;
pub const NVAPI_MAX_SIZEOF_I2C_DATA_BUFFER: u32 = 4096;
pub const NVAPI_MAX_SIZEOF_I2C_REG_ADDRESS: u32 = 4;
pub const NVAPI_DISPLAY_DEVICE_MASK_MAX: u32 = 24;
pub const NVAPI_I2C_SPEED_DEPRECATED: u32 = 65535;
pub const NV_LICENSE_MAX_COUNT: u32 = 3;
pub const NV_LICENSE_SIGNATURE_SIZE: u32 = 128;
pub const NV_LICENSE_INFO_MAX_LENGTH: u32 = 128;
pub const NVAPI_MAX_GPU_UTILIZATIONS: u32 = 8;
pub const NVAPI_MAX_THERMAL_SENSORS_PER_GPU: u32 = 3;
pub const NV_GPU_MAX_CLOCK_FREQUENCIES: u32 = 3;
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS: u32 = 2;
pub const NV_GPU_CLIENT_ILLUM_DEVICE_NUM_DEVICES_MAX: u32 = 32;
pub const NV_GPU_CLIENT_ILLUM_ZONE_NUM_ZONES_MAX: u32 = 32;
pub const NV_SOURCE_PID_CURRENT: u32 = 0;
pub const NVAPI_MAX_MOSAIC_DISPLAY_ROWS: u32 = 8;
pub const NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS: u32 = 8;
pub const NV_MOSAIC_TOPO_VALIDITY_VALID: u32 = 0;
pub const NV_MOSAIC_TOPO_VALIDITY_MISSING_GPU: u32 = 1;
pub const NV_MOSAIC_TOPO_VALIDITY_MISSING_DISPLAY: u32 = 2;
pub const NV_MOSAIC_TOPO_VALIDITY_MIXED_DISPLAY_TYPES: u32 = 4;
pub const NV_MOSAIC_DISPLAY_SETTINGS_MAX: u32 = 40;
pub const NV_MOSAIC_TOPO_IDX_DEFAULT: u32 = 0;
pub const NV_MOSAIC_TOPO_IDX_LEFT_EYE: u32 = 0;
pub const NV_MOSAIC_TOPO_IDX_RIGHT_EYE: u32 = 1;
pub const NV_MOSAIC_TOPO_NUM_EYES: u32 = 2;
pub const NV_MOSAIC_MAX_TOPO_PER_TOPO_GROUP: u32 = 2;
pub const NVAPI_MAX_MOSAIC_TOPOS: u32 = 16;
pub const NVAPI_MAX_GSYNC_DEVICES: u32 = 4;
pub const NVAPI_GSYNC_BOARD_ID_P358: u32 = 856;
pub const NVAPI_GSYNC_BOARD_ID_P2060: u32 = 8288;
pub const NVAPI_GSYNC_BOARD_ID_P2061: u32 = 8289;
pub const NVAPI_MAX_RJ45_PER_GSYNC: u32 = 2;
pub const NV_MULTIVIEW_MAX_SUPPORTED_VIEWS: u32 = 4;
pub const NV_MODIFIED_W_MAX_VIEWPORTS: u32 = 16;
pub const NVVIOOWNERID_NONE: u32 = 0;
pub const NVVIO_O_READ: u32 = 0;
pub const NVVIO_O_WRITE_EXCLUSIVE: u32 = 65537;
pub const NVVIO_VALID_ACCESSRIGHTS: u32 = 65537;
pub const NVVIO_OWNERID_INITIALIZED: u32 = 2147483648;
pub const NVVIO_OWNERID_EXCLUSIVE: u32 = 1073741824;
pub const NVVIO_OWNERID_TYPEMASK: u32 = 268435455;
pub const NVAPI_MAX_VIO_DEVICES: u32 = 8;
pub const NVAPI_MAX_VIO_JACKS: u32 = 4;
pub const NVAPI_MAX_VIO_CHANNELS_PER_JACK: u32 = 2;
pub const NVAPI_MAX_VIO_STREAMS: u32 = 4;
pub const NVAPI_MIN_VIO_STREAMS: u32 = 1;
pub const NVAPI_MAX_VIO_LINKS_PER_STREAM: u32 = 2;
pub const NVAPI_MAX_FRAMELOCK_MAPPING_MODES: u32 = 20;
pub const NVAPI_GVI_MIN_RAW_CAPTURE_IMAGES: u32 = 1;
pub const NVAPI_GVI_MAX_RAW_CAPTURE_IMAGES: u32 = 32;
pub const NVAPI_GVI_DEFAULT_RAW_CAPTURE_IMAGES: u32 = 5;
pub const NVVIOCAPS_VIDOUT_SDI: u32 = 1;
pub const NVVIOCAPS_SYNC_INTERNAL: u32 = 256;
pub const NVVIOCAPS_SYNC_GENLOCK: u32 = 512;
pub const NVVIOCAPS_SYNCSRC_SDI: u32 = 4096;
pub const NVVIOCAPS_SYNCSRC_COMP: u32 = 8192;
pub const NVVIOCAPS_OUTPUTMODE_DESKTOP: u32 = 65536;
pub const NVVIOCAPS_OUTPUTMODE_OPENGL: u32 = 131072;
pub const NVVIOCAPS_VIDIN_SDI: u32 = 1048576;
pub const NVVIOCAPS_PACKED_ANC_SUPPORTED: u32 = 2097152;
pub const NVVIOCAPS_AUDIO_BLANKING_SUPPORTED: u32 = 4194304;
pub const NVVIOCLASS_SDI: u32 = 1;
pub const NVVIOBUFFERFORMAT_R8G8B8: u32 = 1;
pub const NVVIOBUFFERFORMAT_R8G8B8Z24: u32 = 2;
pub const NVVIOBUFFERFORMAT_R8G8B8A8: u32 = 4;
pub const NVVIOBUFFERFORMAT_R8G8B8A8Z24: u32 = 8;
pub const NVVIOBUFFERFORMAT_R16FPG16FPB16FP: u32 = 16;
pub const NVVIOBUFFERFORMAT_R16FPG16FPB16FPZ24: u32 = 32;
pub const NVVIOBUFFERFORMAT_R16FPG16FPB16FPA16FP: u32 = 64;
pub const NVVIOBUFFERFORMAT_R16FPG16FPB16FPA16FPZ24: u32 = 128;
pub const MAX_NUM_COMPOSITE_RANGE: u32 = 2;
pub const NVVIOCONFIG_SIGNALFORMAT: u32 = 1;
pub const NVVIOCONFIG_DATAFORMAT: u32 = 2;
pub const NVVIOCONFIG_OUTPUTREGION: u32 = 4;
pub const NVVIOCONFIG_OUTPUTAREA: u32 = 8;
pub const NVVIOCONFIG_COLORCONVERSION: u32 = 16;
pub const NVVIOCONFIG_GAMMACORRECTION: u32 = 32;
pub const NVVIOCONFIG_SYNCSOURCEENABLE: u32 = 64;
pub const NVVIOCONFIG_SYNCDELAY: u32 = 128;
pub const NVVIOCONFIG_COMPOSITESYNCTYPE: u32 = 256;
pub const NVVIOCONFIG_FRAMELOCKENABLE: u32 = 512;
pub const NVVIOCONFIG_422FILTER: u32 = 1024;
pub const NVVIOCONFIG_COMPOSITETERMINATE: u32 = 2048;
pub const NVVIOCONFIG_DATAINTEGRITYCHECK: u32 = 4096;
pub const NVVIOCONFIG_CSCOVERRIDE: u32 = 8192;
pub const NVVIOCONFIG_FLIPQUEUELENGTH: u32 = 16384;
pub const NVVIOCONFIG_ANCTIMECODEGENERATION: u32 = 32768;
pub const NVVIOCONFIG_COMPOSITE: u32 = 65536;
pub const NVVIOCONFIG_ALPHAKEYCOMPOSITE: u32 = 131072;
pub const NVVIOCONFIG_COMPOSITE_Y: u32 = 262144;
pub const NVVIOCONFIG_COMPOSITE_CR: u32 = 524288;
pub const NVVIOCONFIG_COMPOSITE_CB: u32 = 1048576;
pub const NVVIOCONFIG_FULL_COLOR_RANGE: u32 = 2097152;
pub const NVVIOCONFIG_RGB_DATA: u32 = 4194304;
pub const NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE: u32 = 8388608;
pub const NVVIOCONFIG_STREAMS: u32 = 16777216;
pub const NVVIOCONFIG_ANC_PARITY_COMPUTATION: u32 = 33554432;
pub const NVVIOCONFIG_ANC_AUDIO_REPEAT: u32 = 67108864;
pub const NVVIOCONFIG_ALLFIELDS: u32 = 134217727;
pub const NVVIOCONFIG_VALIDFIELDS: u32 = 134217727;
pub const NVVIOCONFIG_DRIVERFIELDS: u32 = 16412;
pub const NVVIOCONFIG_GAMMAFIELDS: u32 = 32;
pub const NVVIOCONFIG_RMCTRLFIELDS: u32 = 2039619;
pub const NVVIOCONFIG_RMSKEWFIELDS: u32 = 128;
pub const NVVIOCONFIG_ALLOWSDIRUNNING_FIELDS: u32 = 35631232;
pub const NVVIOCONFIG_RMMODESET_FIELDS: u32 = 67109699;
pub const NVAPI_STEREO_QUADBUFFERED_API_VERSION: u32 = 2;
pub const NVAPI_SETTING_MAX_VALUES: u32 = 100;
pub const NV_GPU_CLIENT_UTIL_DOMAINS_MAX_V1: u32 = 4;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
pub type NvU64 = ::std::os::raw::c_ulonglong;
pub type NvS64 = ::std::os::raw::c_longlong;
pub type NvS32 = ::std::os::raw::c_int;
pub type NvU32 = ::std::os::raw::c_ulong;
pub type temp_NvU32 = ::std::os::raw::c_ulong;
pub type NvS16 = ::std::os::raw::c_short;
pub type NvU16 = ::std::os::raw::c_ushort;
pub type NvU8 = ::std::os::raw::c_uchar;
pub type NvS8 = ::std::os::raw::c_schar;
pub type NvF32 = f32;
pub type NvF64 = f64;
pub type NvBool = NvU8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_RECT {
    pub left: NvU32,
    pub top: NvU32,
    pub right: NvU32,
    pub bottom: NvU32,
}
#[test]
fn bindgen_test_layout__NV_RECT() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_RECT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_RECT>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_RECT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_RECT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_RECT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_RECT),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_RECT),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_RECT),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_RECT),
            "::",
            stringify!(bottom)
        )
    );
}
pub type NV_RECT = _NV_RECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvLogicalGpuHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvLogicalGpuHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvLogicalGpuHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvLogicalGpuHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvLogicalGpuHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvLogicalGpuHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvLogicalGpuHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvLogicalGpuHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvLogicalGpuHandle = *mut NvLogicalGpuHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvPhysicalGpuHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvPhysicalGpuHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvPhysicalGpuHandle__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvPhysicalGpuHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvPhysicalGpuHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvPhysicalGpuHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvPhysicalGpuHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvPhysicalGpuHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvPhysicalGpuHandle = *mut NvPhysicalGpuHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDisplayHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvDisplayHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvDisplayHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDisplayHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvDisplayHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDisplayHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvDisplayHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDisplayHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvDisplayHandle = *mut NvDisplayHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvMonitorHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvMonitorHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvMonitorHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvMonitorHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvMonitorHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvMonitorHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvMonitorHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvMonitorHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvMonitorHandle = *mut NvMonitorHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvUnAttachedDisplayHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvUnAttachedDisplayHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvUnAttachedDisplayHandle__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvUnAttachedDisplayHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvUnAttachedDisplayHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvUnAttachedDisplayHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvUnAttachedDisplayHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvUnAttachedDisplayHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvUnAttachedDisplayHandle = *mut NvUnAttachedDisplayHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvVisualComputingDeviceHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvVisualComputingDeviceHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvVisualComputingDeviceHandle__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvVisualComputingDeviceHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvVisualComputingDeviceHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvVisualComputingDeviceHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvVisualComputingDeviceHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvVisualComputingDeviceHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvVisualComputingDeviceHandle = *mut NvVisualComputingDeviceHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvEventHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvEventHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvEventHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvEventHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvEventHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvEventHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvEventHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEventHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvEventHandle = *mut NvEventHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvHICHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvHICHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvHICHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvHICHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvHICHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvHICHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvHICHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvHICHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvHICHandle = *mut NvHICHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvGSyncDeviceHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvGSyncDeviceHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvGSyncDeviceHandle__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvGSyncDeviceHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvGSyncDeviceHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvGSyncDeviceHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvGSyncDeviceHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGSyncDeviceHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvGSyncDeviceHandle = *mut NvGSyncDeviceHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvVioHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvVioHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvVioHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvVioHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvVioHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvVioHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvVioHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvVioHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvVioHandle = *mut NvVioHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvTransitionHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvTransitionHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvTransitionHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvTransitionHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvTransitionHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvTransitionHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvTransitionHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvTransitionHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvTransitionHandle = *mut NvTransitionHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvAudioHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvAudioHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvAudioHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvAudioHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvAudioHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvAudioHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvAudioHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvAudioHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvAudioHandle = *mut NvAudioHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Nv3DVPContextHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Nv3DVPContextHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<Nv3DVPContextHandle__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Nv3DVPContextHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(Nv3DVPContextHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<Nv3DVPContextHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(Nv3DVPContextHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Nv3DVPContextHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type Nv3DVPContextHandle = *mut Nv3DVPContextHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Nv3DVPTransceiverHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Nv3DVPTransceiverHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<Nv3DVPTransceiverHandle__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Nv3DVPTransceiverHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(Nv3DVPTransceiverHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<Nv3DVPTransceiverHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(Nv3DVPTransceiverHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Nv3DVPTransceiverHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type Nv3DVPTransceiverHandle = *mut Nv3DVPTransceiverHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Nv3DVPGlassesHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Nv3DVPGlassesHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<Nv3DVPGlassesHandle__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Nv3DVPGlassesHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(Nv3DVPGlassesHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<Nv3DVPGlassesHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(Nv3DVPGlassesHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Nv3DVPGlassesHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type Nv3DVPGlassesHandle = *mut Nv3DVPGlassesHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvPcfClientHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvPcfClientHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvPcfClientHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvPcfClientHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvPcfClientHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvPcfClientHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvPcfClientHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvPcfClientHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvPcfClientHandle = *mut NvPcfClientHandle__;
pub type StereoHandle = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvSourceHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvSourceHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvSourceHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvSourceHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvSourceHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvSourceHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvSourceHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSourceHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvSourceHandle = *mut NvSourceHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvTargetHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvTargetHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvTargetHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvTargetHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvTargetHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvTargetHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvTargetHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvTargetHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvTargetHandle = *mut NvTargetHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NVDX_SwapChainHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NVDX_SwapChainHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NVDX_SwapChainHandle__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NVDX_SwapChainHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NVDX_SwapChainHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NVDX_SwapChainHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NVDX_SwapChainHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVDX_SwapChainHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NVDX_SwapChainHandle = *mut NVDX_SwapChainHandle__;
extern "C" {
    pub static NVDX_SWAPCHAIN_NONE: NVDX_SwapChainHandle;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvPresentBarrierClientHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvPresentBarrierClientHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvPresentBarrierClientHandle__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvPresentBarrierClientHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvPresentBarrierClientHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvPresentBarrierClientHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvPresentBarrierClientHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvPresentBarrierClientHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvPresentBarrierClientHandle = *mut NvPresentBarrierClientHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvSBox {
    pub sX: NvS32,
    pub sY: NvS32,
    pub sWidth: NvS32,
    pub sHeight: NvS32,
}
#[test]
fn bindgen_test_layout_NvSBox() {
    const UNINIT: ::std::mem::MaybeUninit<NvSBox> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvSBox>(),
        16usize,
        concat!("Size of: ", stringify!(NvSBox))
    );
    assert_eq!(
        ::std::mem::align_of::<NvSBox>(),
        4usize,
        concat!("Alignment of ", stringify!(NvSBox))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSBox),
            "::",
            stringify!(sX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSBox),
            "::",
            stringify!(sY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSBox),
            "::",
            stringify!(sWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sHeight) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSBox),
            "::",
            stringify!(sHeight)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvGUID {
    pub data1: NvU32,
    pub data2: NvU16,
    pub data3: NvU16,
    pub data4: [NvU8; 8usize],
}
#[test]
fn bindgen_test_layout_NvGUID() {
    const UNINIT: ::std::mem::MaybeUninit<NvGUID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvGUID>(),
        16usize,
        concat!("Size of: ", stringify!(NvGUID))
    );
    assert_eq!(
        ::std::mem::align_of::<NvGUID>(),
        4usize,
        concat!("Alignment of ", stringify!(NvGUID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGUID),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGUID),
            "::",
            stringify!(data2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data3) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGUID),
            "::",
            stringify!(data3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data4) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGUID),
            "::",
            stringify!(data4)
        )
    );
}
pub type NvLUID = NvGUID;
pub type NvAPI_String = [::std::os::raw::c_char; 4096usize];
pub type NvAPI_LongString = [::std::os::raw::c_char; 256usize];
pub type NvAPI_ShortString = [::std::os::raw::c_char; 64usize];
pub type NvAPI_UnicodeShortString = [NvU16; 64usize];
#[doc = "!< Success. Request is completed."]
pub const _NvAPI_Status_NVAPI_OK: _NvAPI_Status = 0;
#[doc = "!< Generic error"]
pub const _NvAPI_Status_NVAPI_ERROR: _NvAPI_Status = -1;
#[doc = "!< NVAPI support library cannot be loaded."]
pub const _NvAPI_Status_NVAPI_LIBRARY_NOT_FOUND: _NvAPI_Status = -2;
#[doc = "!< not implemented in current driver installation"]
pub const _NvAPI_Status_NVAPI_NO_IMPLEMENTATION: _NvAPI_Status = -3;
#[doc = "!< NvAPI_Initialize has not been called (successfully)"]
pub const _NvAPI_Status_NVAPI_API_NOT_INITIALIZED: _NvAPI_Status = -4;
#[doc = "!< The argument/parameter value is not valid or NULL."]
pub const _NvAPI_Status_NVAPI_INVALID_ARGUMENT: _NvAPI_Status = -5;
#[doc = "!< No NVIDIA display driver, or NVIDIA GPU driving a display, was found."]
pub const _NvAPI_Status_NVAPI_NVIDIA_DEVICE_NOT_FOUND: _NvAPI_Status = -6;
#[doc = "!< No more items to enumerate"]
pub const _NvAPI_Status_NVAPI_END_ENUMERATION: _NvAPI_Status = -7;
#[doc = "!< Invalid handle"]
pub const _NvAPI_Status_NVAPI_INVALID_HANDLE: _NvAPI_Status = -8;
#[doc = "!< An argument's structure version is not supported"]
pub const _NvAPI_Status_NVAPI_INCOMPATIBLE_STRUCT_VERSION: _NvAPI_Status = -9;
#[doc = "!< The handle is no longer valid (likely due to GPU or display re-configuration)"]
pub const _NvAPI_Status_NVAPI_HANDLE_INVALIDATED: _NvAPI_Status = -10;
#[doc = "!< No NVIDIA OpenGL context is current (but needs to be)"]
pub const _NvAPI_Status_NVAPI_OPENGL_CONTEXT_NOT_CURRENT: _NvAPI_Status = -11;
#[doc = "!< An invalid pointer, usually NULL, was passed as a parameter"]
pub const _NvAPI_Status_NVAPI_INVALID_POINTER: _NvAPI_Status = -14;
#[doc = "!< OpenGL Expert is not supported by the current drivers"]
pub const _NvAPI_Status_NVAPI_NO_GL_EXPERT: _NvAPI_Status = -12;
#[doc = "!< OpenGL Expert is supported, but driver instrumentation is currently disabled"]
pub const _NvAPI_Status_NVAPI_INSTRUMENTATION_DISABLED: _NvAPI_Status = -13;
#[doc = "!< OpenGL does not support Nsight"]
pub const _NvAPI_Status_NVAPI_NO_GL_NSIGHT: _NvAPI_Status = -15;
#[doc = "!< Expected a logical GPU handle for one or more parameters"]
pub const _NvAPI_Status_NVAPI_EXPECTED_LOGICAL_GPU_HANDLE: _NvAPI_Status = -100;
#[doc = "!< Expected a physical GPU handle for one or more parameters"]
pub const _NvAPI_Status_NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: _NvAPI_Status = -101;
#[doc = "!< Expected an NV display handle for one or more parameters"]
pub const _NvAPI_Status_NVAPI_EXPECTED_DISPLAY_HANDLE: _NvAPI_Status = -102;
#[doc = "!< The combination of parameters is not valid."]
pub const _NvAPI_Status_NVAPI_INVALID_COMBINATION: _NvAPI_Status = -103;
#[doc = "!< Requested feature is not supported in the selected GPU"]
pub const _NvAPI_Status_NVAPI_NOT_SUPPORTED: _NvAPI_Status = -104;
#[doc = "!< No port ID was found for the I2C transaction"]
pub const _NvAPI_Status_NVAPI_PORTID_NOT_FOUND: _NvAPI_Status = -105;
#[doc = "!< Expected an unattached display handle as one of the input parameters."]
pub const _NvAPI_Status_NVAPI_EXPECTED_UNATTACHED_DISPLAY_HANDLE: _NvAPI_Status = -106;
#[doc = "!< Invalid perf level"]
pub const _NvAPI_Status_NVAPI_INVALID_PERF_LEVEL: _NvAPI_Status = -107;
#[doc = "!< Device is busy; request not fulfilled"]
pub const _NvAPI_Status_NVAPI_DEVICE_BUSY: _NvAPI_Status = -108;
#[doc = "!< NV persist file is not found"]
pub const _NvAPI_Status_NVAPI_NV_PERSIST_FILE_NOT_FOUND: _NvAPI_Status = -109;
#[doc = "!< NV persist data is not found"]
pub const _NvAPI_Status_NVAPI_PERSIST_DATA_NOT_FOUND: _NvAPI_Status = -110;
#[doc = "!< Expected a TV output display"]
pub const _NvAPI_Status_NVAPI_EXPECTED_TV_DISPLAY: _NvAPI_Status = -111;
#[doc = "!< Expected a TV output on the D Connector - HDTV_EIAJ4120."]
pub const _NvAPI_Status_NVAPI_EXPECTED_TV_DISPLAY_ON_DCONNECTOR: _NvAPI_Status = -112;
#[doc = "!< SLI is not active on this device."]
pub const _NvAPI_Status_NVAPI_NO_ACTIVE_SLI_TOPOLOGY: _NvAPI_Status = -113;
#[doc = "!< Setup of SLI rendering mode is not possible right now."]
pub const _NvAPI_Status_NVAPI_SLI_RENDERING_MODE_NOTALLOWED: _NvAPI_Status = -114;
#[doc = "!< Expected a digital flat panel."]
pub const _NvAPI_Status_NVAPI_EXPECTED_DIGITAL_FLAT_PANEL: _NvAPI_Status = -115;
#[doc = "!< Argument exceeds the expected size."]
pub const _NvAPI_Status_NVAPI_ARGUMENT_EXCEED_MAX_SIZE: _NvAPI_Status = -116;
#[doc = "!< Inhibit is ON due to one of the flags in NV_GPU_DISPLAY_CHANGE_INHIBIT or SLI active."]
pub const _NvAPI_Status_NVAPI_DEVICE_SWITCHING_NOT_ALLOWED: _NvAPI_Status = -117;
#[doc = "!< Testing of clocks is not supported."]
pub const _NvAPI_Status_NVAPI_TESTING_CLOCKS_NOT_SUPPORTED: _NvAPI_Status = -118;
#[doc = "!< The specified underscan config is from an unknown source (e.g. INF)"]
pub const _NvAPI_Status_NVAPI_UNKNOWN_UNDERSCAN_CONFIG: _NvAPI_Status = -119;
#[doc = "!< Timeout while reconfiguring GPUs"]
pub const _NvAPI_Status_NVAPI_TIMEOUT_RECONFIGURING_GPU_TOPO: _NvAPI_Status = -120;
#[doc = "!< Requested data was not found"]
pub const _NvAPI_Status_NVAPI_DATA_NOT_FOUND: _NvAPI_Status = -121;
#[doc = "!< Expected an analog display"]
pub const _NvAPI_Status_NVAPI_EXPECTED_ANALOG_DISPLAY: _NvAPI_Status = -122;
#[doc = "!< No SLI video bridge is present"]
pub const _NvAPI_Status_NVAPI_NO_VIDLINK: _NvAPI_Status = -123;
#[doc = "!< NVAPI requires a reboot for the settings to take effect"]
pub const _NvAPI_Status_NVAPI_REQUIRES_REBOOT: _NvAPI_Status = -124;
#[doc = "!< The function is not supported with the current Hybrid mode."]
pub const _NvAPI_Status_NVAPI_INVALID_HYBRID_MODE: _NvAPI_Status = -125;
#[doc = "!< The target types are not all the same"]
pub const _NvAPI_Status_NVAPI_MIXED_TARGET_TYPES: _NvAPI_Status = -126;
#[doc = "!< The function is not supported from 32-bit on a 64-bit system."]
pub const _NvAPI_Status_NVAPI_SYSWOW64_NOT_SUPPORTED: _NvAPI_Status = -127;
#[doc = "!< There is no implicit GPU topology active. Use NVAPI_SetHybridMode to change topology."]
pub const _NvAPI_Status_NVAPI_IMPLICIT_SET_GPU_TOPOLOGY_CHANGE_NOT_ALLOWED: _NvAPI_Status = -128;
#[doc = "!< Prompt the user to close all non-migratable applications."]
pub const _NvAPI_Status_NVAPI_REQUEST_USER_TO_CLOSE_NON_MIGRATABLE_APPS: _NvAPI_Status = -129;
#[doc = "!< Could not allocate sufficient memory to complete the call."]
pub const _NvAPI_Status_NVAPI_OUT_OF_MEMORY: _NvAPI_Status = -130;
#[doc = "!< The previous operation that is transferring information to or from this surface is incomplete."]
pub const _NvAPI_Status_NVAPI_WAS_STILL_DRAWING: _NvAPI_Status = -131;
#[doc = "!< The file was not found."]
pub const _NvAPI_Status_NVAPI_FILE_NOT_FOUND: _NvAPI_Status = -132;
#[doc = "!< There are too many unique instances of a particular type of state object."]
pub const _NvAPI_Status_NVAPI_TOO_MANY_UNIQUE_STATE_OBJECTS: _NvAPI_Status = -133;
#[doc = "!< The method call is invalid. For example, a method's parameter may not be a valid pointer."]
pub const _NvAPI_Status_NVAPI_INVALID_CALL: _NvAPI_Status = -134;
#[doc = "!< d3d10_1.dll cannot be loaded."]
pub const _NvAPI_Status_NVAPI_D3D10_1_LIBRARY_NOT_FOUND: _NvAPI_Status = -135;
#[doc = "!< Couldn't find the function in the loaded DLL."]
pub const _NvAPI_Status_NVAPI_FUNCTION_NOT_FOUND: _NvAPI_Status = -136;
#[doc = "!< The application will require Administrator privileges to access this API.\n!< The application can be elevated to a higher permission level by selecting \"Run as Administrator\"."]
pub const _NvAPI_Status_NVAPI_INVALID_USER_PRIVILEGE: _NvAPI_Status = -137;
#[doc = "!< The handle corresponds to GDIPrimary."]
pub const _NvAPI_Status_NVAPI_EXPECTED_NON_PRIMARY_DISPLAY_HANDLE: _NvAPI_Status = -138;
#[doc = "!< Setting Physx GPU requires that the GPU is compute-capable."]
pub const _NvAPI_Status_NVAPI_EXPECTED_COMPUTE_GPU_HANDLE: _NvAPI_Status = -139;
#[doc = "!< The Stereo part of NVAPI failed to initialize completely. Check if the stereo driver is installed."]
pub const _NvAPI_Status_NVAPI_STEREO_NOT_INITIALIZED: _NvAPI_Status = -140;
#[doc = "!< Access to stereo-related registry keys or values has failed."]
pub const _NvAPI_Status_NVAPI_STEREO_REGISTRY_ACCESS_FAILED: _NvAPI_Status = -141;
#[doc = "!< The given registry profile type is not supported."]
pub const _NvAPI_Status_NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED: _NvAPI_Status = -142;
#[doc = "!< The given registry value is not supported."]
pub const _NvAPI_Status_NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED: _NvAPI_Status = -143;
#[doc = "!< Stereo is not enabled and the function needed it to execute completely."]
pub const _NvAPI_Status_NVAPI_STEREO_NOT_ENABLED: _NvAPI_Status = -144;
#[doc = "!< Stereo is not turned on and the function needed it to execute completely."]
pub const _NvAPI_Status_NVAPI_STEREO_NOT_TURNED_ON: _NvAPI_Status = -145;
#[doc = "!< Invalid device interface."]
pub const _NvAPI_Status_NVAPI_STEREO_INVALID_DEVICE_INTERFACE: _NvAPI_Status = -146;
#[doc = "!< Separation percentage or JPEG image capture quality is out of [0-100] range."]
pub const _NvAPI_Status_NVAPI_STEREO_PARAMETER_OUT_OF_RANGE: _NvAPI_Status = -147;
#[doc = "!< The given frustum adjust mode is not supported."]
pub const _NvAPI_Status_NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED: _NvAPI_Status = -148;
#[doc = "!< The mosaic topology is not possible given the current state of the hardware."]
pub const _NvAPI_Status_NVAPI_TOPO_NOT_POSSIBLE: _NvAPI_Status = -149;
#[doc = "!< An attempt to do a display resolution mode change has failed."]
pub const _NvAPI_Status_NVAPI_MODE_CHANGE_FAILED: _NvAPI_Status = -150;
#[doc = "!< d3d11.dll/d3d11_beta.dll cannot be loaded."]
pub const _NvAPI_Status_NVAPI_D3D11_LIBRARY_NOT_FOUND: _NvAPI_Status = -151;
#[doc = "!< Address is outside of valid range."]
pub const _NvAPI_Status_NVAPI_INVALID_ADDRESS: _NvAPI_Status = -152;
#[doc = "!< The pre-allocated string is too small to hold the result."]
pub const _NvAPI_Status_NVAPI_STRING_TOO_SMALL: _NvAPI_Status = -153;
#[doc = "!< The input does not match any of the available devices."]
pub const _NvAPI_Status_NVAPI_MATCHING_DEVICE_NOT_FOUND: _NvAPI_Status = -154;
#[doc = "!< Driver is running."]
pub const _NvAPI_Status_NVAPI_DRIVER_RUNNING: _NvAPI_Status = -155;
#[doc = "!< Driver is not running."]
pub const _NvAPI_Status_NVAPI_DRIVER_NOTRUNNING: _NvAPI_Status = -156;
#[doc = "!< A driver reload is required to apply these settings."]
pub const _NvAPI_Status_NVAPI_ERROR_DRIVER_RELOAD_REQUIRED: _NvAPI_Status = -157;
#[doc = "!< Intended setting is not allowed."]
pub const _NvAPI_Status_NVAPI_SET_NOT_ALLOWED: _NvAPI_Status = -158;
#[doc = "!< Information can't be returned due to \"advanced display topology\"."]
pub const _NvAPI_Status_NVAPI_ADVANCED_DISPLAY_TOPOLOGY_REQUIRED: _NvAPI_Status = -159;
#[doc = "!< Setting is not found."]
pub const _NvAPI_Status_NVAPI_SETTING_NOT_FOUND: _NvAPI_Status = -160;
#[doc = "!< Setting size is too large."]
pub const _NvAPI_Status_NVAPI_SETTING_SIZE_TOO_LARGE: _NvAPI_Status = -161;
#[doc = "!< There are too many settings for a profile."]
pub const _NvAPI_Status_NVAPI_TOO_MANY_SETTINGS_IN_PROFILE: _NvAPI_Status = -162;
#[doc = "!< Profile is not found."]
pub const _NvAPI_Status_NVAPI_PROFILE_NOT_FOUND: _NvAPI_Status = -163;
#[doc = "!< Profile name is duplicated."]
pub const _NvAPI_Status_NVAPI_PROFILE_NAME_IN_USE: _NvAPI_Status = -164;
#[doc = "!< Profile name is empty."]
pub const _NvAPI_Status_NVAPI_PROFILE_NAME_EMPTY: _NvAPI_Status = -165;
#[doc = "!< Application not found in the Profile."]
pub const _NvAPI_Status_NVAPI_EXECUTABLE_NOT_FOUND: _NvAPI_Status = -166;
#[doc = "!< Application already exists in the other profile."]
pub const _NvAPI_Status_NVAPI_EXECUTABLE_ALREADY_IN_USE: _NvAPI_Status = -167;
#[doc = "!< Data Type mismatch"]
pub const _NvAPI_Status_NVAPI_DATATYPE_MISMATCH: _NvAPI_Status = -168;
#[doc = "!< The profile passed as parameter has been removed and is no longer valid."]
pub const _NvAPI_Status_NVAPI_PROFILE_REMOVED: _NvAPI_Status = -169;
#[doc = "!< An unregistered resource was passed as a parameter."]
pub const _NvAPI_Status_NVAPI_UNREGISTERED_RESOURCE: _NvAPI_Status = -170;
#[doc = "!< The DisplayId corresponds to a display which is not within the normal outputId range."]
pub const _NvAPI_Status_NVAPI_ID_OUT_OF_RANGE: _NvAPI_Status = -171;
#[doc = "!< Display topology is not valid so the driver cannot do a mode set on this configuration."]
pub const _NvAPI_Status_NVAPI_DISPLAYCONFIG_VALIDATION_FAILED: _NvAPI_Status = -172;
#[doc = "!< Display Port Multi-Stream topology has been changed."]
pub const _NvAPI_Status_NVAPI_DPMST_CHANGED: _NvAPI_Status = -173;
#[doc = "!< Input buffer is insufficient to hold the contents."]
pub const _NvAPI_Status_NVAPI_INSUFFICIENT_BUFFER: _NvAPI_Status = -174;
#[doc = "!< No access to the caller."]
pub const _NvAPI_Status_NVAPI_ACCESS_DENIED: _NvAPI_Status = -175;
#[doc = "!< The requested action cannot be performed without Mosaic being enabled."]
pub const _NvAPI_Status_NVAPI_MOSAIC_NOT_ACTIVE: _NvAPI_Status = -176;
#[doc = "!< The surface is relocated away from video memory."]
pub const _NvAPI_Status_NVAPI_SHARE_RESOURCE_RELOCATED: _NvAPI_Status = -177;
#[doc = "!< The user should disable DWM before calling NvAPI."]
pub const _NvAPI_Status_NVAPI_REQUEST_USER_TO_DISABLE_DWM: _NvAPI_Status = -178;
#[doc = "!< D3D device status is D3DERR_DEVICELOST or D3DERR_DEVICENOTRESET - the user has to reset the device."]
pub const _NvAPI_Status_NVAPI_D3D_DEVICE_LOST: _NvAPI_Status = -179;
#[doc = "!< The requested action cannot be performed in the current state."]
pub const _NvAPI_Status_NVAPI_INVALID_CONFIGURATION: _NvAPI_Status = -180;
#[doc = "!< Call failed as stereo handshake not completed."]
pub const _NvAPI_Status_NVAPI_STEREO_HANDSHAKE_NOT_DONE: _NvAPI_Status = -181;
#[doc = "!< The path provided was too short to determine the correct NVDRS_APPLICATION"]
pub const _NvAPI_Status_NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS: _NvAPI_Status = -182;
#[doc = "!< Default stereo profile is not currently defined"]
pub const _NvAPI_Status_NVAPI_DEFAULT_STEREO_PROFILE_IS_NOT_DEFINED: _NvAPI_Status = -183;
#[doc = "!< Default stereo profile does not exist"]
pub const _NvAPI_Status_NVAPI_DEFAULT_STEREO_PROFILE_DOES_NOT_EXIST: _NvAPI_Status = -184;
#[doc = "!< A cluster is already defined with the given configuration."]
pub const _NvAPI_Status_NVAPI_CLUSTER_ALREADY_EXISTS: _NvAPI_Status = -185;
#[doc = "!< The input display id is not that of a multi stream enabled connector or a display device in a multi stream topology"]
pub const _NvAPI_Status_NVAPI_DPMST_DISPLAY_ID_EXPECTED: _NvAPI_Status = -186;
#[doc = "!< The input display id is not valid or the monitor associated to it does not support the current operation"]
pub const _NvAPI_Status_NVAPI_INVALID_DISPLAY_ID: _NvAPI_Status = -187;
#[doc = "!< While playing secure audio stream, stream goes out of sync"]
pub const _NvAPI_Status_NVAPI_STREAM_IS_OUT_OF_SYNC: _NvAPI_Status = -188;
#[doc = "!< Older audio driver version than required"]
pub const _NvAPI_Status_NVAPI_INCOMPATIBLE_AUDIO_DRIVER: _NvAPI_Status = -189;
#[doc = "!< Value already set, setting again not allowed."]
pub const _NvAPI_Status_NVAPI_VALUE_ALREADY_SET: _NvAPI_Status = -190;
#[doc = "!< Requested operation timed out"]
pub const _NvAPI_Status_NVAPI_TIMEOUT: _NvAPI_Status = -191;
#[doc = "!< The requested workstation feature set has incomplete driver internal allocation resources"]
pub const _NvAPI_Status_NVAPI_GPU_WORKSTATION_FEATURE_INCOMPLETE: _NvAPI_Status = -192;
#[doc = "!< Call failed because InitActivation was not called."]
pub const _NvAPI_Status_NVAPI_STEREO_INIT_ACTIVATION_NOT_DONE: _NvAPI_Status = -193;
#[doc = "!< The requested action cannot be performed without Sync being enabled."]
pub const _NvAPI_Status_NVAPI_SYNC_NOT_ACTIVE: _NvAPI_Status = -194;
#[doc = "!< The requested action cannot be performed without Sync Master being enabled."]
pub const _NvAPI_Status_NVAPI_SYNC_MASTER_NOT_FOUND: _NvAPI_Status = -195;
#[doc = "!< Invalid displays passed in the NV_GSYNC_DISPLAY pointer."]
pub const _NvAPI_Status_NVAPI_INVALID_SYNC_TOPOLOGY: _NvAPI_Status = -196;
#[doc = "!< The specified signing algorithm is not supported. Either an incorrect value was entered or the current installed driver/hardware does not support the input value."]
pub const _NvAPI_Status_NVAPI_ECID_SIGN_ALGO_UNSUPPORTED: _NvAPI_Status = -197;
#[doc = "!< The encrypted public key verification has failed."]
pub const _NvAPI_Status_NVAPI_ECID_KEY_VERIFICATION_FAILED: _NvAPI_Status = -198;
#[doc = "!< The device's firmware is out of date."]
pub const _NvAPI_Status_NVAPI_FIRMWARE_OUT_OF_DATE: _NvAPI_Status = -199;
#[doc = "!< The device's firmware is not supported."]
pub const _NvAPI_Status_NVAPI_FIRMWARE_REVISION_NOT_SUPPORTED: _NvAPI_Status = -200;
#[doc = "!< The caller is not authorized to modify the License."]
pub const _NvAPI_Status_NVAPI_LICENSE_CALLER_AUTHENTICATION_FAILED: _NvAPI_Status = -201;
#[doc = "!< The user tried to use a deferred context without registering the device first"]
pub const _NvAPI_Status_NVAPI_D3D_DEVICE_NOT_REGISTERED: _NvAPI_Status = -202;
#[doc = "!< Head or SourceId was not reserved for the VR Display before doing the Modeset or the dedicated display."]
pub const _NvAPI_Status_NVAPI_RESOURCE_NOT_ACQUIRED: _NvAPI_Status = -203;
#[doc = "!< Provided timing is not supported."]
pub const _NvAPI_Status_NVAPI_TIMING_NOT_SUPPORTED: _NvAPI_Status = -204;
#[doc = "!< HDCP Encryption Failed for the device. Would be applicable when the device is HDCP Capable."]
pub const _NvAPI_Status_NVAPI_HDCP_ENCRYPTION_FAILED: _NvAPI_Status = -205;
#[doc = "!< Provided mode is over sink device pclk limitation."]
pub const _NvAPI_Status_NVAPI_PCLK_LIMITATION_FAILED: _NvAPI_Status = -206;
#[doc = "!< No connector on GPU found."]
pub const _NvAPI_Status_NVAPI_NO_CONNECTOR_FOUND: _NvAPI_Status = -207;
#[doc = "!< When a non-HDCP capable HMD is connected, we would inform user by this code."]
pub const _NvAPI_Status_NVAPI_HDCP_DISABLED: _NvAPI_Status = -208;
#[doc = "!< Atleast an API is still being called"]
pub const _NvAPI_Status_NVAPI_API_IN_USE: _NvAPI_Status = -209;
#[doc = "!< No display found on Nvidia GPU(s)."]
pub const _NvAPI_Status_NVAPI_NVIDIA_DISPLAY_NOT_FOUND: _NvAPI_Status = -210;
#[doc = "!< Priv security violation, improper access to a secured register."]
pub const _NvAPI_Status_NVAPI_PRIV_SEC_VIOLATION: _NvAPI_Status = -211;
#[doc = "!< NVAPI cannot be called by this vendor"]
pub const _NvAPI_Status_NVAPI_INCORRECT_VENDOR: _NvAPI_Status = -212;
#[doc = "!< DirectMode Display is already in use"]
pub const _NvAPI_Status_NVAPI_DISPLAY_IN_USE: _NvAPI_Status = -213;
#[doc = "!< The Config is having Non-NVidia GPU with Non-HDCP HMD connected"]
pub const _NvAPI_Status_NVAPI_UNSUPPORTED_CONFIG_NON_HDCP_HMD: _NvAPI_Status = -214;
#[doc = "!< GPU's Max Display Limit has Reached"]
pub const _NvAPI_Status_NVAPI_MAX_DISPLAY_LIMIT_REACHED: _NvAPI_Status = -215;
#[doc = "!< DirectMode not Enabled on the Display"]
pub const _NvAPI_Status_NVAPI_INVALID_DIRECT_MODE_DISPLAY: _NvAPI_Status = -216;
#[doc = "!< GPU is in debug mode, OC is NOT allowed."]
pub const _NvAPI_Status_NVAPI_GPU_IN_DEBUG_MODE: _NvAPI_Status = -217;
#[doc = "!< No NvAPI context was found for this D3D object"]
pub const _NvAPI_Status_NVAPI_D3D_CONTEXT_NOT_FOUND: _NvAPI_Status = -218;
#[doc = "!< there is version mismatch between stereo driver and dx driver"]
pub const _NvAPI_Status_NVAPI_STEREO_VERSION_MISMATCH: _NvAPI_Status = -219;
#[doc = "!< GPU is not powered and so the request cannot be completed."]
pub const _NvAPI_Status_NVAPI_GPU_NOT_POWERED: _NvAPI_Status = -220;
#[doc = "!< The display driver update in progress."]
pub const _NvAPI_Status_NVAPI_ERROR_DRIVER_RELOAD_IN_PROGRESS: _NvAPI_Status = -221;
#[doc = "!< Wait for HW resources allocation"]
pub const _NvAPI_Status_NVAPI_WAIT_FOR_HW_RESOURCE: _NvAPI_Status = -222;
#[doc = "!< operation requires further HDCP action"]
pub const _NvAPI_Status_NVAPI_REQUIRE_FURTHER_HDCP_ACTION: _NvAPI_Status = -223;
#[doc = "!< Dynamic Mux transition failure"]
pub const _NvAPI_Status_NVAPI_DISPLAY_MUX_TRANSITION_FAILED: _NvAPI_Status = -224;
#[doc = "!< Invalid DSC version"]
pub const _NvAPI_Status_NVAPI_INVALID_DSC_VERSION: _NvAPI_Status = -225;
#[doc = "!< Invalid DSC slice count"]
pub const _NvAPI_Status_NVAPI_INVALID_DSC_SLICECOUNT: _NvAPI_Status = -226;
#[doc = "!< Invalid DSC output BPP"]
pub const _NvAPI_Status_NVAPI_INVALID_DSC_OUTPUT_BPP: _NvAPI_Status = -227;
#[doc = "!< There was an error while loading nvapi.dll from the driver store."]
pub const _NvAPI_Status_NVAPI_FAILED_TO_LOAD_FROM_DRIVER_STORE: _NvAPI_Status = -228;
#[doc = "!< OpenGL does not export Vulkan fake extensions"]
pub const _NvAPI_Status_NVAPI_NO_VULKAN: _NvAPI_Status = -229;
#[doc = "!< A request for NvTOPPs telemetry CData has already been made and is pending a response."]
pub const _NvAPI_Status_NVAPI_REQUEST_PENDING: _NvAPI_Status = -230;
#[doc = "!< Operation cannot be performed because the resource is in use."]
pub const _NvAPI_Status_NVAPI_RESOURCE_IN_USE: _NvAPI_Status = -231;
#[doc = "!< Device kernel image is invalid"]
pub const _NvAPI_Status_NVAPI_INVALID_IMAGE: _NvAPI_Status = -232;
#[doc = "!< PTX JIT compilation failed"]
pub const _NvAPI_Status_NVAPI_INVALID_PTX: _NvAPI_Status = -233;
#[doc = "!< Uncorrectable NVLink error was detected during the execution"]
pub const _NvAPI_Status_NVAPI_NVLINK_UNCORRECTABLE: _NvAPI_Status = -234;
#[doc = "!< PTX JIT compiler library was not found."]
pub const _NvAPI_Status_NVAPI_JIT_COMPILER_NOT_FOUND: _NvAPI_Status = -235;
#[doc = "!< Device kernel source is invalid."]
pub const _NvAPI_Status_NVAPI_INVALID_SOURCE: _NvAPI_Status = -236;
#[doc = "!< While executing a kernel, the device encountered an illegal instruction."]
pub const _NvAPI_Status_NVAPI_ILLEGAL_INSTRUCTION: _NvAPI_Status = -237;
#[doc = "!< While executing a kernel, the device program counter wrapped its address space"]
pub const _NvAPI_Status_NVAPI_INVALID_PC: _NvAPI_Status = -238;
#[doc = "!< An exception occurred on the device while executing a kernel"]
pub const _NvAPI_Status_NVAPI_LAUNCH_FAILED: _NvAPI_Status = -239;
#[doc = "!< Attempted operation is not permitted."]
pub const _NvAPI_Status_NVAPI_NOT_PERMITTED: _NvAPI_Status = -240;
#[doc = "!< The callback function has already been registered."]
pub const _NvAPI_Status_NVAPI_CALLBACK_ALREADY_REGISTERED: _NvAPI_Status = -241;
#[doc = "!< The callback function is not found or not registered."]
pub const _NvAPI_Status_NVAPI_CALLBACK_NOT_FOUND: _NvAPI_Status = -242;
#[doc = "! NvAPI Status Values\n!   All NvAPI functions return one of these codes.\n!   \\ingroup nvapistatus"]
pub type _NvAPI_Status = ::std::os::raw::c_int;
#[doc = "! NvAPI Status Values\n!   All NvAPI functions return one of these codes.\n!   \\ingroup nvapistatus"]
pub use self::_NvAPI_Status as NvAPI_Status;
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns display driver version and driver-branch string.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [out]  pDriverVersion         Contains the driver version after successful return.\n! \\param [out]  szBuildBranchString    Contains the driver-branch string after successful return.\n!\n! \\retval ::NVAPI_INVALID_ARGUMENT: either pDriverVersion is NULL or enum index too big\n! \\retval ::NVAPI_OK - completed request\n! \\retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized\n! \\retval ::NVAPI_ERROR - miscellaneous error occurred\n!\n! \\ingroup driverapi\n"]
    pub fn NvAPI_SYS_GetDriverAndBranchVersion(
        pDriverVersion: *mut NvU32,
        szBuildBranchString: *mut ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup driverapi\n! Used in NvAPI_GPU_GetMemoryInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_DRIVER_MEMORY_INFO_V1 {
    #[doc = "!< Version info"]
    pub version: NvU32,
    #[doc = "!< Size(in kb) of the physical framebuffer."]
    pub dedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of the available physical framebuffer for allocating video memory surfaces."]
    pub availableDedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of system memory the driver allocates at load time."]
    pub systemVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations."]
    pub sharedSystemMemory: NvU32,
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_DRIVER_MEMORY_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_DISPLAY_DRIVER_MEMORY_INFO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_DRIVER_MEMORY_INFO_V1>(),
        20usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_DRIVER_MEMORY_INFO_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dedicatedVideoMemory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1),
            "::",
            stringify!(dedicatedVideoMemory)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).availableDedicatedVideoMemory) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1),
            "::",
            stringify!(availableDedicatedVideoMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).systemVideoMemory) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1),
            "::",
            stringify!(systemVideoMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedSystemMemory) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V1),
            "::",
            stringify!(sharedSystemMemory)
        )
    );
}
#[doc = "! \\ingroup driverapi\n! Used in NvAPI_GPU_GetMemoryInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_DRIVER_MEMORY_INFO_V2 {
    #[doc = "!< Version info"]
    pub version: NvU32,
    #[doc = "!< Size(in kb) of the physical framebuffer."]
    pub dedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of the available physical framebuffer for allocating video memory surfaces."]
    pub availableDedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of system memory the driver allocates at load time."]
    pub systemVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations."]
    pub sharedSystemMemory: NvU32,
    #[doc = "!< Size(in kb) of the current available physical framebuffer for allocating video memory surfaces."]
    pub curAvailableDedicatedVideoMemory: NvU32,
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_DRIVER_MEMORY_INFO_V2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_DISPLAY_DRIVER_MEMORY_INFO_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_DRIVER_MEMORY_INFO_V2>(),
        24usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_DRIVER_MEMORY_INFO_V2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dedicatedVideoMemory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2),
            "::",
            stringify!(dedicatedVideoMemory)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).availableDedicatedVideoMemory) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2),
            "::",
            stringify!(availableDedicatedVideoMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).systemVideoMemory) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2),
            "::",
            stringify!(systemVideoMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedSystemMemory) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2),
            "::",
            stringify!(sharedSystemMemory)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).curAvailableDedicatedVideoMemory) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V2),
            "::",
            stringify!(curAvailableDedicatedVideoMemory)
        )
    );
}
#[doc = "! \\ingroup driverapi\n! Used in NvAPI_GPU_GetMemoryInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_DRIVER_MEMORY_INFO_V3 {
    #[doc = "!< Version info"]
    pub version: NvU32,
    #[doc = "!< Size(in kb) of the physical framebuffer."]
    pub dedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of the available physical framebuffer for allocating video memory surfaces."]
    pub availableDedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of system memory the driver allocates at load time."]
    pub systemVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations."]
    pub sharedSystemMemory: NvU32,
    #[doc = "!< Size(in kb) of the current available physical framebuffer for allocating video memory surfaces."]
    pub curAvailableDedicatedVideoMemory: NvU32,
    #[doc = "!< Size(in kb) of the total size of memory released as a result of the evictions."]
    pub dedicatedVideoMemoryEvictionsSize: NvU32,
    #[doc = "!< Indicates the number of eviction events that caused an allocation to be removed from dedicated video memory to free GPU\n!< video memory to make room for other allocations."]
    pub dedicatedVideoMemoryEvictionCount: NvU32,
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_DRIVER_MEMORY_INFO_V3() {
    const UNINIT: ::std::mem::MaybeUninit<NV_DISPLAY_DRIVER_MEMORY_INFO_V3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_DRIVER_MEMORY_INFO_V3>(),
        32usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_DRIVER_MEMORY_INFO_V3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dedicatedVideoMemory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
            "::",
            stringify!(dedicatedVideoMemory)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).availableDedicatedVideoMemory) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
            "::",
            stringify!(availableDedicatedVideoMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).systemVideoMemory) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
            "::",
            stringify!(systemVideoMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedSystemMemory) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
            "::",
            stringify!(sharedSystemMemory)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).curAvailableDedicatedVideoMemory) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
            "::",
            stringify!(curAvailableDedicatedVideoMemory)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dedicatedVideoMemoryEvictionsSize) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
            "::",
            stringify!(dedicatedVideoMemoryEvictionsSize)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dedicatedVideoMemoryEvictionCount) as usize - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_MEMORY_INFO_V3),
            "::",
            stringify!(dedicatedVideoMemoryEvictionCount)
        )
    );
}
#[doc = "! \\ingroup driverapi"]
pub type NV_DISPLAY_DRIVER_MEMORY_INFO = NV_DISPLAY_DRIVER_MEMORY_INFO_V3;
extern "C" {
    #[doc = "!   DESCRIPTION: This function retrieves the available driver memory footprint for the specified GPU.\n!                If the GPU is in TCC Mode, only dedicatedVideoMemory will be returned in pMemoryInfo (NV_DISPLAY_DRIVER_MEMORY_INFO).\n!\n! \\deprecated  Do not use this function - it is deprecated in release 520. Instead, use NvAPI_GPU_GetMemoryInfoEx.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 177\n!\n!  \\param [in]   hPhysicalGpu  Handle of the physical GPU for which the memory information is to be extracted.\n!  \\param [out]  pMemoryInfo   The memory footprint available in the driver. See NV_DISPLAY_DRIVER_MEMORY_INFO.\n!\n!  \\retval       NVAPI_INVALID_ARGUMENT             pMemoryInfo is NULL.\n!  \\retval       NVAPI_OK                           Call successful.\n!  \\retval       NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found.\n!  \\retval       NVAPI_INCOMPATIBLE_STRUCT_VERSION  NV_DISPLAY_DRIVER_MEMORY_INFO structure version mismatch.\n!\n!  \\ingroup  driverapi\n"]
    pub fn NvAPI_GPU_GetMemoryInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pMemoryInfo: *mut NV_DISPLAY_DRIVER_MEMORY_INFO,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup driverapi\n! Used in NvAPI_GPU_GetMemoryInfoEx()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_MEMORY_INFO_EX_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Size(in bytes) of the physical framebuffer."]
    pub dedicatedVideoMemory: NvU64,
    #[doc = "!< Size(in bytes) of the available physical framebuffer for allocating video memory surfaces."]
    pub availableDedicatedVideoMemory: NvU64,
    #[doc = "!< Size(in bytes) of system memory the driver allocates at load time."]
    pub systemVideoMemory: NvU64,
    #[doc = "!< Size(in bytes) of shared system memory that driver is allowed to commit for surfaces across all allocations."]
    pub sharedSystemMemory: NvU64,
    #[doc = "!< Size(in bytes) of the current available physical framebuffer for allocating video memory surfaces."]
    pub curAvailableDedicatedVideoMemory: NvU64,
    #[doc = "!< Size(in bytes) of the total size of memory released as a result of the evictions."]
    pub dedicatedVideoMemoryEvictionsSize: NvU64,
    #[doc = "!< Indicates the number of eviction events that caused an allocation to be removed from dedicated video memory to free GPU\n!< video memory to make room for other allocations."]
    pub dedicatedVideoMemoryEvictionCount: NvU64,
    #[doc = "!< Size(in bytes) of the total size of memory allocated as a result of the promotions."]
    pub dedicatedVideoMemoryPromotionsSize: NvU64,
    #[doc = "!< Indicates the number of promotion events that caused an allocation to be promoted to dedicated video memory"]
    pub dedicatedVideoMemoryPromotionCount: NvU64,
}
#[test]
fn bindgen_test_layout_NV_GPU_MEMORY_INFO_EX_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_MEMORY_INFO_EX_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_MEMORY_INFO_EX_V1>(),
        80usize,
        concat!("Size of: ", stringify!(NV_GPU_MEMORY_INFO_EX_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_MEMORY_INFO_EX_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_GPU_MEMORY_INFO_EX_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_MEMORY_INFO_EX_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dedicatedVideoMemory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_MEMORY_INFO_EX_V1),
            "::",
            stringify!(dedicatedVideoMemory)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).availableDedicatedVideoMemory) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_MEMORY_INFO_EX_V1),
            "::",
            stringify!(availableDedicatedVideoMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).systemVideoMemory) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_MEMORY_INFO_EX_V1),
            "::",
            stringify!(systemVideoMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedSystemMemory) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_MEMORY_INFO_EX_V1),
            "::",
            stringify!(sharedSystemMemory)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).curAvailableDedicatedVideoMemory) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_MEMORY_INFO_EX_V1),
            "::",
            stringify!(curAvailableDedicatedVideoMemory)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dedicatedVideoMemoryEvictionsSize) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_MEMORY_INFO_EX_V1),
            "::",
            stringify!(dedicatedVideoMemoryEvictionsSize)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dedicatedVideoMemoryEvictionCount) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_MEMORY_INFO_EX_V1),
            "::",
            stringify!(dedicatedVideoMemoryEvictionCount)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dedicatedVideoMemoryPromotionsSize) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_MEMORY_INFO_EX_V1),
            "::",
            stringify!(dedicatedVideoMemoryPromotionsSize)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dedicatedVideoMemoryPromotionCount) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_MEMORY_INFO_EX_V1),
            "::",
            stringify!(dedicatedVideoMemoryPromotionCount)
        )
    );
}
#[doc = "! \\ingroup driverapi"]
pub type NV_GPU_MEMORY_INFO_EX = NV_GPU_MEMORY_INFO_EX_V1;
extern "C" {
    #[doc = "!   DESCRIPTION: This function retrieves the available driver memory footprint for the specified GPU.\n!                If the GPU is in TCC Mode, only dedicatedVideoMemory will be returned in pMemoryInfo (NV_GPU_MEMORY_INFO_EX).\n!\n! SUPPORTED OS:  Windows 10 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 520\n!\n!  \\param [in]   hPhysicalGpu  Handle of the physical GPU for which the memory information is to be extracted.\n!  \\param [out]  pMemoryInfo   The memory footprint available in the driver. See NV_GPU_MEMORY_INFO_EX.\n!\n!  \\retval       NVAPI_INVALID_ARGUMENT             pMemoryInfo is NULL.\n!  \\retval       NVAPI_OK                           Call successful.\n!  \\retval       NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found.\n!  \\retval       NVAPI_INCOMPATIBLE_STRUCT_VERSION  NV_GPU_MEMORY_INFO_EX structure version mismatch.\n!\n!  \\ingroup  driverapi\n"]
    pub fn NvAPI_GPU_GetMemoryInfoEx(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pMemoryInfo: *mut NV_GPU_MEMORY_INFO_EX,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns an array of physical GPU handles.\n! Each handle represents a physical GPU present in the system.\n! That GPU may be part of an SLI configuration, or may not be visible to the OS directly.\n!\n! At least one GPU must be present in the system and running an NVIDIA display driver.\n!\n! The array nvGPUHandle will be filled with physical GPU handle values. The returned\n! gpuCount determines how many entries in the array are valid.\n!\n! \\note In drivers older than 105.00, all physical GPU handles get invalidated on a\n!       modeset. So the calling applications need to renum the handles after every modeset.\\n\n!       With drivers 105.00 and up, all physical GPU handles are constant.\n!       Physical GPU handles are constant as long as the GPUs are not physically moved and\n!       the SBIOS VGA order is unchanged.\n!\n!       For GPU handles in TCC MODE please use NvAPI_EnumTCCPhysicalGPUs()\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\par Introduced in\n! \\since Release: 80\n!\n! \\retval NVAPI_INVALID_ARGUMENT         nvGPUHandle or pGpuCount is NULL\n! \\retval NVAPI_OK                       One or more handles were returned\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found\n! \\ingroup gpu\n"]
    pub fn NvAPI_EnumPhysicalGPUs(
        nvGPUHandle: *mut NvPhysicalGpuHandle,
        pGpuCount: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dx\n! Used in NvAPI_D3D10_GetCurrentSLIState(), and NvAPI_D3D_GetCurrentSLIState()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GET_CURRENT_SLI_STATE_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< [OUT] The maximum possible value of numAFRGroups"]
    pub maxNumAFRGroups: NvU32,
    #[doc = "!< [OUT] The number of AFR groups enabled in the system"]
    pub numAFRGroups: NvU32,
    #[doc = "!< [OUT] The AFR group index for the frame currently being rendered"]
    pub currentAFRIndex: NvU32,
    #[doc = "!< [OUT] What the AFR group index will be for the next frame (i.e. after calling Present)"]
    pub nextFrameAFRIndex: NvU32,
    #[doc = "!< [OUT] The AFR group index that was used for the previous frame (~0 if more than one frame has not been rendered yet)"]
    pub previousFrameAFRIndex: NvU32,
    #[doc = "!< [OUT] Boolean: Is this frame the first time running on the current AFR group"]
    pub bIsCurAFRGroupNew: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GET_CURRENT_SLI_STATE_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GET_CURRENT_SLI_STATE_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GET_CURRENT_SLI_STATE_V1>(),
        28usize,
        concat!("Size of: ", stringify!(NV_GET_CURRENT_SLI_STATE_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GET_CURRENT_SLI_STATE_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GET_CURRENT_SLI_STATE_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxNumAFRGroups) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V1),
            "::",
            stringify!(maxNumAFRGroups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAFRGroups) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V1),
            "::",
            stringify!(numAFRGroups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentAFRIndex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V1),
            "::",
            stringify!(currentAFRIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nextFrameAFRIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V1),
            "::",
            stringify!(nextFrameAFRIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).previousFrameAFRIndex) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V1),
            "::",
            stringify!(previousFrameAFRIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsCurAFRGroupNew) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V1),
            "::",
            stringify!(bIsCurAFRGroupNew)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GET_CURRENT_SLI_STATE_V2 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< [OUT] The maximum possible value of numAFRGroups"]
    pub maxNumAFRGroups: NvU32,
    #[doc = "!< [OUT] The number of AFR groups enabled in the system"]
    pub numAFRGroups: NvU32,
    #[doc = "!< [OUT] The AFR group index for the frame currently being rendered"]
    pub currentAFRIndex: NvU32,
    #[doc = "!< [OUT] What the AFR group index will be for the next frame (i.e. after calling Present)"]
    pub nextFrameAFRIndex: NvU32,
    #[doc = "!< [OUT] The AFR group index that was used for the previous frame (~0 if more than one frame has not been rendered yet)"]
    pub previousFrameAFRIndex: NvU32,
    #[doc = "!< [OUT] Boolean: Is this frame the first time running on the current AFR group"]
    pub bIsCurAFRGroupNew: NvU32,
    #[doc = "!< [OUT] The number of GPUs used in VR-SLI. If it is 0 VR-SLI is not active"]
    pub numVRSLIGpus: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GET_CURRENT_SLI_STATE_V2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GET_CURRENT_SLI_STATE_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GET_CURRENT_SLI_STATE_V2>(),
        32usize,
        concat!("Size of: ", stringify!(NV_GET_CURRENT_SLI_STATE_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GET_CURRENT_SLI_STATE_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GET_CURRENT_SLI_STATE_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxNumAFRGroups) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V2),
            "::",
            stringify!(maxNumAFRGroups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAFRGroups) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V2),
            "::",
            stringify!(numAFRGroups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentAFRIndex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V2),
            "::",
            stringify!(currentAFRIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nextFrameAFRIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V2),
            "::",
            stringify!(nextFrameAFRIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).previousFrameAFRIndex) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V2),
            "::",
            stringify!(previousFrameAFRIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsCurAFRGroupNew) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V2),
            "::",
            stringify!(bIsCurAFRGroupNew)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numVRSLIGpus) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_CURRENT_SLI_STATE_V2),
            "::",
            stringify!(numVRSLIGpus)
        )
    );
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API returns the Display ID of the GDI Primary.\n!\n! \\param [out]     displayId   Display ID of the GDI Primary display.\n!\n! \\retval ::NVAPI_OK:                          Capabilties have been returned.\n! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND:     GDI Primary not on an NVIDIA GPU.\n! \\retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.\n! \\retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first\n! \\retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available\n! \\retval ::NVAPI_ERROR:                       Miscellaneous error occurred\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DISP_GetGDIPrimaryDisplayId(displayId: *mut NvU32) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API returns the viewports that would be applied on\n!                  the requested display.\n!\n! \\param [in]      displayId       Display ID of a single display in the active\n!                                  mosaic topology to query.\n! \\param [in]      srcWidth        Width of full display topology. If both\n!                                  width and height are 0, the current\n!                                  resolution is used.\n! \\param [in]      srcHeight       Height of full display topology. If both\n!                                  width and height are 0, the current\n!                                  resolution is used.\n! \\param [out]     viewports       Array of NV_RECT viewports which represent\n!                                  the displays as identified in\n!                                  NvAPI_Mosaic_EnumGridTopologies. If the\n!                                  requested resolution is a single-wide\n!                                  resolution, only viewports[0] will\n!                                  contain the viewport details, regardless\n!                                  of which display is driving the display.\n! \\param [out]     bezelCorrected  Returns 1 if the requested resolution is\n!                                  bezel corrected. May be NULL.\n!\n! \\retval ::NVAPI_OK                          Capabilties have been returned.\n! \\retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid.\n! \\retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first\n! \\retval ::NVAPI_MOSAIC_NOT_ACTIVE           The display does not belong to an active Mosaic Topology\n! \\retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available\n! \\retval ::NVAPI_ERROR                       Miscellaneous error occurred\n!\n! \\ingroup mosaicapi\n"]
    pub fn NvAPI_Mosaic_GetDisplayViewportsByResolution(
        displayId: NvU32,
        srcWidth: NvU32,
        srcHeight: NvU32,
        viewports: *mut NV_RECT,
        bezelCorrected: *mut NvU8,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This APU enables stereo mode in the registry.\n!                Calls to this function affect the entire system.\n!                If stereo is not enabled, then calls to functions that require that stereo is enabled have no effect,\n!                and will return the appropriate error code.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\retval ::NVAPI_OK                      Stereo is now enabled.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED  Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_Enable() -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API disables stereo mode in the registry.\n!                Calls to this function affect the entire system.\n!                If stereo is not enabled, then calls to functions that require that stereo is enabled have no effect,\n!                and will return the appropriate error code.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\retval ::NVAPI_OK                     Stereo is now disabled.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_Disable() -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API checks if stereo mode is enabled in the registry.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [out]     pIsStereoEnabled   Address where the result of the inquiry will be placed.\n!\n! \\retval ::NVAPI_OK                       Check was sucessfully completed and result reflects current state of stereo availability.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED   Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_IsEnabled(pIsStereoEnabled: *mut NvU8) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API destroys the stereo handle created with one of the NvAPI_Stereo_CreateHandleFrom() functions.\n!                This should be called after the device corresponding to the handle has been destroyed.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]     stereoHandle  Stereo handle that is to be destroyed.\n!\n! \\retval ::NVAPI_OK                      Stereo handle is destroyed.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED  Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_DestroyHandle(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API activates stereo for the device interface corresponding to the given stereo handle.\n!                Activating stereo is possible only if stereo was enabled previously in the registry.\n!                If stereo is not activated, then calls to functions that require that stereo is activated have no effect,\n!                and will return the appropriate error code.\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]    stereoHandle  Stereo handle corresponding to the device interface.\n!\n! \\retval ::NVAPI_OK                                Stereo is turned on.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_Activate(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API deactivates stereo for the given device interface.\n!                If stereo is not activated, then calls to functions that require that stereo is activated have no effect,\n!                and will return the appropriate error code.\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]     stereoHandle  Stereo handle that corresponds to the device interface.\n!\n! \\retval ::NVAPI_OK                               Stereo is turned off.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_Deactivate(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API checks if stereo is activated for the given device interface.\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]    stereoHandle  Stereo handle that corresponds to the device interface.\n! \\param [in]    pIsStereoOn   Address where result of the inquiry will be placed.\n!\n! \\retval ::NVAPI_OK - Check was sucessfully completed and result reflects current state of stereo (on/off).\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR - Something is wrong (generic error).\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_IsActivated(
        stereoHandle: StereoHandle,
        pIsStereoOn: *mut NvU8,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API gets current separation value (in percents).\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]     stereoHandle           Stereo handle that corresponds to the device interface.\n! \\param [out]    pSeparationPercentage  Address of @c float type variable to store current separation percentage in.\n!\n! \\retval ::NVAPI_OK                                Retrieval of separation percentage was successfull.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_GetSeparation(
        stereoHandle: StereoHandle,
        pSeparationPercentage: *mut f32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API sets separation to given percentage.\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]     stereoHandle             Stereo handle that corresponds to the device interface.\n! \\param [in]     newSeparationPercentage  New value for separation percentage.\n!\n! \\retval ::NVAPI_OK                               Setting of separation percentage was successfull.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED               NVAPI not initialized.\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_STEREO_PARAMETER_OUT_OF_RANGE    Given separation percentage is out of [0..100] range.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_SetSeparation(
        stereoHandle: StereoHandle,
        newSeparationPercentage: f32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API gets the current convergence value.\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]     stereoHandle   Stereo handle that corresponds to the device interface.\n! \\param [out]    pConvergence   Address of @c float type variable to store current convergence value in.\n!\n! \\retval ::NVAPI_OK                               Retrieval of convergence value was successfull.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_GetConvergence(
        stereoHandle: StereoHandle,
        pConvergence: *mut f32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API sets convergence to the given value.\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]     stereoHandle              Stereo handle that corresponds to the device interface.\n! \\param [in]     newConvergence            New value for convergence.\n!\n! \\retval ::NVAPI_OK                                Setting of convergence value was successfull.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_SetConvergence(
        stereoHandle: StereoHandle,
        newConvergence: f32,
    ) -> NvAPI_Status;
}
pub const _NV_StereoActiveEye_NVAPI_STEREO_EYE_RIGHT: _NV_StereoActiveEye = 1;
pub const _NV_StereoActiveEye_NVAPI_STEREO_EYE_LEFT: _NV_StereoActiveEye = 2;
pub const _NV_StereoActiveEye_NVAPI_STEREO_EYE_MONO: _NV_StereoActiveEye = 3;
#[doc = "! \\ingroup stereoapi"]
pub type _NV_StereoActiveEye = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi"]
pub use self::_NV_StereoActiveEye as NV_STEREO_ACTIVE_EYE;
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_SetActiveEye(
        hStereoHandle: StereoHandle,
        StereoEye: NV_STEREO_ACTIVE_EYE,
    ) -> NvAPI_Status;
}
pub const _NV_StereoDriverMode_NVAPI_STEREO_DRIVER_MODE_AUTOMATIC: _NV_StereoDriverMode = 0;
pub const _NV_StereoDriverMode_NVAPI_STEREO_DRIVER_MODE_DIRECT: _NV_StereoDriverMode = 2;
#[doc = "! \\ingroup stereoapi"]
pub type _NV_StereoDriverMode = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi"]
pub use self::_NV_StereoDriverMode as NV_STEREO_DRIVER_MODE;
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_SetDriverMode(mode: NV_STEREO_DRIVER_MODE) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API returns eye separation as a ratio of <between eye distance>/<physical screen width>.\n!\n! HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate API. Applies only to DirectX 9 and up.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]   stereoHandle  Stereo handle that corresponds to the device interface.\n! \\param [out]  pSeparation   Eye separation.\n!\n! \\retval ::NVAPI_OK                               Active eye is set.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED               NVAPI not initialized.\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR  (generic error).\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_GetEyeSeparation(
        hStereoHandle: StereoHandle,
        pSeparation: *mut f32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API returns availability of windowed mode stereo\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [out] bSupported(OUT)    != 0  - supported,  \\n\n!                                 == 0  - is not supported\n!\n!\n! \\retval ::NVAPI_OK                      Retrieval of frustum adjust mode was successfull.\n! \\retval ::NVAPI_API_NOT_INTIALIZED      NVAPI not initialized.\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED  Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR                   Something is wrong (generic error).\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_IsWindowedModeSupported(bSupported: *mut NvU8) -> NvAPI_Status;
}
#[doc = "!< Use driver registry profile settings for surface creation mode."]
pub const _NVAPI_STEREO_SURFACECREATEMODE_NVAPI_STEREO_SURFACECREATEMODE_AUTO:
    _NVAPI_STEREO_SURFACECREATEMODE = 0;
#[doc = "!< Always create stereo surfaces."]
pub const _NVAPI_STEREO_SURFACECREATEMODE_NVAPI_STEREO_SURFACECREATEMODE_FORCESTEREO:
    _NVAPI_STEREO_SURFACECREATEMODE = 1;
#[doc = "!< Always create mono surfaces."]
pub const _NVAPI_STEREO_SURFACECREATEMODE_NVAPI_STEREO_SURFACECREATEMODE_FORCEMONO:
    _NVAPI_STEREO_SURFACECREATEMODE = 2;
#[doc = "! \\ingroup stereoapi"]
pub type _NVAPI_STEREO_SURFACECREATEMODE = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi"]
pub use self::_NVAPI_STEREO_SURFACECREATEMODE as NVAPI_STEREO_SURFACECREATEMODE;
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_SetSurfaceCreationMode(
        hStereoHandle: StereoHandle,
        creationMode: NVAPI_STEREO_SURFACECREATEMODE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_GetSurfaceCreationMode(
        hStereoHandle: StereoHandle,
        pCreationMode: *mut NVAPI_STEREO_SURFACECREATEMODE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\param [in]  hStereoHandle    Stereo handle that corresponds to the device interface.\n! \\param [out] pWasStereoized   Address where result of the inquiry will be placed.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! DESCRIPTION: This API checks if the last draw call was stereoized. It is a very expensive to call and should be used for debugging purpose *only*.\n!\n! WHEN TO USE: After the stereo handle for device interface is created via successful call to appropriate NvAPI_Stereo_CreateHandleFrom function.\n!\n! \\return      This API can return any of the error codes enumerated in #NvAPI_Status.\n!              There are no return error codes with specific meaning for this API.\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_Debug_WasLastDrawStereoized(
        hStereoHandle: StereoHandle,
        pWasStereoized: *mut NvU8,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! DESCRIPTION: This API defines the stereo profile used by the driver in case the application has no associated profile.\n!\n! WHEN TO USE: To take effect, this API must be called before D3D device is created. Calling once a device has been created will not affect the current device.\n!\n! \\param [in]  szProfileName        Default profile name.\n!\n! \\return      This API can return any of the error codes enumerated in #NvAPI_Status.\n!              Error codes specific to this API are described below.\n!\n! \\retval      NVAPI_SUCCESS                               - Default stereo profile name has been copied into szProfileName.\n! \\retval      NVAPI_INVALID_ARGUMENT                      - szProfileName == NULL.\n! \\retval      NVAPI_DEFAULT_STEREO_PROFILE_DOES_NOT_EXIST - Default stereo profile does not exist\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_SetDefaultProfile(
        szProfileName: *const ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! DESCRIPTION: This API retrieves the current default stereo profile.\n!\n!              After call cbSizeOut contain 0 if default profile is not set required buffer size cbSizeOut.\n!              To get needed buffer size this function can be called with szProfileName==0 and cbSizeIn == 0.\n!\n! WHEN TO USE: This API can be called at any time.\n!\n!\n! \\param [in]   cbSizeIn             Size of buffer allocated for default stereo profile name.\n! \\param [out]  szProfileName        Default stereo profile name.\n! \\param [out]  pcbSizeOut           Required buffer size.\n!                     # ==0 - there is no default stereo profile name currently set\n!                     # !=0 - size of buffer required for currently set default stereo profile name including trailing '0'.\n!\n!\n! \\return      This API can return any of the error codes enumerated in #NvAPI_Status.\n!              Error codes specific to this API are described below.\n!\n! \\retval      NVAPI_SUCCESS                                - Default stereo profile name has been copied into szProfileName.\n! \\retval      NVAPI_DEFAULT_STEREO_PROFILE_IS_NOT_DEFINED  - There is no default stereo profile set at this time.\n! \\retval      NVAPI_INVALID_ARGUMENT                       - pcbSizeOut == 0 or cbSizeIn >= *pcbSizeOut && szProfileName == 0\n! \\retval      NVAPI_INSUFFICIENT_BUFFER                    - cbSizeIn < *pcbSizeOut\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_GetDefaultProfile(
        cbSizeIn: NvU32,
        szProfileName: *mut ::std::os::raw::c_char,
        pcbSizeOut: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function initializes the NvAPI library (if not already initialized) but always increments the ref-counter.\n! This must be called before calling other NvAPI_ functions.\n! Note: It is now mandatory to call NvAPI_Initialize before calling any other NvAPI.\n! NvAPI_Unload should be called to unload the NVAPI Library.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\return      This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!              specific meaning for this API, they are listed below.\n! \\retval      NVAPI_LIBRARY_NOT_FOUND  Failed to load the NVAPI support library\n! \\sa nvapistatus\n! \\ingroup nvapifunctions\n"]
    pub fn NvAPI_Initialize() -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Decrements the ref-counter and when it reaches ZERO, unloads NVAPI library.\n!                This must be called in pairs with NvAPI_Initialize.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n!        If the client wants unload functionality, it is recommended to always call NvAPI_Initialize and NvAPI_Unload in pairs.\n!\n!  Unloading NvAPI library is not supported when the library is in a resource locked state.\n!  Some functions in the NvAPI library initiates an operation or allocates certain resources\n!  and there are corresponding functions available, to complete the operation or free the\n!  allocated resources. All such function pairs are designed to prevent unloading NvAPI library.\n!\n!  For example, if NvAPI_Unload is called after NvAPI_XXX which locks a resource, it fails with\n!  NVAPI_ERROR. Developers need to call the corresponding NvAPI_YYY to unlock the resources,\n!  before calling NvAPI_Unload again.\n!\n! \\return      This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!              specific meaning for this API, they are listed below.\n! \\retval      NVAPI_API_IN_USE       Atleast an API is still being called hence cannot unload requested driver.\n!\n! \\ingroup nvapifunctions\n"]
    pub fn NvAPI_Unload() -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function converts an NvAPI error code into a null terminated string.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\param nr      The error code to convert\n! \\param szDesc  The string corresponding to the error code\n!\n! \\return NULL terminated string (always, never NULL)\n! \\ingroup nvapifunctions\n"]
    pub fn NvAPI_GetErrorMessage(
        nr: NvAPI_Status,
        szDesc: *mut ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns a string describing the version of the NvAPI library.\n!               The contents of the string are human readable.  Do not assume a fixed\n!                format.\n!\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\param  szDesc User readable string giving NvAPI version information\n!\n! \\return See \\ref nvapistatus for the list of possible return values.\n! \\ingroup nvapifunctions\n"]
    pub fn NvAPI_GetInterfaceVersionString(szDesc: *mut ::std::os::raw::c_char) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns a string describing the version of the NvAPI library.\n!               The contents of the string are human readable.  Do not assume a fixed  format.\n!\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 450\n!\n! \\param  szDesc User readable string giving NvAPI version information\n!\n! \\return See \\ref nvapistatus for the list of possible return values.\n! \\ingroup nvapifunctions\n"]
    pub fn NvAPI_GetInterfaceVersionStringEx(szDesc: *mut ::std::os::raw::c_char) -> NvAPI_Status;
}
pub const _NV_DP_LINK_RATE_NV_DP_1_62GBPS: _NV_DP_LINK_RATE = 6;
pub const _NV_DP_LINK_RATE_NV_DP_2_70GBPS: _NV_DP_LINK_RATE = 10;
pub const _NV_DP_LINK_RATE_NV_DP_5_40GBPS: _NV_DP_LINK_RATE = 20;
pub const _NV_DP_LINK_RATE_NV_DP_8_10GBPS: _NV_DP_LINK_RATE = 30;
pub const _NV_DP_LINK_RATE_NV_EDP_2_16GBPS: _NV_DP_LINK_RATE = 8;
pub const _NV_DP_LINK_RATE_NV_EDP_2_43GBPS: _NV_DP_LINK_RATE = 9;
pub const _NV_DP_LINK_RATE_NV_EDP_3_24GBPS: _NV_DP_LINK_RATE = 12;
pub const _NV_DP_LINK_RATE_NV_EDP_4_32GBPS: _NV_DP_LINK_RATE = 16;
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PORT_INFO."]
pub type _NV_DP_LINK_RATE = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PORT_INFO."]
pub use self::_NV_DP_LINK_RATE as NV_DP_LINK_RATE;
pub const _NV_DP_LANE_COUNT_NV_DP_1_LANE: _NV_DP_LANE_COUNT = 1;
pub const _NV_DP_LANE_COUNT_NV_DP_2_LANE: _NV_DP_LANE_COUNT = 2;
pub const _NV_DP_LANE_COUNT_NV_DP_4_LANE: _NV_DP_LANE_COUNT = 4;
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PORT_INFO."]
pub type _NV_DP_LANE_COUNT = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PORT_INFO."]
pub use self::_NV_DP_LANE_COUNT as NV_DP_LANE_COUNT;
pub const _NV_DP_COLOR_FORMAT_NV_DP_COLOR_FORMAT_RGB: _NV_DP_COLOR_FORMAT = 0;
pub const _NV_DP_COLOR_FORMAT_NV_DP_COLOR_FORMAT_YCbCr422: _NV_DP_COLOR_FORMAT = 1;
pub const _NV_DP_COLOR_FORMAT_NV_DP_COLOR_FORMAT_YCbCr444: _NV_DP_COLOR_FORMAT = 2;
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PORT_INFO."]
pub type _NV_DP_COLOR_FORMAT = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PORT_INFO."]
pub use self::_NV_DP_COLOR_FORMAT as NV_DP_COLOR_FORMAT;
pub const _NV_DP_COLORIMETRY_NV_DP_COLORIMETRY_RGB: _NV_DP_COLORIMETRY = 0;
pub const _NV_DP_COLORIMETRY_NV_DP_COLORIMETRY_YCbCr_ITU601: _NV_DP_COLORIMETRY = 1;
pub const _NV_DP_COLORIMETRY_NV_DP_COLORIMETRY_YCbCr_ITU709: _NV_DP_COLORIMETRY = 2;
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PORT_INFO."]
pub type _NV_DP_COLORIMETRY = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PORT_INFO."]
pub use self::_NV_DP_COLORIMETRY as NV_DP_COLORIMETRY;
pub const _NV_DP_DYNAMIC_RANGE_NV_DP_DYNAMIC_RANGE_VESA: _NV_DP_DYNAMIC_RANGE = 0;
pub const _NV_DP_DYNAMIC_RANGE_NV_DP_DYNAMIC_RANGE_CEA: _NV_DP_DYNAMIC_RANGE = 1;
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PORT_INFO."]
pub type _NV_DP_DYNAMIC_RANGE = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PORT_INFO."]
pub use self::_NV_DP_DYNAMIC_RANGE as NV_DP_DYNAMIC_RANGE;
pub const _NV_DP_BPC_NV_DP_BPC_DEFAULT: _NV_DP_BPC = 0;
pub const _NV_DP_BPC_NV_DP_BPC_6: _NV_DP_BPC = 1;
pub const _NV_DP_BPC_NV_DP_BPC_8: _NV_DP_BPC = 2;
pub const _NV_DP_BPC_NV_DP_BPC_10: _NV_DP_BPC = 3;
pub const _NV_DP_BPC_NV_DP_BPC_12: _NV_DP_BPC = 4;
pub const _NV_DP_BPC_NV_DP_BPC_16: _NV_DP_BPC = 5;
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PORT_INFO."]
pub type _NV_DP_BPC = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PORT_INFO."]
pub use self::_NV_DP_BPC as NV_DP_BPC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_EDID_V1 {
    pub version: NvU32,
    pub EDID_Data: [NvU8; 256usize],
}
#[test]
fn bindgen_test_layout_NV_EDID_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_EDID_V1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_EDID_V1>(),
        260usize,
        concat!("Size of: ", stringify!(NV_EDID_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_EDID_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_EDID_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EDID_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EDID_Data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EDID_V1),
            "::",
            stringify!(EDID_Data)
        )
    );
}
#[doc = "! Used in NvAPI_GPU_GetEDID()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_EDID_V2 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub EDID_Data: [NvU8; 256usize],
    pub sizeofEDID: NvU32,
}
#[test]
fn bindgen_test_layout_NV_EDID_V2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_EDID_V2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_EDID_V2>(),
        264usize,
        concat!("Size of: ", stringify!(NV_EDID_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_EDID_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_EDID_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EDID_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EDID_Data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EDID_V2),
            "::",
            stringify!(EDID_Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeofEDID) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EDID_V2),
            "::",
            stringify!(sizeofEDID)
        )
    );
}
#[doc = "! Used in NvAPI_GPU_GetEDID()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_EDID_V3 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub EDID_Data: [NvU8; 256usize],
    pub sizeofEDID: NvU32,
    #[doc = "!< ID which always returned in a monotonically increasing counter.\n!< Across a split-EDID read we need to verify that all calls returned the same edidId.\n!< This counter is incremented if we get the updated EDID."]
    pub edidId: NvU32,
    #[doc = "!< Which 256-byte page of the EDID we want to read. Start at 0.\n!< If the read succeeds with edidSize > NV_EDID_DATA_SIZE,\n!< call back again with offset+256 until we have read the entire buffer"]
    pub offset: NvU32,
}
#[test]
fn bindgen_test_layout_NV_EDID_V3() {
    const UNINIT: ::std::mem::MaybeUninit<NV_EDID_V3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_EDID_V3>(),
        272usize,
        concat!("Size of: ", stringify!(NV_EDID_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_EDID_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_EDID_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EDID_V3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EDID_Data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EDID_V3),
            "::",
            stringify!(EDID_Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeofEDID) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EDID_V3),
            "::",
            stringify!(sizeofEDID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edidId) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EDID_V3),
            "::",
            stringify!(edidId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EDID_V3),
            "::",
            stringify!(offset)
        )
    );
}
#[doc = "! Used in NvAPI_GPU_GetEDID()"]
pub type NV_EDID = NV_EDID_V3;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_GetEDID(
        hPhysicalGpu: NvPhysicalGpuHandle,
        displayOutputId: NvU32,
        pEDID: *mut NV_EDID,
    ) -> NvAPI_Status;
}
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_VGA_15_PIN: _NV_GPU_CONNECTOR_TYPE = 0;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_TV_COMPOSITE: _NV_GPU_CONNECTOR_TYPE = 16;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_TV_SVIDEO: _NV_GPU_CONNECTOR_TYPE = 17;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_TV_HDTV_COMPONENT: _NV_GPU_CONNECTOR_TYPE = 19;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_TV_SCART: _NV_GPU_CONNECTOR_TYPE = 20;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_TV_COMPOSITE_SCART_ON_EIAJ4120:
    _NV_GPU_CONNECTOR_TYPE = 22;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_TV_HDTV_EIAJ4120: _NV_GPU_CONNECTOR_TYPE = 23;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_PC_POD_HDTV_YPRPB: _NV_GPU_CONNECTOR_TYPE = 24;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_PC_POD_SVIDEO: _NV_GPU_CONNECTOR_TYPE = 25;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_PC_POD_COMPOSITE: _NV_GPU_CONNECTOR_TYPE = 26;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DVI_I_TV_SVIDEO: _NV_GPU_CONNECTOR_TYPE = 32;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DVI_I_TV_COMPOSITE: _NV_GPU_CONNECTOR_TYPE =
    33;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DVI_I: _NV_GPU_CONNECTOR_TYPE = 48;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DVI_D: _NV_GPU_CONNECTOR_TYPE = 49;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_ADC: _NV_GPU_CONNECTOR_TYPE = 50;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_LFH_DVI_I_1: _NV_GPU_CONNECTOR_TYPE = 56;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_LFH_DVI_I_2: _NV_GPU_CONNECTOR_TYPE = 57;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_SPWG: _NV_GPU_CONNECTOR_TYPE = 64;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_OEM: _NV_GPU_CONNECTOR_TYPE = 65;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DISPLAYPORT_EXTERNAL: _NV_GPU_CONNECTOR_TYPE =
    70;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DISPLAYPORT_INTERNAL: _NV_GPU_CONNECTOR_TYPE =
    71;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_DISPLAYPORT_MINI_EXT: _NV_GPU_CONNECTOR_TYPE =
    72;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_HDMI_A: _NV_GPU_CONNECTOR_TYPE = 97;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_HDMI_C_MINI: _NV_GPU_CONNECTOR_TYPE = 99;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_LFH_DISPLAYPORT_1: _NV_GPU_CONNECTOR_TYPE =
    100;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_LFH_DISPLAYPORT_2: _NV_GPU_CONNECTOR_TYPE =
    101;
#[doc = "!< Deprecated."]
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_VIRTUAL_WFD: _NV_GPU_CONNECTOR_TYPE = 112;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_USB_C: _NV_GPU_CONNECTOR_TYPE = 113;
pub const _NV_GPU_CONNECTOR_TYPE_NVAPI_GPU_CONNECTOR_UNKNOWN: _NV_GPU_CONNECTOR_TYPE = -1;
#[doc = "! \\ingroup gpu\n! Used in NV_GPU_CONNECTOR_DATA"]
pub type _NV_GPU_CONNECTOR_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu\n! Used in NV_GPU_CONNECTOR_DATA"]
pub use self::_NV_GPU_CONNECTOR_TYPE as NV_GPU_CONNECTOR_TYPE;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_NONE: _NV_DISPLAY_TV_FORMAT = 0;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_NTSCM: _NV_DISPLAY_TV_FORMAT = 1;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_NTSCJ: _NV_DISPLAY_TV_FORMAT = 2;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_PALM: _NV_DISPLAY_TV_FORMAT = 4;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_PALBDGH: _NV_DISPLAY_TV_FORMAT = 8;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_PALN: _NV_DISPLAY_TV_FORMAT = 16;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_PALNC: _NV_DISPLAY_TV_FORMAT = 32;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_576i: _NV_DISPLAY_TV_FORMAT = 256;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_480i: _NV_DISPLAY_TV_FORMAT = 512;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_ED_480p: _NV_DISPLAY_TV_FORMAT = 1024;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_ED_576p: _NV_DISPLAY_TV_FORMAT = 2048;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_720p: _NV_DISPLAY_TV_FORMAT = 4096;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_1080i: _NV_DISPLAY_TV_FORMAT = 8192;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_1080p: _NV_DISPLAY_TV_FORMAT = 16384;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_720p50: _NV_DISPLAY_TV_FORMAT = 32768;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_1080p24: _NV_DISPLAY_TV_FORMAT = 65536;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_1080i50: _NV_DISPLAY_TV_FORMAT = 131072;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_1080p50: _NV_DISPLAY_TV_FORMAT = 262144;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp30: _NV_DISPLAY_TV_FORMAT = 524288;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp30_3840: _NV_DISPLAY_TV_FORMAT = 524288;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp25: _NV_DISPLAY_TV_FORMAT = 1048576;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp25_3840: _NV_DISPLAY_TV_FORMAT =
    1048576;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp24: _NV_DISPLAY_TV_FORMAT = 2097152;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp24_3840: _NV_DISPLAY_TV_FORMAT =
    2097152;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp24_SMPTE: _NV_DISPLAY_TV_FORMAT =
    4194304;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp50_3840: _NV_DISPLAY_TV_FORMAT =
    8388608;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp60_3840: _NV_DISPLAY_TV_FORMAT =
    9437184;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp30_4096: _NV_DISPLAY_TV_FORMAT =
    10485760;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp25_4096: _NV_DISPLAY_TV_FORMAT =
    11534336;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp24_4096: _NV_DISPLAY_TV_FORMAT =
    12582912;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp50_4096: _NV_DISPLAY_TV_FORMAT =
    13631488;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp60_4096: _NV_DISPLAY_TV_FORMAT =
    14680064;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp24_7680: _NV_DISPLAY_TV_FORMAT =
    16777216;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp25_7680: _NV_DISPLAY_TV_FORMAT =
    33554432;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp30_7680: _NV_DISPLAY_TV_FORMAT =
    67108864;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp48_7680: _NV_DISPLAY_TV_FORMAT =
    134217728;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp50_7680: _NV_DISPLAY_TV_FORMAT =
    150994944;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp60_7680: _NV_DISPLAY_TV_FORMAT =
    167772160;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp100_7680: _NV_DISPLAY_TV_FORMAT =
    184549376;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_8Kp120_7680: _NV_DISPLAY_TV_FORMAT =
    201326592;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp48_3840: _NV_DISPLAY_TV_FORMAT =
    218103808;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp48_4096: _NV_DISPLAY_TV_FORMAT =
    234881024;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp100_4096: _NV_DISPLAY_TV_FORMAT =
    251658240;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp100_3840: _NV_DISPLAY_TV_FORMAT =
    268435456;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp120_4096: _NV_DISPLAY_TV_FORMAT =
    285212672;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp120_3840: _NV_DISPLAY_TV_FORMAT =
    301989888;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp100_5120: _NV_DISPLAY_TV_FORMAT =
    318767104;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp120_5120: _NV_DISPLAY_TV_FORMAT =
    335544320;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp24_5120: _NV_DISPLAY_TV_FORMAT =
    352321536;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp25_5120: _NV_DISPLAY_TV_FORMAT =
    369098752;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp30_5120: _NV_DISPLAY_TV_FORMAT =
    385875968;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp48_5120: _NV_DISPLAY_TV_FORMAT =
    402653184;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp50_5120: _NV_DISPLAY_TV_FORMAT =
    419430400;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_4Kp60_5120: _NV_DISPLAY_TV_FORMAT =
    536870912;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp24_10240: _NV_DISPLAY_TV_FORMAT =
    553648128;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp25_10240: _NV_DISPLAY_TV_FORMAT =
    570425344;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp30_10240: _NV_DISPLAY_TV_FORMAT =
    587202560;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp48_10240: _NV_DISPLAY_TV_FORMAT =
    603979776;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp50_10240: _NV_DISPLAY_TV_FORMAT =
    620756992;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp60_10240: _NV_DISPLAY_TV_FORMAT =
    637534208;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp100_10240: _NV_DISPLAY_TV_FORMAT =
    654311424;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_UHD_10Kp120_10240: _NV_DISPLAY_TV_FORMAT =
    671088640;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_SD_OTHER: _NV_DISPLAY_TV_FORMAT = 805306368;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_ED_OTHER: _NV_DISPLAY_TV_FORMAT = 1073741824;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_HD_OTHER: _NV_DISPLAY_TV_FORMAT = 1342177280;
pub const _NV_DISPLAY_TV_FORMAT_NV_DISPLAY_TV_FORMAT_ANY: _NV_DISPLAY_TV_FORMAT = -2147483648;
#[doc = "! \\ingroup tvapi\n! Used in NV_DISPLAY_TV_OUTPUT_INFO"]
pub type _NV_DISPLAY_TV_FORMAT = ::std::os::raw::c_int;
#[doc = "! \\ingroup tvapi\n! Used in NV_DISPLAY_TV_OUTPUT_INFO"]
pub use self::_NV_DISPLAY_TV_FORMAT as NV_DISPLAY_TV_FORMAT;
pub const _NV_TARGET_VIEW_MODE_NV_VIEW_MODE_STANDARD: _NV_TARGET_VIEW_MODE = 0;
pub const _NV_TARGET_VIEW_MODE_NV_VIEW_MODE_CLONE: _NV_TARGET_VIEW_MODE = 1;
pub const _NV_TARGET_VIEW_MODE_NV_VIEW_MODE_HSPAN: _NV_TARGET_VIEW_MODE = 2;
pub const _NV_TARGET_VIEW_MODE_NV_VIEW_MODE_VSPAN: _NV_TARGET_VIEW_MODE = 3;
pub const _NV_TARGET_VIEW_MODE_NV_VIEW_MODE_DUALVIEW: _NV_TARGET_VIEW_MODE = 4;
pub const _NV_TARGET_VIEW_MODE_NV_VIEW_MODE_MULTIVIEW: _NV_TARGET_VIEW_MODE = 5;
#[doc = "! Used in NvAPI_SetView()."]
pub type _NV_TARGET_VIEW_MODE = ::std::os::raw::c_int;
#[doc = "! Used in NvAPI_SetView()."]
pub use self::_NV_TARGET_VIEW_MODE as NV_TARGET_VIEW_MODE;
#[doc = "!< No change"]
pub const _NV_SCALING_NV_SCALING_DEFAULT: _NV_SCALING = 0;
#[doc = "!< Balanced  - Full Screen"]
pub const _NV_SCALING_NV_SCALING_GPU_SCALING_TO_CLOSEST: _NV_SCALING = 1;
#[doc = "!< Force GPU - Full Screen"]
pub const _NV_SCALING_NV_SCALING_GPU_SCALING_TO_NATIVE: _NV_SCALING = 2;
#[doc = "!< Force GPU - Centered\\No Scaling"]
pub const _NV_SCALING_NV_SCALING_GPU_SCANOUT_TO_NATIVE: _NV_SCALING = 3;
#[doc = "!< Force GPU - Aspect Ratio"]
pub const _NV_SCALING_NV_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_NATIVE: _NV_SCALING = 5;
#[doc = "!< Balanced  - Aspect Ratio"]
pub const _NV_SCALING_NV_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_CLOSEST: _NV_SCALING = 6;
#[doc = "!< Balanced  - Centered\\No Scaling"]
pub const _NV_SCALING_NV_SCALING_GPU_SCANOUT_TO_CLOSEST: _NV_SCALING = 7;
#[doc = "!< Force GPU - Integer Scaling"]
pub const _NV_SCALING_NV_SCALING_GPU_INTEGER_ASPECT_SCALING: _NV_SCALING = 8;
pub const _NV_SCALING_NV_SCALING_MONITOR_SCALING: _NV_SCALING = 1;
pub const _NV_SCALING_NV_SCALING_ADAPTER_SCALING: _NV_SCALING = 2;
pub const _NV_SCALING_NV_SCALING_CENTERED: _NV_SCALING = 3;
pub const _NV_SCALING_NV_SCALING_ASPECT_SCALING: _NV_SCALING = 5;
#[doc = "!< For future use"]
pub const _NV_SCALING_NV_SCALING_CUSTOMIZED: _NV_SCALING = 255;
#[doc = "! Scaling modes - used in NvAPI_SetViewEx().\n! \\ingroup dispcontrol"]
pub type _NV_SCALING = ::std::os::raw::c_int;
#[doc = "! Scaling modes - used in NvAPI_SetViewEx().\n! \\ingroup dispcontrol"]
pub use self::_NV_SCALING as NV_SCALING;
pub const _NV_ROTATE_NV_ROTATE_0: _NV_ROTATE = 0;
pub const _NV_ROTATE_NV_ROTATE_90: _NV_ROTATE = 1;
pub const _NV_ROTATE_NV_ROTATE_180: _NV_ROTATE = 2;
pub const _NV_ROTATE_NV_ROTATE_270: _NV_ROTATE = 3;
pub const _NV_ROTATE_NV_ROTATE_IGNORED: _NV_ROTATE = 4;
#[doc = "! \\ingroup dispcontrol"]
pub type _NV_ROTATE = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
pub use self::_NV_ROTATE as NV_ROTATE;
#[doc = "!< unknown. Driver will choose one as following value."]
pub const _NV_FORMAT_NV_FORMAT_UNKNOWN: _NV_FORMAT = 0;
#[doc = "!< for 8bpp mode"]
pub const _NV_FORMAT_NV_FORMAT_P8: _NV_FORMAT = 41;
#[doc = "!< for 16bpp mode"]
pub const _NV_FORMAT_NV_FORMAT_R5G6B5: _NV_FORMAT = 23;
#[doc = "!< for 32bpp mode"]
pub const _NV_FORMAT_NV_FORMAT_A8R8G8B8: _NV_FORMAT = 21;
#[doc = "!< for 64bpp(floating point) mode."]
pub const _NV_FORMAT_NV_FORMAT_A16B16G16R16F: _NV_FORMAT = 113;
#[doc = "! Color formats- used in NvAPI_SetViewEx().\n! \\ingroup dispcontrol"]
pub type _NV_FORMAT = ::std::os::raw::c_int;
#[doc = "! Color formats- used in NvAPI_SetViewEx().\n! \\ingroup dispcontrol"]
pub use self::_NV_FORMAT as NV_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_VIEWPORTF {
    #[doc = "!<  x-coordinate of the viewport top-left point"]
    pub x: f32,
    #[doc = "!<  y-coordinate of the viewport top-left point"]
    pub y: f32,
    #[doc = "!<  Width of the viewport"]
    pub w: f32,
    #[doc = "!<  Height of the viewport"]
    pub h: f32,
}
#[test]
fn bindgen_test_layout_NV_VIEWPORTF() {
    const UNINIT: ::std::mem::MaybeUninit<NV_VIEWPORTF> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_VIEWPORTF>(),
        16usize,
        concat!("Size of: ", stringify!(NV_VIEWPORTF))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_VIEWPORTF>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_VIEWPORTF))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_VIEWPORTF),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_VIEWPORTF),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_VIEWPORTF),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_VIEWPORTF),
            "::",
            stringify!(h)
        )
    );
}
#[doc = "!< get the current timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_CURRENT: _NV_TIMING_OVERRIDE = 0;
#[doc = "!< the timing the driver will use based the current policy"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_AUTO: _NV_TIMING_OVERRIDE = 1;
#[doc = "!< EDID timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_EDID: _NV_TIMING_OVERRIDE = 2;
#[doc = "!< VESA DMT timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_DMT: _NV_TIMING_OVERRIDE = 3;
#[doc = "!< VESA DMT timing with reduced blanking"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_DMT_RB: _NV_TIMING_OVERRIDE = 4;
#[doc = "!< VESA CVT timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_CVT: _NV_TIMING_OVERRIDE = 5;
#[doc = "!< VESA CVT timing with reduced blanking"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_CVT_RB: _NV_TIMING_OVERRIDE = 6;
#[doc = "!< VESA GTF timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_GTF: _NV_TIMING_OVERRIDE = 7;
#[doc = "!< EIA 861x pre-defined timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_EIA861: _NV_TIMING_OVERRIDE = 8;
#[doc = "!< analog SD/HDTV timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_ANALOG_TV: _NV_TIMING_OVERRIDE = 9;
#[doc = "!< NV custom timings"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_CUST: _NV_TIMING_OVERRIDE = 10;
#[doc = "!< NV pre-defined timing (basically the PsF timings)"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_NV_PREDEFINED: _NV_TIMING_OVERRIDE = 11;
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_NV_PSF: _NV_TIMING_OVERRIDE = 11;
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_NV_ASPR: _NV_TIMING_OVERRIDE = 12;
#[doc = "!< Override for SDI timing"]
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVERRIDE_SDI: _NV_TIMING_OVERRIDE = 13;
pub const _NV_TIMING_OVERRIDE_NV_TIMING_OVRRIDE_MAX: _NV_TIMING_OVERRIDE = 14;
#[doc = "! \\ingroup dispcontrol\n! The timing override is not supported yet; must be set to _AUTO. \\n"]
pub type _NV_TIMING_OVERRIDE = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol\n! The timing override is not supported yet; must be set to _AUTO. \\n"]
pub use self::_NV_TIMING_OVERRIDE as NV_TIMING_OVERRIDE;
#[doc = "! \\ingroup dispcontrol\n!  NVIDIA-specific timing extras \\n\n! Used in NV_TIMING."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagNV_TIMINGEXT {
    #[doc = "!< Reserved for NVIDIA hardware-based enhancement, such as double-scan."]
    pub flag: NvU32,
    #[doc = "!< Logical refresh rate to present"]
    pub rr: NvU16,
    #[doc = "!< Physical vertical refresh rate in 0.001Hz"]
    pub rrx1k: NvU32,
    #[doc = "!< Display aspect ratio Hi(aspect):horizontal-aspect, Low(aspect):vertical-aspect"]
    pub aspect: NvU32,
    #[doc = "!< Bit-wise pixel repetition factor: 0x1:no pixel repetition; 0x2:each pixel repeats twice horizontally,.."]
    pub rep: NvU16,
    #[doc = "!< Timing standard"]
    pub status: NvU32,
    #[doc = "!< Timing name"]
    pub name: [NvU8; 40usize],
}
#[test]
fn bindgen_test_layout_tagNV_TIMINGEXT() {
    const UNINIT: ::std::mem::MaybeUninit<tagNV_TIMINGEXT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagNV_TIMINGEXT>(),
        64usize,
        concat!("Size of: ", stringify!(tagNV_TIMINGEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<tagNV_TIMINGEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(tagNV_TIMINGEXT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagNV_TIMINGEXT),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagNV_TIMINGEXT),
            "::",
            stringify!(rr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrx1k) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagNV_TIMINGEXT),
            "::",
            stringify!(rrx1k)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aspect) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tagNV_TIMINGEXT),
            "::",
            stringify!(aspect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rep) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tagNV_TIMINGEXT),
            "::",
            stringify!(rep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tagNV_TIMINGEXT),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tagNV_TIMINGEXT),
            "::",
            stringify!(name)
        )
    );
}
#[doc = "! \\ingroup dispcontrol\n!  NVIDIA-specific timing extras \\n\n! Used in NV_TIMING."]
pub type NV_TIMINGEXT = tagNV_TIMINGEXT;
#[doc = "! \\ingroup dispcontrol\n!The very basic timing structure based on the VESA standard:\n! \\code\n!            |<----------------------------htotal--------------------------->|\n!             ---------\"active\" video-------->|<-------blanking------>|<-----\n!            |<-------hvisible-------->|<-hb->|<-hfp->|<-hsw->|<-hbp->|<-hb->|\n! --------- -+-------------------------+      |       |       |       |      |\n!   A      A |                         |      |       |       |       |      |\n!   :      : |                         |      |       |       |       |      |\n!   :      : |                         |      |       |       |       |      |\n!   :vertical|    addressable video    |      |       |       |       |      |\n!   : visible|                         |      |       |       |       |      |\n!   :      : |                         |      |       |       |       |      |\n!   :      : |                         |      |       |       |       |      |\n! vertical V |                         |      |       |       |       |      |\n!  total   --+-------------------------+      |       |       |       |      |\n!   :      vb         border                  |       |       |       |      |\n!   :      -----------------------------------+       |       |       |      |\n!   :      vfp        front porch                     |       |       |      |\n!   :      -------------------------------------------+       |       |      |\n!   :      vsw        sync width                              |       |      |\n!   :      ---------------------------------------------------+       |      |\n!   :      vbp        back porch                                      |      |\n!   :      -----------------------------------------------------------+      |\n!   V      vb         border                                                 |\n! ---------------------------------------------------------------------------+\n! \\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_TIMING {
    #[doc = "!< horizontal visible"]
    pub HVisible: NvU16,
    #[doc = "!< horizontal border"]
    pub HBorder: NvU16,
    #[doc = "!< horizontal front porch"]
    pub HFrontPorch: NvU16,
    #[doc = "!< horizontal sync width"]
    pub HSyncWidth: NvU16,
    #[doc = "!< horizontal total"]
    pub HTotal: NvU16,
    #[doc = "!< horizontal sync polarity: 1-negative, 0-positive"]
    pub HSyncPol: NvU8,
    #[doc = "!< vertical visible"]
    pub VVisible: NvU16,
    #[doc = "!< vertical border"]
    pub VBorder: NvU16,
    #[doc = "!< vertical front porch"]
    pub VFrontPorch: NvU16,
    #[doc = "!< vertical sync width"]
    pub VSyncWidth: NvU16,
    #[doc = "!< vertical total"]
    pub VTotal: NvU16,
    #[doc = "!< vertical sync polarity: 1-negative, 0-positive"]
    pub VSyncPol: NvU8,
    #[doc = "!< 1-interlaced, 0-progressive"]
    pub interlaced: NvU16,
    #[doc = "!< pixel clock in 10 kHz"]
    pub pclk: NvU32,
    pub etc: NV_TIMINGEXT,
}
#[test]
fn bindgen_test_layout__NV_TIMING() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_TIMING> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_TIMING>(),
        96usize,
        concat!("Size of: ", stringify!(_NV_TIMING))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_TIMING>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_TIMING))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HVisible) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(HVisible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HBorder) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(HBorder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HFrontPorch) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(HFrontPorch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HSyncWidth) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(HSyncWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HTotal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(HTotal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HSyncPol) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(HSyncPol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VVisible) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(VVisible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBorder) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(VBorder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VFrontPorch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(VFrontPorch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VSyncWidth) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(VSyncWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VTotal) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(VTotal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VSyncPol) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(VSyncPol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlaced) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(interlaced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pclk) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(pclk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).etc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING),
            "::",
            stringify!(etc)
        )
    );
}
#[doc = "! \\ingroup dispcontrol\n!The very basic timing structure based on the VESA standard:\n! \\code\n!            |<----------------------------htotal--------------------------->|\n!             ---------\"active\" video-------->|<-------blanking------>|<-----\n!            |<-------hvisible-------->|<-hb->|<-hfp->|<-hsw->|<-hbp->|<-hb->|\n! --------- -+-------------------------+      |       |       |       |      |\n!   A      A |                         |      |       |       |       |      |\n!   :      : |                         |      |       |       |       |      |\n!   :      : |                         |      |       |       |       |      |\n!   :vertical|    addressable video    |      |       |       |       |      |\n!   : visible|                         |      |       |       |       |      |\n!   :      : |                         |      |       |       |       |      |\n!   :      : |                         |      |       |       |       |      |\n! vertical V |                         |      |       |       |       |      |\n!  total   --+-------------------------+      |       |       |       |      |\n!   :      vb         border                  |       |       |       |      |\n!   :      -----------------------------------+       |       |       |      |\n!   :      vfp        front porch                     |       |       |      |\n!   :      -------------------------------------------+       |       |      |\n!   :      vsw        sync width                              |       |      |\n!   :      ---------------------------------------------------+       |      |\n!   :      vbp        back porch                                      |      |\n!   :      -----------------------------------------------------------+      |\n!   V      vb         border                                                 |\n! ---------------------------------------------------------------------------+\n! \\endcode"]
pub type NV_TIMING = _NV_TIMING;
#[doc = "! \\ingroup dispcontrol\n! Used in NvAPI_SetView() and NvAPI_GetView()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_VIEW_TARGET_INFO {
    #[doc = "!< (IN) structure version"]
    pub version: NvU32,
    #[doc = "!< (IN) target count"]
    pub count: NvU32,
    pub target: [NV_VIEW_TARGET_INFO__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_VIEW_TARGET_INFO__bindgen_ty_1 {
    #[doc = "!< (IN/OUT) Device mask"]
    pub deviceMask: NvU32,
    #[doc = "!< (IN/OUT) Source ID - values will be based on the number of heads exposed per GPU."]
    pub sourceId: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_NV_VIEW_TARGET_INFO__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_VIEW_TARGET_INFO__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_VIEW_TARGET_INFO__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(NV_VIEW_TARGET_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_VIEW_TARGET_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_VIEW_TARGET_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceMask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_VIEW_TARGET_INFO__bindgen_ty_1),
            "::",
            stringify!(deviceMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_VIEW_TARGET_INFO__bindgen_ty_1),
            "::",
            stringify!(sourceId)
        )
    );
}
impl NV_VIEW_TARGET_INFO__bindgen_ty_1 {
    #[inline]
    pub fn bPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bInterlaced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bInterlaced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bGDIPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bGDIPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bForceModeSet(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bForceModeSet(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bPrimary: NvU32,
        bInterlaced: NvU32,
        bGDIPrimary: NvU32,
        bForceModeSet: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bPrimary: u32 = unsafe { ::std::mem::transmute(bPrimary) };
            bPrimary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bInterlaced: u32 = unsafe { ::std::mem::transmute(bInterlaced) };
            bInterlaced as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bGDIPrimary: u32 = unsafe { ::std::mem::transmute(bGDIPrimary) };
            bGDIPrimary as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bForceModeSet: u32 = unsafe { ::std::mem::transmute(bForceModeSet) };
            bForceModeSet as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_VIEW_TARGET_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<NV_VIEW_TARGET_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_VIEW_TARGET_INFO>(),
        32usize,
        concat!("Size of: ", stringify!(NV_VIEW_TARGET_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_VIEW_TARGET_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_VIEW_TARGET_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_VIEW_TARGET_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_VIEW_TARGET_INFO),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_VIEW_TARGET_INFO),
            "::",
            stringify!(target)
        )
    );
}
extern "C" {
    #[doc = "! \\ingroup dispcontrol"]
    pub fn NvAPI_SetView(
        hNvDisplay: NvDisplayHandle,
        pTargetInfo: *mut NV_VIEW_TARGET_INFO,
        targetView: NV_TARGET_VIEW_MODE,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol\n! Used in NV_DISPLAY_PATH_INFO."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_PATH {
    #[doc = "!< (IN) Device mask"]
    pub deviceMask: NvU32,
    #[doc = "!< (IN) Values will be based on the number of heads exposed per GPU(0, 1?)"]
    pub sourceId: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "!< (IN) Specify connector type. For TV only."]
    pub connector: NV_GPU_CONNECTOR_TYPE,
    #[doc = "!< (IN) Width of the mode"]
    pub width: NvU32,
    #[doc = "!< (IN) Height of the mode"]
    pub height: NvU32,
    #[doc = "!< (IN) Depth of the mode"]
    pub depth: NvU32,
    #[doc = "!<      Color format if it needs to be specified. Not used now."]
    pub colorFormat: NV_FORMAT,
    #[doc = "!< (IN) Rotation setting."]
    pub rotation: NV_ROTATE,
    #[doc = "!< (IN) Scaling setting"]
    pub scaling: NV_SCALING,
    #[doc = "!< (IN) Refresh rate of the mode"]
    pub refreshRate: NvU32,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "!< (IN) To choose the last TV format set this value to NV_DISPLAY_TV_FORMAT_NONE"]
    pub tvFormat: NV_DISPLAY_TV_FORMAT,
    #[doc = "!< (IN/OUT) X-offset of this display on the Windows desktop"]
    pub posx: NvU32,
    #[doc = "!< (IN/OUT) Y-offset of this display on the Windows desktop"]
    pub posy: NvU32,
    pub _bitfield_align_3: [u32; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_PATH() {
    const UNINIT: ::std::mem::MaybeUninit<NV_DISPLAY_PATH> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_PATH>(),
        64usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_PATH))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_PATH>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_DISPLAY_PATH))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceMask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(deviceMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(sourceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connector) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(connector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaling) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(scaling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refreshRate) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(refreshRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tvFormat) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(tvFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posx) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(posx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posy) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH),
            "::",
            stringify!(posy)
        )
    );
}
impl NV_DISPLAY_PATH {
    #[inline]
    pub fn bPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bPrimary: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bPrimary: u32 = unsafe { ::std::mem::transmute(bPrimary) };
            bPrimary as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn interlaced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interlaced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(interlaced: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interlaced: u32 = unsafe { ::std::mem::transmute(interlaced) };
            interlaced as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn bGDIPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bGDIPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bForceModeSet(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bForceModeSet(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bFocusDisplay(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bFocusDisplay(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpuId(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(3usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_gpuId(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(3usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        bGDIPrimary: NvU32,
        bForceModeSet: NvU32,
        bFocusDisplay: NvU32,
        gpuId: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bGDIPrimary: u32 = unsafe { ::std::mem::transmute(bGDIPrimary) };
            bGDIPrimary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bForceModeSet: u32 = unsafe { ::std::mem::transmute(bForceModeSet) };
            bForceModeSet as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bFocusDisplay: u32 = unsafe { ::std::mem::transmute(bFocusDisplay) };
            bFocusDisplay as u64
        });
        __bindgen_bitfield_unit.set(3usize, 24u8, {
            let gpuId: u32 = unsafe { ::std::mem::transmute(gpuId) };
            gpuId as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol\n! Used in NvAPI_SetViewEx() and NvAPI_GetViewEx()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_PATH_INFO_V3 {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    #[doc = "!< (IN) Path count"]
    pub count: NvU32,
    pub path: [NV_DISPLAY_PATH; 2usize],
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_PATH_INFO_V3() {
    const UNINIT: ::std::mem::MaybeUninit<NV_DISPLAY_PATH_INFO_V3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_PATH_INFO_V3>(),
        136usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_PATH_INFO_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_PATH_INFO_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_DISPLAY_PATH_INFO_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH_INFO_V3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH_INFO_V3),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH_INFO_V3),
            "::",
            stringify!(path)
        )
    );
}
#[doc = "! \\ingroup dispcontrol\n! Used in NvAPI_SetViewEx() and NvAPI_GetViewEx()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_PATH_INFO {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    #[doc = "!< (IN) Path count"]
    pub count: NvU32,
    pub path: [NV_DISPLAY_PATH; 4usize],
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_PATH_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<NV_DISPLAY_PATH_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_PATH_INFO>(),
        264usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_PATH_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_PATH_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_DISPLAY_PATH_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH_INFO),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PATH_INFO),
            "::",
            stringify!(path)
        )
    );
}
extern "C" {
    #[doc = "! \\ingroup dispcontrol"]
    pub fn NvAPI_SetViewEx(
        hNvDisplay: NvDisplayHandle,
        pPathInfo: *mut NV_DISPLAY_PATH_INFO,
        displayView: NV_TARGET_VIEW_MODE,
    ) -> NvAPI_Status;
}
#[doc = "\n! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_POSITION {
    pub x: NvS32,
    pub y: NvS32,
}
#[test]
fn bindgen_test_layout__NV_POSITION() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_POSITION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_POSITION>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_POSITION))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_POSITION>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_POSITION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_POSITION),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_POSITION),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "\n! \\ingroup dispcontrol"]
pub type NV_POSITION = _NV_POSITION;
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_RESOLUTION {
    pub width: NvU32,
    pub height: NvU32,
    pub colorDepth: NvU32,
}
#[test]
fn bindgen_test_layout__NV_RESOLUTION() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_RESOLUTION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_RESOLUTION>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_RESOLUTION))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_RESOLUTION>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_RESOLUTION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_RESOLUTION),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_RESOLUTION),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorDepth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_RESOLUTION),
            "::",
            stringify!(colorDepth)
        )
    );
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_RESOLUTION = _NV_RESOLUTION;
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 {
    pub version: NvU32,
    #[doc = "!< (IN) rotation setting."]
    pub rotation: NV_ROTATE,
    #[doc = "!< (IN) scaling setting."]
    pub scaling: NV_SCALING,
    #[doc = "!< (IN) Non-interlaced Refresh Rate of the mode, multiplied by 1000, 0 = ignored\n!< This is the value which driver reports to the OS."]
    pub refreshRate1K: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Specify connector type. For TV only, ignored if tvFormat == NV_DISPLAY_TV_FORMAT_NONE"]
    pub connector: NV_GPU_CONNECTOR_TYPE,
    #[doc = "!< (IN) to choose the last TV format set this value to NV_DISPLAY_TV_FORMAT_NONE\n!< In case of NvAPI_DISP_GetDisplayConfig(), this field will indicate the currently applied TV format;\n!< if no TV format is applied, this field will have NV_DISPLAY_TV_FORMAT_NONE value.\n!< In case of NvAPI_DISP_SetDisplayConfig(), this field should only be set in case of TVs;\n!< for other displays this field will be ignored and resolution & refresh rate specified in input will be used to apply the TV format."]
    pub tvFormat: NV_DISPLAY_TV_FORMAT,
    #[doc = "!< Ignored if timingOverride == NV_TIMING_OVERRIDE_CURRENT"]
    pub timingOverride: NV_TIMING_OVERRIDE,
    #[doc = "!< Scan out timing, valid only if timingOverride == NV_TIMING_OVERRIDE_CUST\n!< The value NV_TIMING::NV_TIMINGEXT::rrx1k is obtained from the EDID. The driver may\n!< tweak this value for HDTV, stereo, etc., before reporting it to the OS."]
    pub timing: NV_TIMING,
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaling) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
            "::",
            stringify!(scaling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refreshRate1K) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
            "::",
            stringify!(refreshRate1K)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
            "::",
            stringify!(connector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tvFormat) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
            "::",
            stringify!(tvFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timingOverride) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
            "::",
            stringify!(timingOverride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timing) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1),
            "::",
            stringify!(timing)
        )
    );
}
impl _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 {
    #[inline]
    pub fn interlaced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interlaced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn primary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_primary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBit1(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBit1(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableVirtualModeSupport(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableVirtualModeSupport(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isPreferredUnscaledTarget(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isPreferredUnscaledTarget(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interlaced: NvU32,
        primary: NvU32,
        reservedBit1: NvU32,
        disableVirtualModeSupport: NvU32,
        isPreferredUnscaledTarget: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interlaced: u32 = unsafe { ::std::mem::transmute(interlaced) };
            interlaced as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let primary: u32 = unsafe { ::std::mem::transmute(primary) };
            primary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let reservedBit1: u32 = unsafe { ::std::mem::transmute(reservedBit1) };
            reservedBit1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disableVirtualModeSupport: u32 =
                unsafe { ::std::mem::transmute(disableVirtualModeSupport) };
            disableVirtualModeSupport as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isPreferredUnscaledTarget: u32 =
                unsafe { ::std::mem::transmute(isPreferredUnscaledTarget) };
            isPreferredUnscaledTarget as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 =
    _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1;
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO = NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1;
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1 {
    #[doc = "!< Display ID"]
    pub displayId: NvU32,
    #[doc = "!< May be NULL if no advanced settings are required. NULL for Non-NVIDIA Display."]
    pub details: *mut NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO,
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1),
            "::",
            stringify!(displayId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1),
            "::",
            stringify!(details)
        )
    );
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1 = _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1;
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2 {
    #[doc = "!< Display ID"]
    pub displayId: NvU32,
    #[doc = "!< May be NULL if no advanced settings are required"]
    pub details: *mut NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO,
    #[doc = "!< Windows CCD target ID. Must be present only for non-NVIDIA adapter, for NVIDIA adapter this parameter is ignored."]
    pub targetId: NvU32,
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2),
            "::",
            stringify!(displayId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2),
            "::",
            stringify!(details)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2),
            "::",
            stringify!(targetId)
        )
    );
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2 = _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2;
#[doc = "! \\ingroup dispcontrol\n! As version is not defined for this structure, we will be using version of NV_DISPLAYCONFIG_PATH_INFO"]
pub type NV_DISPLAYCONFIG_PATH_TARGET_INFO = NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2;
pub const _NV_DISPLAYCONFIG_SPANNING_ORIENTATION_NV_DISPLAYCONFIG_SPAN_NONE:
    _NV_DISPLAYCONFIG_SPANNING_ORIENTATION = 0;
pub const _NV_DISPLAYCONFIG_SPANNING_ORIENTATION_NV_DISPLAYCONFIG_SPAN_HORIZONTAL:
    _NV_DISPLAYCONFIG_SPANNING_ORIENTATION = 1;
pub const _NV_DISPLAYCONFIG_SPANNING_ORIENTATION_NV_DISPLAYCONFIG_SPAN_VERTICAL:
    _NV_DISPLAYCONFIG_SPANNING_ORIENTATION = 2;
#[doc = "! \\ingroup dispcontrol"]
pub type _NV_DISPLAYCONFIG_SPANNING_ORIENTATION = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
pub use self::_NV_DISPLAYCONFIG_SPANNING_ORIENTATION as NV_DISPLAYCONFIG_SPANNING_ORIENTATION;
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 {
    pub resolution: NV_RESOLUTION,
    #[doc = "!< Ignored at present, must be NV_FORMAT_UNKNOWN (0)"]
    pub colorFormat: NV_FORMAT,
    #[doc = "!< Is all positions are 0 or invalid, displays will be automatically\n!< positioned from left to right with GDI Primary at 0,0, and all\n!< other displays in the order of the path array."]
    pub position: NV_POSITION,
    #[doc = "!< Spanning is only supported on XP"]
    pub spanningOrientation: NV_DISPLAYCONFIG_SPANNING_ORIENTATION,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolution) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1),
            "::",
            stringify!(resolution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spanningOrientation) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1),
            "::",
            stringify!(spanningOrientation)
        )
    );
}
impl _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 {
    #[inline]
    pub fn bGDIPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bGDIPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSLIFocus(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSLIFocus(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bGDIPrimary: NvU32,
        bSLIFocus: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bGDIPrimary: u32 = unsafe { ::std::mem::transmute(bGDIPrimary) };
            bGDIPrimary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSLIFocus: u32 = unsafe { ::std::mem::transmute(bSLIFocus) };
            bSLIFocus as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 = _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1;
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_INFO_V1 {
    pub version: NvU32,
    #[doc = "!< This field is reserved. There is ongoing debate if we need this field.\n!< Identifies sourceIds used by Windows. If all sourceIds are 0,\n!< these will be computed automatically."]
    pub reserved_sourceId: NvU32,
    #[doc = "!< Number of elements in targetInfo array"]
    pub targetInfoCount: NvU32,
    pub targetInfo: *mut NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1,
    #[doc = "!< May be NULL if mode info is not important"]
    pub sourceModeInfo: *mut NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1,
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_PATH_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_DISPLAYCONFIG_PATH_INFO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_PATH_INFO_V1>(),
        32usize,
        concat!("Size of: ", stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_PATH_INFO_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_sourceId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1),
            "::",
            stringify!(reserved_sourceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetInfoCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1),
            "::",
            stringify!(targetInfoCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1),
            "::",
            stringify!(targetInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceModeInfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO_V1),
            "::",
            stringify!(sourceModeInfo)
        )
    );
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_INFO_V1 = _NV_DISPLAYCONFIG_PATH_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_INFO {
    pub version: NvU32,
    pub __bindgen_anon_1: _NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1,
    #[doc = "!< Number of elements in targetInfo array"]
    pub targetInfoCount: NvU32,
    pub targetInfo: *mut NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2,
    #[doc = "!< May be NULL if mode info is not important"]
    pub sourceModeInfo: *mut NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Used by Non-NVIDIA adapter for pointer to OS Adapter of LUID\n!< type, type casted to void *."]
    pub pOSAdapterID: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1 {
    #[doc = "!< Identifies sourceId used by Windows CCD. This can be optionally set."]
    pub sourceId: NvU32,
    #[doc = "!< Only for compatibility"]
    pub reserved_sourceId: NvU32,
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1),
            "::",
            stringify!(sourceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_sourceId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1),
            "::",
            stringify!(reserved_sourceId)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_DISPLAYCONFIG_PATH_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_DISPLAYCONFIG_PATH_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAYCONFIG_PATH_INFO>(),
        48usize,
        concat!("Size of: ", stringify!(_NV_DISPLAYCONFIG_PATH_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAYCONFIG_PATH_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_DISPLAYCONFIG_PATH_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetInfoCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO),
            "::",
            stringify!(targetInfoCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO),
            "::",
            stringify!(targetInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceModeInfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO),
            "::",
            stringify!(sourceModeInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pOSAdapterID) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAYCONFIG_PATH_INFO),
            "::",
            stringify!(pOSAdapterID)
        )
    );
}
impl _NV_DISPLAYCONFIG_PATH_INFO {
    #[inline]
    pub fn IsNonNVIDIAAdapter(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsNonNVIDIAAdapter(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsNonNVIDIAAdapter: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsNonNVIDIAAdapter: u32 = unsafe { ::std::mem::transmute(IsNonNVIDIAAdapter) };
            IsNonNVIDIAAdapter as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_PATH_INFO_V2 = _NV_DISPLAYCONFIG_PATH_INFO;
pub type NV_DISPLAYCONFIG_PATH_INFO = NV_DISPLAYCONFIG_PATH_INFO_V2;
#[doc = "! \\ingroup dispcontrol"]
pub type NV_DISPLAYCONFIG_SOURCE_MODE_INFO = NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1;
pub const _NV_DISPLAYCONFIG_FLAGS_NV_DISPLAYCONFIG_VALIDATE_ONLY: _NV_DISPLAYCONFIG_FLAGS = 1;
pub const _NV_DISPLAYCONFIG_FLAGS_NV_DISPLAYCONFIG_SAVE_TO_PERSISTENCE: _NV_DISPLAYCONFIG_FLAGS = 2;
#[doc = "!< Driver reload is permitted if necessary"]
pub const _NV_DISPLAYCONFIG_FLAGS_NV_DISPLAYCONFIG_DRIVER_RELOAD_ALLOWED: _NV_DISPLAYCONFIG_FLAGS =
    4;
#[doc = "!< Refresh OS mode list."]
pub const _NV_DISPLAYCONFIG_FLAGS_NV_DISPLAYCONFIG_FORCE_MODE_ENUMERATION: _NV_DISPLAYCONFIG_FLAGS =
    8;
#[doc = "!< Tell OS to avoid optimizing CommitVidPn call during a modeset"]
pub const _NV_DISPLAYCONFIG_FLAGS_NV_FORCE_COMMIT_VIDPN: _NV_DISPLAYCONFIG_FLAGS = 16;
#[doc = "! \\ingroup dispcontrol"]
pub type _NV_DISPLAYCONFIG_FLAGS = ::std::os::raw::c_int;
#[doc = "! \\ingroup dispcontrol"]
pub use self::_NV_DISPLAYCONFIG_FLAGS as NV_DISPLAYCONFIG_FLAGS;
pub type NvAPI_UnicodeString = [NvU16; 2048usize];
pub type NvAPI_LPCWSTR = *const NvU16;
pub const _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID_NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_CORE:
    _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID = 0;
pub const _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID_NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_UNDEFINED:
    _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID = 16;
#[doc = "! \\ingroup gpuclock"]
pub type _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpuclock"]
pub use self::_NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID as NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID;
pub const _NV_GPU_PUBLIC_CLOCK_ID_NVAPI_GPU_PUBLIC_CLOCK_GRAPHICS: _NV_GPU_PUBLIC_CLOCK_ID = 0;
pub const _NV_GPU_PUBLIC_CLOCK_ID_NVAPI_GPU_PUBLIC_CLOCK_MEMORY: _NV_GPU_PUBLIC_CLOCK_ID = 4;
pub const _NV_GPU_PUBLIC_CLOCK_ID_NVAPI_GPU_PUBLIC_CLOCK_PROCESSOR: _NV_GPU_PUBLIC_CLOCK_ID = 7;
pub const _NV_GPU_PUBLIC_CLOCK_ID_NVAPI_GPU_PUBLIC_CLOCK_VIDEO: _NV_GPU_PUBLIC_CLOCK_ID = 8;
pub const _NV_GPU_PUBLIC_CLOCK_ID_NVAPI_GPU_PUBLIC_CLOCK_UNDEFINED: _NV_GPU_PUBLIC_CLOCK_ID = 32;
#[doc = "! \\ingroup gpuclock"]
pub type _NV_GPU_PUBLIC_CLOCK_ID = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpuclock"]
pub use self::_NV_GPU_PUBLIC_CLOCK_ID as NV_GPU_PUBLIC_CLOCK_ID;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P0: _NV_GPU_PERF_PSTATE_ID = 0;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P1: _NV_GPU_PERF_PSTATE_ID = 1;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P2: _NV_GPU_PERF_PSTATE_ID = 2;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P3: _NV_GPU_PERF_PSTATE_ID = 3;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P4: _NV_GPU_PERF_PSTATE_ID = 4;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P5: _NV_GPU_PERF_PSTATE_ID = 5;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P6: _NV_GPU_PERF_PSTATE_ID = 6;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P7: _NV_GPU_PERF_PSTATE_ID = 7;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P8: _NV_GPU_PERF_PSTATE_ID = 8;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P9: _NV_GPU_PERF_PSTATE_ID = 9;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P10: _NV_GPU_PERF_PSTATE_ID = 10;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P11: _NV_GPU_PERF_PSTATE_ID = 11;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P12: _NV_GPU_PERF_PSTATE_ID = 12;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P13: _NV_GPU_PERF_PSTATE_ID = 13;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P14: _NV_GPU_PERF_PSTATE_ID = 14;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_P15: _NV_GPU_PERF_PSTATE_ID = 15;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_UNDEFINED: _NV_GPU_PERF_PSTATE_ID = 16;
pub const _NV_GPU_PERF_PSTATE_ID_NVAPI_GPU_PERF_PSTATE_ALL: _NV_GPU_PERF_PSTATE_ID = 17;
#[doc = "! \\addtogroup gpupstate\n! @{"]
pub type _NV_GPU_PERF_PSTATE_ID = ::std::os::raw::c_int;
#[doc = "! \\addtogroup gpupstate\n! @{"]
pub use self::_NV_GPU_PERF_PSTATE_ID as NV_GPU_PERF_PSTATE_ID;
#[doc = "! Clock domains that use single frequency value within given pstate"]
pub const NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID_NVAPI_GPU_PERF_PSTATE20_CLOCK_TYPE_SINGLE:
    NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID = 0;
#[doc = "! Clock domains that allow range of frequency values within given pstate"]
pub const NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID_NVAPI_GPU_PERF_PSTATE20_CLOCK_TYPE_RANGE:
    NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID = 1;
#[doc = "! Used to identify clock type"]
pub type NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID = ::std::os::raw::c_int;
#[doc = "! Used to describe both voltage and frequency deltas"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES20_PARAM_DELTA {
    #[doc = "! Value of parameter delta (in respective units [kHz, uV])"]
    pub value: NvS32,
    pub valueRange: NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1 {
    #[doc = "! Min value allowed for parameter delta (in respective units [kHz, uV])"]
    pub min: NvS32,
    #[doc = "! Max value allowed for parameter delta (in respective units [kHz, uV])"]
    pub max: NvS32,
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1),
            "::",
            stringify!(max)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES20_PARAM_DELTA() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PERF_PSTATES20_PARAM_DELTA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES20_PARAM_DELTA>(),
        12usize,
        concat!("Size of: ", stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES20_PARAM_DELTA>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valueRange) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES20_PARAM_DELTA),
            "::",
            stringify!(valueRange)
        )
    );
}
#[doc = "! Used to describe single clock entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PSTATE20_CLOCK_ENTRY_V1 {
    #[doc = "! ID of the clock domain"]
    pub domainId: NV_GPU_PUBLIC_CLOCK_ID,
    #[doc = "! Clock type ID"]
    pub typeId: NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "! Current frequency delta from nominal settings in (kHz)"]
    pub freqDelta_kHz: NV_GPU_PERF_PSTATES20_PARAM_DELTA,
    pub data: NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1,
}
#[doc = "! Clock domain type dependant information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1 {
    pub single: NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1,
    pub range: NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "! Clock frequency within given pstate in (kHz)"]
    pub freq_kHz: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq_kHz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(freq_kHz)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "! Min clock frequency within given pstate in (kHz)"]
    pub minFreq_kHz: NvU32,
    #[doc = "! Max clock frequency within given pstate in (kHz)"]
    pub maxFreq_kHz: NvU32,
    #[doc = "! Voltage domain ID and value range in (uV) required for this clock"]
    pub domainId: NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID,
    pub minVoltage_uV: NvU32,
    pub maxVoltage_uV: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minFreq_kHz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(minFreq_kHz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxFreq_kHz) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(maxFreq_kHz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domainId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(domainId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minVoltage_uV) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(minVoltage_uV)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxVoltage_uV) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(maxVoltage_uV)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).single) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1),
            "::",
            stringify!(single)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1),
            "::",
            stringify!(range)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_GPU_PSTATE20_CLOCK_ENTRY_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PSTATE20_CLOCK_ENTRY_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1>(),
        44usize,
        concat!("Size of: ", stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PSTATE20_CLOCK_ENTRY_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domainId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1),
            "::",
            stringify!(domainId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typeId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1),
            "::",
            stringify!(typeId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freqDelta_kHz) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1),
            "::",
            stringify!(freqDelta_kHz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_CLOCK_ENTRY_V1),
            "::",
            stringify!(data)
        )
    );
}
impl NV_GPU_PSTATE20_CLOCK_ENTRY_V1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Used to describe single base voltage entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1 {
    #[doc = "! ID of the voltage domain"]
    pub domainId: NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "! Current base voltage settings in [uV]"]
    pub volt_uV: NvU32,
    pub voltDelta_uV: NV_GPU_PERF_PSTATES20_PARAM_DELTA,
}
#[test]
fn bindgen_test_layout_NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domainId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1),
            "::",
            stringify!(domainId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volt_uV) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1),
            "::",
            stringify!(volt_uV)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voltDelta_uV) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1),
            "::",
            stringify!(voltDelta_uV)
        )
    );
}
impl NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Used in NvAPI_GPU_GetPstates20() interface call."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES20_INFO_V1 {
    #[doc = "! Version info of the structure (NV_GPU_PERF_PSTATES20_INFO_VER<n>)"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "! Number of populated pstates"]
    pub numPstates: NvU32,
    #[doc = "! Number of populated clocks (per pstate)"]
    pub numClocks: NvU32,
    #[doc = "! Number of populated base voltages (per pstate)"]
    pub numBaseVoltages: NvU32,
    pub pstates: [NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1; 16usize],
}
#[doc = "! Performance state (P-State) settings\n! Valid index range is 0 to numPstates-1"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1 {
    #[doc = "! ID of the P-State"]
    pub pstateId: NV_GPU_PERF_PSTATE_ID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "! Array of clock entries\n! Valid index range is 0 to numClocks-1"]
    pub clocks: [NV_GPU_PSTATE20_CLOCK_ENTRY_V1; 8usize],
    #[doc = "! Array of baseVoltage entries\n! Valid index range is 0 to numBaseVoltages-1"]
    pub baseVoltages: [NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1; 4usize],
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1>(),
        456usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pstateId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(pstateId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clocks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(clocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseVoltages) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(baseVoltages)
        )
    );
}
impl NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES20_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PERF_PSTATES20_INFO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES20_INFO_V1>(),
        7316usize,
        concat!("Size of: ", stringify!(NV_GPU_PERF_PSTATES20_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES20_INFO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_PERF_PSTATES20_INFO_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES20_INFO_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPstates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES20_INFO_V1),
            "::",
            stringify!(numPstates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numClocks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES20_INFO_V1),
            "::",
            stringify!(numClocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numBaseVoltages) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES20_INFO_V1),
            "::",
            stringify!(numBaseVoltages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pstates) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES20_INFO_V1),
            "::",
            stringify!(pstates)
        )
    );
}
impl NV_GPU_PERF_PSTATES20_INFO_V1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Used in NvAPI_GPU_GetPstates20() interface call."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_PERF_PSTATES20_INFO_V2 {
    #[doc = "! Version info of the structure (NV_GPU_PERF_PSTATES20_INFO_VER<n>)"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "! Number of populated pstates"]
    pub numPstates: NvU32,
    #[doc = "! Number of populated clocks (per pstate)"]
    pub numClocks: NvU32,
    #[doc = "! Number of populated base voltages (per pstate)"]
    pub numBaseVoltages: NvU32,
    pub pstates: [_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1; 16usize],
    pub ov: _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2,
}
#[doc = "! Performance state (P-State) settings\n! Valid index range is 0 to numPstates-1"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1 {
    #[doc = "! ID of the P-State"]
    pub pstateId: NV_GPU_PERF_PSTATE_ID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "! Array of clock entries\n! Valid index range is 0 to numClocks-1"]
    pub clocks: [NV_GPU_PSTATE20_CLOCK_ENTRY_V1; 8usize],
    #[doc = "! Array of baseVoltage entries\n! Valid index range is 0 to numBaseVoltages-1"]
    pub baseVoltages: [NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1; 4usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1>(),
        456usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pstateId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1),
            "::",
            stringify!(pstateId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clocks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1),
            "::",
            stringify!(clocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseVoltages) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1),
            "::",
            stringify!(baseVoltages)
        )
    );
}
impl _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! OV settings - Please refer to NVIDIA over-volting recommendation to understand impact of this functionality\n! Valid index range is 0 to numVoltages-1"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2 {
    #[doc = "! Number of populated voltages"]
    pub numVoltages: NvU32,
    #[doc = "! Array of voltage entries\n! Valid index range is 0 to numVoltages-1"]
    pub voltages: [NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1; 4usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2>(),
        100usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numVoltages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2),
            "::",
            stringify!(numVoltages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voltages) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2),
            "::",
            stringify!(voltages)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_GPU_PERF_PSTATES20_INFO_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_PERF_PSTATES20_INFO_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_PERF_PSTATES20_INFO_V2>(),
        7416usize,
        concat!("Size of: ", stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_PERF_PSTATES20_INFO_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPstates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2),
            "::",
            stringify!(numPstates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numClocks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2),
            "::",
            stringify!(numClocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numBaseVoltages) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2),
            "::",
            stringify!(numBaseVoltages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pstates) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2),
            "::",
            stringify!(pstates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ov) as usize - ptr as usize },
        7316usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_PERF_PSTATES20_INFO_V2),
            "::",
            stringify!(ov)
        )
    );
}
impl _NV_GPU_PERF_PSTATES20_INFO_V2 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Used in NvAPI_GPU_GetPstates20() interface call."]
pub type NV_GPU_PERF_PSTATES20_INFO_V2 = _NV_GPU_PERF_PSTATES20_INFO_V2;
#[doc = "! Used in NvAPI_GPU_GetPstates20() interface call."]
pub type NV_GPU_PERF_PSTATES20_INFO = NV_GPU_PERF_PSTATES20_INFO_V2;
#[doc = "! \\ingroup driverapi\n! Used in NvAPI_GetDisplayDriverVersion()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_DRIVER_VERSION {
    pub version: NvU32,
    pub drvVersion: NvU32,
    pub bldChangeListNum: NvU32,
    pub szBuildBranchString: NvAPI_ShortString,
    pub szAdapterString: NvAPI_ShortString,
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_DRIVER_VERSION() {
    const UNINIT: ::std::mem::MaybeUninit<NV_DISPLAY_DRIVER_VERSION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_DRIVER_VERSION>(),
        140usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_DRIVER_VERSION))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_DRIVER_VERSION>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_DISPLAY_DRIVER_VERSION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_VERSION),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drvVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_VERSION),
            "::",
            stringify!(drvVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bldChangeListNum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_VERSION),
            "::",
            stringify!(bldChangeListNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szBuildBranchString) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_VERSION),
            "::",
            stringify!(szBuildBranchString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szAdapterString) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_DRIVER_VERSION),
            "::",
            stringify!(szAdapterString)
        )
    );
}
extern "C" {
    #[doc = "! \\ingroup driverapi"]
    pub fn NvAPI_GetDisplayDriverVersion(
        hNvDisplay: NvDisplayHandle,
        pVersion: *mut NV_DISPLAY_DRIVER_VERSION,
    ) -> NvAPI_Status;
}
#[doc = "!   DESCRIPTION: Used in conjunction with OUTPUT_TO_CALLBACK, this is a simple\n!                callback function the user may use to obtain the feedback\n!                stream. The function will be called once per fully qualified\n!                feedback stream entry.\n!\n!   \\param   categoryId    Contains the bit from the NVAPI_OGLEXPERT_REPORT\n!                          mask that corresponds to the current message\n!   \\param   messageId     Unique ID for the current message\n!   \\param   detailLevel   Contains the bit from the NVAPI_OGLEXPERT_DETAIL\n!                          mask that corresponds to the current message\n!   \\param   objectId      Unique ID of the object that corresponds to the\n!                          current message\n!   \\param   messageStr    Text string from the current message\n!\n!   \\ingroup oglapi\n"]
pub type NVAPI_OGLEXPERT_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        categoryId: ::std::os::raw::c_uint,
        messageId: ::std::os::raw::c_uint,
        detailLevel: ::std::os::raw::c_uint,
        objectId: ::std::os::raw::c_int,
        messageStr: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = "! \\ingroup oglapi\n! SUPPORTED OS:  Windows 7 and higher\n!"]
    pub fn NvAPI_OGL_ExpertModeSet(
        expertDetailLevel: NvU32,
        expertReportMask: NvU32,
        expertOutputMask: NvU32,
        expertCallback: NVAPI_OGLEXPERT_CALLBACK,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\addtogroup oglapi\n! SUPPORTED OS:  Windows 7 and higher\n!"]
    pub fn NvAPI_OGL_ExpertModeGet(
        pExpertDetailLevel: *mut NvU32,
        pExpertReportMask: *mut NvU32,
        pExpertOutputMask: *mut NvU32,
        pExpertCallback: *mut NVAPI_OGLEXPERT_CALLBACK,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\ingroup oglapi\n! SUPPORTED OS:  Windows 7 and higher\n!"]
    pub fn NvAPI_OGL_ExpertModeDefaultsSet(
        expertDetailLevel: NvU32,
        expertReportMask: NvU32,
        expertOutputMask: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\addtogroup oglapi\n! SUPPORTED OS:  Windows 7 and higher\n!"]
    pub fn NvAPI_OGL_ExpertModeDefaultsGet(
        pExpertDetailLevel: *mut NvU32,
        pExpertReportMask: *mut NvU32,
        pExpertOutputMask: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns an array of physical GPU handles that are in TCC Mode.\n! Each handle represents a physical GPU present in the system in TCC Mode.\n! That GPU may not be visible to the OS directly.\n!\n! The array nvGPUHandle will be filled with physical GPU handle values. The returned\n! gpuCount determines how many entries in the array are valid.\n!\n! NOTE: Handles enumerated by this API are only valid for NvAPIs that are tagged as TCC_SUPPORTED\n!       If handle is passed to any other API, it will fail with NVAPI_INVALID_HANDLE\n!\n!       For WDDM GPU handles please use NvAPI_EnumPhysicalGPUs()\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n!\n! \\param [out]   nvGPUHandle      Physical GPU array that will contain all TCC Physical GPUs\n! \\param [out]   pGpuCount        count represent the number of valid entries in nvGPUHandle\n!\n!\n! \\retval NVAPI_INVALID_ARGUMENT         nvGPUHandle or pGpuCount is NULL\n! \\ingroup gpu\n"]
    pub fn NvAPI_EnumTCCPhysicalGPUs(
        nvGPUHandle: *mut NvPhysicalGpuHandle,
        pGpuCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns an array of logical GPU handles.\n!\n! Each handle represents one or more GPUs acting in concert as a single graphics device.\n!\n! At least one GPU must be present in the system and running an NVIDIA display driver.\n!\n! The array nvGPUHandle will be filled with logical GPU handle values.  The returned\n! gpuCount determines how many entries in the array are valid.\n!\n! \\note All logical GPUs handles get invalidated on a GPU topology change, so the calling\n!       application is required to renum the logical GPU handles to get latest physical handle\n!       mapping after every GPU topology change activated by a call to NvAPI_SetGpuTopologies().\n!\n! To detect if SLI rendering is enabled, use NvAPI_D3D_GetCurrentSLIState().\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\retval NVAPI_INVALID_ARGUMENT         nvGPUHandle or pGpuCount is NULL\n! \\retval NVAPI_OK                       One or more handles were returned\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found\n! \\ingroup gpu\n"]
    pub fn NvAPI_EnumLogicalGPUs(
        nvGPUHandle: *mut NvLogicalGpuHandle,
        pGpuCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns an array of physical GPU handles associated with the specified display.\n!\n! At least one GPU must be present in the system and running an NVIDIA display driver.\n!\n! The array nvGPUHandle will be filled with physical GPU handle values.  The returned\n! gpuCount determines how many entries in the array are valid.\n!\n! If the display corresponds to more than one physical GPU, the first GPU returned\n! is the one with the attached active output.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\retval NVAPI_INVALID_ARGUMENT         hNvDisp is not valid; nvGPUHandle or pGpuCount is NULL\n! \\retval NVAPI_OK                       One or more handles were returned\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  no NVIDIA GPU driving a display was found\n! \\ingroup gpu\n"]
    pub fn NvAPI_GetPhysicalGPUsFromDisplay(
        hNvDisp: NvDisplayHandle,
        nvGPUHandle: *mut NvPhysicalGpuHandle,
        pGpuCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns a physical GPU handle associated with the specified unattached display.\n! The source GPU is a physical render GPU which renders the frame buffer but may or may not drive the scan out.\n!\n! At least one GPU must be present in the system and running an NVIDIA display driver.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\retval NVAPI_INVALID_ARGUMENT         hNvUnAttachedDisp is not valid or pPhysicalGpu is NULL.\n! \\retval NVAPI_OK                       One or more handles were returned\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found\n! \\ingroup gpu\n"]
    pub fn NvAPI_GetPhysicalGPUFromUnAttachedDisplay(
        hNvUnAttachedDisp: NvUnAttachedDisplayHandle,
        pPhysicalGpu: *mut NvPhysicalGpuHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns the logical GPU handle associated with the specified display.\n! At least one GPU must be present in the system and running an NVIDIA display driver.\n! hNvDisp can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\retval NVAPI_INVALID_ARGUMENT         hNvDisp is not valid; pLogicalGPU is NULL\n! \\retval NVAPI_OK                       One or more handles were returned\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found\n! \\ingroup gpu\n"]
    pub fn NvAPI_GetLogicalGPUFromDisplay(
        hNvDisp: NvDisplayHandle,
        pLogicalGPU: *mut NvLogicalGpuHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns the logical GPU handle associated with specified physical GPU handle.\n! At least one GPU must be present in the system and running an NVIDIA display driver.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\retval NVAPI_INVALID_ARGUMENT         hPhysicalGPU is not valid; pLogicalGPU is NULL\n! \\retval NVAPI_OK                       One or more handles were returned\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found\n! \\ingroup gpu\n"]
    pub fn NvAPI_GetLogicalGPUFromPhysicalGPU(
        hPhysicalGPU: NvPhysicalGpuHandle,
        pLogicalGPU: *mut NvLogicalGpuHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the physical GPU handles associated with the specified logical GPU handle.\n!  At least one GPU must be present in the system and running an NVIDIA display driver.\n!\n!  The array hPhysicalGPU will be filled with physical GPU handle values.  The returned\n!  gpuCount determines how many entries in the array are valid.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\retval NVAPI_INVALID_ARGUMENT             hLogicalGPU is not valid; hPhysicalGPU is NULL\n! \\retval NVAPI_OK                           One or more handles were returned\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found\n! \\retval NVAPI_EXPECTED_LOGICAL_GPU_HANDLE  hLogicalGPU was not a logical GPU handle\n! \\ingroup gpu\n"]
    pub fn NvAPI_GetPhysicalGPUsFromLogicalGPU(
        hLogicalGPU: NvLogicalGpuHandle,
        hPhysicalGPU: *mut NvPhysicalGpuHandle,
        pGpuCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  Do not use this function for new software development.\n!\n! SUPPORTED OS:  Windows 10 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 80\n!\n! \\retval NVAPI_INVALID_ARGUMENT         gpuId is zero or pPhysicalGPU is NULL\n! \\retval NVAPI_OK                       Handle was returned\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found\n! \\ingroup gpu\n"]
    pub fn NvAPI_GetPhysicalGPUFromGPUID(
        gpuId: NvU32,
        pPhysicalGPU: *mut NvPhysicalGpuHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 10 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 95\n!\n! \\retval NVAPI_INVALID_ARGUMENT         hPhysicalGpu is NULL or invalid. Re-enumerate the GPU handles.\n! \\retval NVAPI_OK                       Handle was returned\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found\n! \\ingroup gpu\n"]
    pub fn NvAPI_GetGPUIDfromPhysicalGPU(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pGpuId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This function retrieves the number of Shader SubPipes on the GPU\n!                On newer architectures, this corresponds to the number of SM units\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 170\n!\n! \\retval NVAPI_INVALID_ARGUMENT: pCount is NULL\n! \\retval NVAPI_OK: *pCount is set\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found\n! \\retval NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle\n!\n! \\ingroup   gpu\n"]
    pub fn NvAPI_GPU_GetShaderSubPipeCount(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Retrieves the total number of cores defined for a GPU.\n!                Returns 0 on architectures that don't define GPU cores.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\retval ::NVAPI_INVALID_ARGUMENT              pCount is NULL\n! \\retval ::NVAPI_OK                            *pCount is set\n! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND       no NVIDIA GPU driving a display was found\n! \\retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle\n! \\retval ::NVAPI_NOT_SUPPORTED                 API call is not supported on current architecture\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetGpuCoreCount(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns set of all GPU-output identifiers as a bitmask.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetAllDisplayIds.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 85\n!\n! \\retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL.\n! \\retval   NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers.\n! \\retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.\n! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetAllOutputs(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOutputsMask: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function is the same as NvAPI_GPU_GetAllOutputs() but returns only the set of GPU output\n! identifiers that are connected to display devices.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL.\n! \\retval   NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers.\n! \\retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.\n! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetConnectedOutputs(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOutputsMask: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This function is the same as NvAPI_GPU_GetConnectedOutputs() but returns only the set of GPU-output\n!                identifiers that can be selected in an SLI configuration.\n!                 NOTE: This function matches NvAPI_GPU_GetConnectedOutputs()\n!                 - On systems which are not SLI capable.\n!                 - If the queried GPU is not part of a valid SLI group.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 170\n!\n! \\retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL\n! \\retval   NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers\n! \\retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found\n! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetConnectedSLIOutputs(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOutputsMask: *mut NvU32,
    ) -> NvAPI_Status;
}
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_UNINITIALIZED: NV_MONITOR_CONN_TYPE = 0;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_VGA: NV_MONITOR_CONN_TYPE = 1;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_COMPONENT: NV_MONITOR_CONN_TYPE = 2;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_SVIDEO: NV_MONITOR_CONN_TYPE = 3;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_HDMI: NV_MONITOR_CONN_TYPE = 4;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_DVI: NV_MONITOR_CONN_TYPE = 5;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_LVDS: NV_MONITOR_CONN_TYPE = 6;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_DP: NV_MONITOR_CONN_TYPE = 7;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_COMPOSITE: NV_MONITOR_CONN_TYPE = 8;
pub const NV_MONITOR_CONN_TYPE_NV_MONITOR_CONN_TYPE_UNKNOWN: NV_MONITOR_CONN_TYPE = -1;
#[doc = "! \\ingroup gpu"]
pub type NV_MONITOR_CONN_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_DISPLAYIDS {
    pub version: NvU32,
    #[doc = "!< out: vga, tv, dvi, hdmi and dp. This is reserved for future use and clients should not rely on this information. Instead get the\n!< GPU connector type from NvAPI_GPU_GetConnectorInfo/NvAPI_GPU_GetConnectorInfoEx"]
    pub connectorType: NV_MONITOR_CONN_TYPE,
    #[doc = "!< this is a unique identifier for each device"]
    pub displayId: NvU32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_GPU_DISPLAYIDS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_DISPLAYIDS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_DISPLAYIDS>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_GPU_DISPLAYIDS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_DISPLAYIDS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GPU_DISPLAYIDS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_DISPLAYIDS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connectorType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_DISPLAYIDS),
            "::",
            stringify!(connectorType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_DISPLAYIDS),
            "::",
            stringify!(displayId)
        )
    );
}
impl _NV_GPU_DISPLAYIDS {
    #[inline]
    pub fn isDynamic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDynamic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMultiStreamRootNode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMultiStreamRootNode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isActive(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isActive(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isCluster(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isCluster(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isOSVisible(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isOSVisible(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isWFD(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isWFD(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isConnected(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isConnected(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedInternal(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reservedInternal(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn isPhysicallyConnected(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isPhysicallyConnected(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isDynamic: NvU32,
        isMultiStreamRootNode: NvU32,
        isActive: NvU32,
        isCluster: NvU32,
        isOSVisible: NvU32,
        isWFD: NvU32,
        isConnected: NvU32,
        reservedInternal: NvU32,
        isPhysicallyConnected: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isDynamic: u32 = unsafe { ::std::mem::transmute(isDynamic) };
            isDynamic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isMultiStreamRootNode: u32 =
                unsafe { ::std::mem::transmute(isMultiStreamRootNode) };
            isMultiStreamRootNode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isActive: u32 = unsafe { ::std::mem::transmute(isActive) };
            isActive as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isCluster: u32 = unsafe { ::std::mem::transmute(isCluster) };
            isCluster as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isOSVisible: u32 = unsafe { ::std::mem::transmute(isOSVisible) };
            isOSVisible as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isWFD: u32 = unsafe { ::std::mem::transmute(isWFD) };
            isWFD as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isConnected: u32 = unsafe { ::std::mem::transmute(isConnected) };
            isConnected as u64
        });
        __bindgen_bitfield_unit.set(7usize, 10u8, {
            let reservedInternal: u32 = unsafe { ::std::mem::transmute(reservedInternal) };
            reservedInternal as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let isPhysicallyConnected: u32 =
                unsafe { ::std::mem::transmute(isPhysicallyConnected) };
            isPhysicallyConnected as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_DISPLAYIDS = _NV_GPU_DISPLAYIDS;
extern "C" {
    #[doc = "!\n!   DESCRIPTION: Due to space limitation NvAPI_GPU_GetConnectedOutputs can return maximum 32 devices, but\n!                this is no longer true for DPMST. NvAPI_GPU_GetConnectedDisplayIds will return all\n!                the connected display devices in the form of displayIds for the associated hPhysicalGpu.\n!                This function can accept set of flags to request cached, uncached, sli and lid to get the connected devices.\n!                Default value for flags will be cached .\n!\n! HOW TO USE: 1) for each PhysicalGpu, make a call to get the number of connected displayId's\n!                using NvAPI_GPU_GetConnectedDisplayIds by passing the pDisplayIds as NULL\n!                On call success:\n!\n!             2) If pDisplayIdCount is greater than 0, allocate memory based on pDisplayIdCount. Then make a call NvAPI_GPU_GetConnectedDisplayIds to populate DisplayIds.\n!                However, if pDisplayIdCount is 0, do not make this call.\n! SUPPORTED OS:  Windows 7 and higher\n!\n! \\param [in]     hPhysicalGpu   - GPU selection\n! \\param [in]     flags          - One or more defines from NV_GPU_CONNECTED_IDS_FLAG_* as valid flags.\n! \\param [in,out]     pDisplayIds   - Pointer to an NV_GPU_DISPLAYIDS struct, each entry represents a one displayID and its attributes\n! \\param [in]     pDisplayIdCount - Number of displayId's.\n!\n! \\retval  NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pDisplayIds or pDisplayIdCount is NULL\n! \\retval  NVAPI_OK: *pDisplayIds contains a set of GPU-output identifiers\n! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found\n! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetConnectedDisplayIds(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pDisplayIds: *mut NV_GPU_DISPLAYIDS,
        pDisplayIdCount: *mut NvU32,
        flags: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns display IDs for all possible outputs on the GPU.\n!                For DPMST connector, it will return display IDs for all the video sinks in the topology. \\n\n! HOW TO USE: 1. The first call should be made to get the all display ID count. To get the display ID count, send in \\n\n!                  a) hPhysicalGpu    - a valid GPU handle(enumerated using NvAPI_EnumPhysicalGPUs()) as input,      \\n\n!                  b) pDisplayIds     - NULL, as we just want to get the display ID count.                           \\n\n!                  c) pDisplayIdCount - a valid pointer to NvU32, whose value is set to ZERO.                        \\n\n!                If all parameters are correct and this call is successful, this call will return the display ID's count. \\n\n!             2. To get the display ID array, make the second call to NvAPI_GPU_GetAllDisplayIds() with              \\n\n!                  a) hPhysicalGpu    - should be same value which was sent in first call,                           \\n\n!                  b) pDisplayIds     - pointer to the display ID array allocated by caller based on display ID count,    \\n\n!                                       eg. malloc(sizeof(NV_GPU_DISPLAYIDS) * pDisplayIdCount).                     \\n\n!                  c) pDisplayIdCount - a valid pointer to NvU32. This indicates for how many display IDs            \\n\n!                                       the memory is allocated(pDisplayIds) by the caller.                          \\n\n!                If all parameters are correct and this call is successful, this call will return the display ID array and actual\n!                display ID count (which was obtained in the first call to NvAPI_GPU_GetAllDisplayIds). If the input display ID count is\n!                less than the actual display ID count, it will overwrite the input and give the pDisplayIdCount as actual count and the\n!                API will return NVAPI_INSUFFICIENT_BUFFER.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]     hPhysicalGpu         GPU selection.\n! \\param [in,out] DisplayIds           Pointer to an array of NV_GPU_DISPLAYIDS structures, each entry represents one displayID\n!                                      and its attributes.\n! \\param [in,out] pDisplayIdCount      As input, this parameter indicates the number of display's id's for which caller has\n!                                      allocated the memory. As output, it will return the actual number of display IDs.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!          specific meaning for this API, they are listed below.\n!\n! \\retval  NVAPI_INSUFFICIENT_BUFFER  When the input buffer(pDisplayIds) is less than the actual number of display IDs, this API\n!                                     will return NVAPI_INSUFFICIENT_BUFFER.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetAllDisplayIds(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pDisplayIds: *mut NV_GPU_DISPLAYIDS,
        pDisplayIdCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function is similar to NvAPI_GPU_GetConnectedOutputs(), and returns the connected display identifiers that are connected\n!  as an output mask but unlike NvAPI_GPU_GetConnectedOutputs() this API \"always\" reflects the Lid State in the output mask.\n!  Thus if you expect the LID close state to be available in the connection mask use this API.\n!  - If LID is closed then this API will remove the LID panel from the connected display identifiers.\n!  - If LID is open then this API will reflect the LID panel in the connected display identifiers.\n!\n! \\note This API should be used on notebook systems and on systems where the LID state is required in the connection\n!       output mask. On desktop systems the returned identifiers will match NvAPI_GPU_GetConnectedOutputs().\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 95\n!\n! \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL\n! \\retval  NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers\n! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found\n! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetConnectedOutputsWithLidState(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOutputsMask: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This function is the same as NvAPI_GPU_GetConnectedOutputsWithLidState() but returns only the set\n!                of GPU-output identifiers that can be selected in an SLI configuration. With SLI disabled,\n!                this function matches NvAPI_GPU_GetConnectedOutputsWithLidState().\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 170\n!\n! \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL\n! \\retval  NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers\n! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found\n! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetConnectedSLIOutputsWithLidState(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOutputsMask: *mut NvU32,
    ) -> NvAPI_Status;
}
pub const NV_SYSTEM_TYPE_NV_SYSTEM_TYPE_UNKNOWN: NV_SYSTEM_TYPE = 0;
pub const NV_SYSTEM_TYPE_NV_SYSTEM_TYPE_LAPTOP: NV_SYSTEM_TYPE = 1;
pub const NV_SYSTEM_TYPE_NV_SYSTEM_TYPE_DESKTOP: NV_SYSTEM_TYPE = 2;
#[doc = "! \\ingroup gpu\n! Used in NvAPI_GPU_GetSystemType()"]
pub type NV_SYSTEM_TYPE = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_GetSystemType(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pSystemType: *mut NV_SYSTEM_TYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function is the same as NvAPI_GPU_GetAllOutputs but returns only the set of GPU output\n!  identifiers that are actively driving display devices.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 85\n!\n! \\retval    NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL.\n! \\retval    NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers.\n! \\retval    NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.\n! \\retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetActiveOutputs(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOutputsMask: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  Thus function sets the EDID data for the specified GPU handle and connection bit mask.\n!  User can either send (Gpu handle & output id)  or only display Id in variable displayOutputId parameter & hPhysicalGpu parameter can be default handle (0).\n!  \\note The EDID will be cached across the boot session and will be enumerated to the OS in this call.\n!        To remove the EDID set sizeofEDID to zero.\n!        OS and NVAPI connection status APIs will reflect the newly set or removed EDID dynamically.\n!\n!                This feature will NOT be supported on the following boards:\n!                - GeForce\n!                - Quadro VX\n!                - Tesla\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 100\n!\n! \\retval  NVAPI_INVALID_ARGUMENT              pEDID is NULL; displayOutputId has 0 or > 1 bits set\n! \\retval  NVAPI_OK                           *pEDID data was applied to the requested displayOutputId.\n! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.\n! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle.\n! \\retval  NVAPI_NOT_SUPPORTED                 For the above mentioned GPUs\n! \\retval  NVAPI_INVALID_USER_PRIVILEGE        The application will require Administrator privileges to access this API.\n!                                              The application can be elevated to a higher permission level by selecting \"Run as Administrator\".\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_SetEDID(
        hPhysicalGpu: NvPhysicalGpuHandle,
        displayOutputId: NvU32,
        pEDID: *mut NV_EDID,
    ) -> NvAPI_Status;
}
pub const _NV_GPU_OUTPUT_TYPE_NVAPI_GPU_OUTPUT_UNKNOWN: _NV_GPU_OUTPUT_TYPE = 0;
#[doc = "!<  CRT display device"]
pub const _NV_GPU_OUTPUT_TYPE_NVAPI_GPU_OUTPUT_CRT: _NV_GPU_OUTPUT_TYPE = 1;
#[doc = "!<  Digital Flat Panel display device"]
pub const _NV_GPU_OUTPUT_TYPE_NVAPI_GPU_OUTPUT_DFP: _NV_GPU_OUTPUT_TYPE = 2;
#[doc = "!<  TV display device"]
pub const _NV_GPU_OUTPUT_TYPE_NVAPI_GPU_OUTPUT_TV: _NV_GPU_OUTPUT_TYPE = 3;
#[doc = "! \\ingroup gpu\n! used in NvAPI_GPU_GetOutputType()"]
pub type _NV_GPU_OUTPUT_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu\n! used in NvAPI_GPU_GetOutputType()"]
pub use self::_NV_GPU_OUTPUT_TYPE as NV_GPU_OUTPUT_TYPE;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_GetOutputType(
        hPhysicalGpu: NvPhysicalGpuHandle,
        outputId: NvU32,
        pOutputType: *mut NV_GPU_OUTPUT_TYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function determines if a set of GPU outputs can be active\n!  simultaneously.  While a GPU may have <n> outputs, typically they cannot\n!  all be active at the same time due to internal resource sharing.\n!\n!  Given a physical GPU handle and a mask of candidate outputs, this call\n!  will return NVAPI_OK if all of the specified outputs can be driven\n!  simultaneously.  It will return NVAPI_INVALID_COMBINATION if they cannot.\n!\n!  Use NvAPI_GPU_GetAllOutputs() to determine which outputs are candidates.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 85\n!\n! \\retval  NVAPI_OK                            Combination of outputs in outputsMask are valid (can be active simultaneously).\n! \\retval  NVAPI_INVALID_COMBINATION           Combination of outputs in outputsMask are NOT valid.\n! \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or outputsMask does not have at least 2 bits set.\n! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.\n! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_ValidateOutputCombination(
        hPhysicalGpu: NvPhysicalGpuHandle,
        outputsMask: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function retrieves the full GPU name as an ASCII string - for example, \"Quadro FX 1400\".\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 90\n!\n! \\return  NVAPI_ERROR or NVAPI_OK\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetFullName(
        hPhysicalGpu: NvPhysicalGpuHandle,
        szName: *mut ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the PCI identifiers associated with this GPU.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 90\n!\n! \\param   DeviceId      The internal PCI device identifier for the GPU.\n! \\param   SubSystemId   The internal PCI subsystem identifier for the GPU.\n! \\param   RevisionId    The internal PCI device-specific revision identifier for the GPU.\n! \\param   ExtDeviceId   The external PCI device identifier for the GPU.\n!\n! \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or an argument is NULL\n! \\retval  NVAPI_OK                            Arguments are populated with PCI identifiers\n! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found\n! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetPCIIdentifiers(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pDeviceId: *mut NvU32,
        pSubSystemId: *mut NvU32,
        pRevisionId: *mut NvU32,
        pExtDeviceId: *mut NvU32,
    ) -> NvAPI_Status;
}
pub const _NV_GPU_TYPE_NV_SYSTEM_TYPE_GPU_UNKNOWN: _NV_GPU_TYPE = 0;
#[doc = "!< Integrated GPU"]
pub const _NV_GPU_TYPE_NV_SYSTEM_TYPE_IGPU: _NV_GPU_TYPE = 1;
#[doc = "!< Discrete GPU"]
pub const _NV_GPU_TYPE_NV_SYSTEM_TYPE_DGPU: _NV_GPU_TYPE = 2;
#[doc = "! \\ingroup gpu\n! Used in NvAPI_GPU_GetGPUType()."]
pub type _NV_GPU_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu\n! Used in NvAPI_GPU_GetGPUType()."]
pub use self::_NV_GPU_TYPE as NV_GPU_TYPE;
extern "C" {
    #[doc = "!  DESCRIPTION: This function returns the GPU type (integrated or discrete).\n!               See ::NV_GPU_TYPE.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 173\n!\n! \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu\n! \\retval  NVAPI_OK                           *pGpuType contains the GPU type\n! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found\n! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle\n!\n!  \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetGPUType(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pGpuType: *mut NV_GPU_TYPE,
    ) -> NvAPI_Status;
}
pub const _NV_GPU_BUS_TYPE_NVAPI_GPU_BUS_TYPE_UNDEFINED: _NV_GPU_BUS_TYPE = 0;
pub const _NV_GPU_BUS_TYPE_NVAPI_GPU_BUS_TYPE_PCI: _NV_GPU_BUS_TYPE = 1;
pub const _NV_GPU_BUS_TYPE_NVAPI_GPU_BUS_TYPE_AGP: _NV_GPU_BUS_TYPE = 2;
pub const _NV_GPU_BUS_TYPE_NVAPI_GPU_BUS_TYPE_PCI_EXPRESS: _NV_GPU_BUS_TYPE = 3;
pub const _NV_GPU_BUS_TYPE_NVAPI_GPU_BUS_TYPE_FPCI: _NV_GPU_BUS_TYPE = 4;
pub const _NV_GPU_BUS_TYPE_NVAPI_GPU_BUS_TYPE_AXI: _NV_GPU_BUS_TYPE = 5;
#[doc = "! \\ingroup gpu\n! Used in NvAPI_GPU_GetBusType()"]
pub type _NV_GPU_BUS_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu\n! Used in NvAPI_GPU_GetBusType()"]
pub use self::_NV_GPU_BUS_TYPE as NV_GPU_BUS_TYPE;
extern "C" {
    #[doc = "!  This function returns the type of bus associated with this GPU.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 90\n!\n! \\return      This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!              specific meaning for this API, they are listed below.\n! \\retval      NVAPI_INVALID_ARGUMENT             hPhysicalGpu or pBusType is NULL.\n! \\retval      NVAPI_OK                          *pBusType contains bus identifier.\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetBusType(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBusType: *mut NV_GPU_BUS_TYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Returns the ID of the bus associated with this GPU.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 167\n!\n!  \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pBusId is NULL.\n!  \\retval  NVAPI_OK                           *pBusId contains the bus ID.\n!  \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.\n!  \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.\n!\n!  \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetBusId(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBusId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Returns the ID of the bus slot associated with this GPU.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 167\n!\n!  \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pBusSlotId is NULL.\n!  \\retval  NVAPI_OK                           *pBusSlotId contains the bus slot ID.\n!  \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.\n!  \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.\n!\n!  \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetBusSlotId(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBusSlotId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the interrupt number associated with this GPU.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 90\n!\n! \\retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pIRQ is NULL.\n! \\retval  NVAPI_OK                           *pIRQ contains interrupt number.\n! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.\n! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetIRQ(hPhysicalGpu: NvPhysicalGpuHandle, pIRQ: *mut NvU32) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the revision of the video BIOS associated with this GPU.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 90\n!\n! \\retval    NVAPI_INVALID_ARGUMENT               hPhysicalGpu or pBiosRevision is NULL.\n! \\retval    NVAPI_OK                            *pBiosRevision contains revision number.\n! \\retval    NVAPI_NVIDIA_DEVICE_NOT_FOUND        No NVIDIA GPU driving a display was found.\n! \\retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   hPhysicalGpu was not a physical GPU handle.\n! \\ingroup   gpu\n"]
    pub fn NvAPI_GPU_GetVbiosRevision(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBiosRevision: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the OEM revision of the video BIOS associated with this GPU.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 90\n!\n! \\retval    NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pBiosRevision is NULL\n! \\retval    NVAPI_OK                           *pBiosRevision contains revision number\n! \\retval    NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found\n! \\retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle\n! \\ingroup   gpu\n"]
    pub fn NvAPI_GPU_GetVbiosOEMRevision(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBiosRevision: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the full video BIOS version string in the form of xx.xx.xx.xx.yy where\n!  - xx numbers come from NvAPI_GPU_GetVbiosRevision() and\n!  - yy comes from NvAPI_GPU_GetVbiosOEMRevision().\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 90\n!\n! \\retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu is NULL.\n! \\retval   NVAPI_OK                            szBiosRevision contains version string.\n! \\retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.\n! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetVbiosVersionString(
        hPhysicalGpu: NvPhysicalGpuHandle,
        szBiosRevision: *mut ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the AGP aperture in megabytes.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 455.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 90\n!\n! \\retval   NVAPI_NOT_SUPPORTED\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetAGPAperture(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pSize: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the current AGP Rate (0 = AGP not present, 1 = 1x, 2 = 2x, etc.).\n!\n! \\deprecated  Do not use this function - it is deprecated in release 455.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 90\n!\n! \\retval   NVAPI_NOT_SUPPORTED\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetCurrentAGPRate(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pRate: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the number of PCIE lanes being used for the PCIE interface\n!  downstream from the GPU.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 90\n!\n! \\retval  NVAPI_INVALID_ARGUMENT              pWidth is NULL.\n! \\retval  NVAPI_OK                            Call successful.\n! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.\n! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetCurrentPCIEDownstreamWidth(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pWidth: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   This function returns the physical size of framebuffer in KB.  This does NOT include any\n!   system RAM that may be dedicated for use by the GPU.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 90\n!\n! \\retval  NVAPI_INVALID_ARGUMENT              pSize is NULL\n! \\retval  NVAPI_OK                            Call successful\n! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found\n! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetPhysicalFrameBufferSize(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pSize: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the virtual size of framebuffer in KB.  This includes the physical RAM plus any\n!  system RAM that has been dedicated for use by the GPU.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 90\n!\n! \\retval  NVAPI_INVALID_ARGUMENT              pSize is NULL.\n! \\retval  NVAPI_OK                            Call successful.\n! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.\n! \\retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetVirtualFrameBufferSize(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pSize: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function retrieves the Quadro status for the GPU (1 if Quadro, 0 if GeForce)\n!\n!  This API is deprecated and it is recommended to instead query\n!  NV_GPU_WORKSTATION_FEATURE_TYPE_PROVIZ support from the API\n!  NvAPI_GPU_QueryWorkstationFeatureSupport.\n! \\deprecated  Do not use this function - it is deprecated in release 460.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\return  NVAPI_ERROR or NVAPI_OK\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetQuadroStatus(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pStatus: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_BOARD_INFO {
    #[doc = "!< structure version"]
    pub version: NvU32,
    #[doc = "!< Board Serial Number"]
    pub BoardNum: [NvU8; 16usize],
}
#[test]
fn bindgen_test_layout__NV_BOARD_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_BOARD_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_BOARD_INFO>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_BOARD_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_BOARD_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_BOARD_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_BOARD_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BoardNum) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_BOARD_INFO),
            "::",
            stringify!(BoardNum)
        )
    );
}
#[doc = "! \\ingroup gpu"]
pub type NV_BOARD_INFO_V1 = _NV_BOARD_INFO;
#[doc = "! \\ingroup gpu"]
pub type NV_BOARD_INFO = NV_BOARD_INFO_V1;
extern "C" {
    #[doc = "!   DESCRIPTION: This API Retrieves the Board information (a unique GPU Board Serial Number) stored in the InfoROM.\n!\n! \\param [in]      hPhysicalGpu       Physical GPU Handle.\n! \\param [in,out]  NV_BOARD_INFO      Board Information.\n!\n! TCC_SUPPORTED\n!\n! \\retval ::NVAPI_OK                     completed request\n! \\retval ::NVAPI_ERROR                  miscellaneous error occurred\n! \\retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  handle passed is not a physical GPU handle\n! \\retval ::NVAPI_API_NOT_INTIALIZED            NVAPI not initialized\n! \\retval ::NVAPI_INVALID_POINTER               pBoardInfo is NULL\n! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION   the version of the INFO struct is not supported\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetBoardInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBoardInfo: *mut NV_BOARD_INFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the width of the GPU's RAM memory bus.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 100\n!\n!  \\return NVAPI_ERROR or NVAPI_OK\n!  \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetRamBusWidth(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pBusWidth: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! Used in NvAPI_GPU_GetArchInfo()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_ARCH_INFO_V1 {
    pub version: NvU32,
    pub architecture: NvU32,
    pub implementation: NvU32,
    pub revision: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_ARCH_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_ARCH_INFO_V1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ARCH_INFO_V1>(),
        16usize,
        concat!("Size of: ", stringify!(NV_GPU_ARCH_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ARCH_INFO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_ARCH_INFO_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ARCH_INFO_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).architecture) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ARCH_INFO_V1),
            "::",
            stringify!(architecture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ARCH_INFO_V1),
            "::",
            stringify!(implementation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ARCH_INFO_V1),
            "::",
            stringify!(revision)
        )
    );
}
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_T2X: _NV_GPU_ARCHITECTURE_ID = -536870880;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_T3X: _NV_GPU_ARCHITECTURE_ID = -536870864;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_T4X: _NV_GPU_ARCHITECTURE_ID = -536870848;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_T12X: _NV_GPU_ARCHITECTURE_ID = -536870848;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_NV40: _NV_GPU_ARCHITECTURE_ID = 64;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_NV50: _NV_GPU_ARCHITECTURE_ID = 80;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_G78: _NV_GPU_ARCHITECTURE_ID = 96;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_G80: _NV_GPU_ARCHITECTURE_ID = 128;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_G90: _NV_GPU_ARCHITECTURE_ID = 144;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GT200: _NV_GPU_ARCHITECTURE_ID = 160;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GF100: _NV_GPU_ARCHITECTURE_ID = 192;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GF110: _NV_GPU_ARCHITECTURE_ID = 208;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GK100: _NV_GPU_ARCHITECTURE_ID = 224;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GK110: _NV_GPU_ARCHITECTURE_ID = 240;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GK200: _NV_GPU_ARCHITECTURE_ID = 256;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GM000: _NV_GPU_ARCHITECTURE_ID = 272;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GM200: _NV_GPU_ARCHITECTURE_ID = 288;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GP100: _NV_GPU_ARCHITECTURE_ID = 304;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GV100: _NV_GPU_ARCHITECTURE_ID = 320;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GV110: _NV_GPU_ARCHITECTURE_ID = 336;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_TU100: _NV_GPU_ARCHITECTURE_ID = 352;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_GA100: _NV_GPU_ARCHITECTURE_ID = 368;
pub const _NV_GPU_ARCHITECTURE_ID_NV_GPU_ARCHITECTURE_AD100: _NV_GPU_ARCHITECTURE_ID = 400;
#[doc = "! NV_GPU_ARCH_INFO() values to identify Architecture level for the GPU."]
pub type _NV_GPU_ARCHITECTURE_ID = ::std::os::raw::c_int;
#[doc = "! NV_GPU_ARCH_INFO() values to identify Architecture level for the GPU."]
pub use self::_NV_GPU_ARCHITECTURE_ID as NV_GPU_ARCHITECTURE_ID;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_T20:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_T30:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_T35:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 5;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_T40:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_T124:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV40:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV41:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 1;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV42:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV43:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 3;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV44:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV44A:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 10;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV46:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV47:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 7;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV49:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 9;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV4B:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 11;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV4C:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 12;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV4E:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 14;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV50:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV63:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 3;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_NV67:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 7;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_G84:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_G86:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_G92:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_G94:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_G96:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_G98:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 8;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT200:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT212:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT214:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT215:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 3;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT216:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 5;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT218:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 8;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_MCP77:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 10;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT21C:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 11;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_MCP79:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 12;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GT21A:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 13;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_MCP89:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 15;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF100:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF104:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF106:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 3;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF108:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 1;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF110:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF116:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF117:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 7;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF118:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 8;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GF119:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 9;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GK104:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GK106:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GK107:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 7;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GK20A:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 10;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GK110:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GK208:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 8;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GM204:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GM206:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP100:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP000:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 1;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP102:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP104:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP106:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP107:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 7;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GP108:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 8;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GV100:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GV10B:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 11;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU100:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU102:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU104:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU106:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 6;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU116:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 8;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU117:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 7;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_TU000:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 1;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GA100:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 0;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GA102:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_GA104:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_AD102:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 2;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_AD103:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 3;
pub const _NV_GPU_ARCH_IMPLEMENTATION_ID_NV_GPU_ARCH_IMPLEMENTATION_AD104:
    _NV_GPU_ARCH_IMPLEMENTATION_ID = 4;
#[doc = "! NV_GPU_ARCH_INFO() values to identify GPU Architecture Implementation."]
pub type _NV_GPU_ARCH_IMPLEMENTATION_ID = ::std::os::raw::c_int;
#[doc = "! NV_GPU_ARCH_INFO() values to identify GPU Architecture Implementation."]
pub use self::_NV_GPU_ARCH_IMPLEMENTATION_ID as NV_GPU_ARCH_IMPLEMENTATION_ID;
#[doc = "!< QT chip"]
pub const _NV_GPU_CHIP_REVISION_NV_GPU_CHIP_REV_EMULATION_QT: _NV_GPU_CHIP_REVISION = 0;
#[doc = "!< FPGA implementation of the chipset"]
pub const _NV_GPU_CHIP_REVISION_NV_GPU_CHIP_REV_EMULATION_FPGA: _NV_GPU_CHIP_REVISION = 1;
#[doc = "!< First silicon chipset revision"]
pub const _NV_GPU_CHIP_REVISION_NV_GPU_CHIP_REV_A01: _NV_GPU_CHIP_REVISION = 17;
#[doc = "!< Second Silicon chipset revision"]
pub const _NV_GPU_CHIP_REVISION_NV_GPU_CHIP_REV_A02: _NV_GPU_CHIP_REVISION = 18;
#[doc = "!< Third Silicon chipset revision"]
pub const _NV_GPU_CHIP_REVISION_NV_GPU_CHIP_REV_A03: _NV_GPU_CHIP_REVISION = 19;
#[doc = "!< Unknown chip revision"]
pub const _NV_GPU_CHIP_REVISION_NV_GPU_CHIP_REV_UNKNOWN: _NV_GPU_CHIP_REVISION = -1;
pub type _NV_GPU_CHIP_REVISION = ::std::os::raw::c_int;
pub use self::_NV_GPU_CHIP_REVISION as NV_GPU_CHIP_REVISION;
#[doc = "! \\ingroup gpu\n! Used in NvAPI_GPU_GetArchInfo()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_ARCH_INFO_V2 {
    pub version: NvU32,
    pub __bindgen_anon_1: NV_GPU_ARCH_INFO_V2__bindgen_ty_1,
    pub __bindgen_anon_2: NV_GPU_ARCH_INFO_V2__bindgen_ty_2,
    pub __bindgen_anon_3: NV_GPU_ARCH_INFO_V2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_GPU_ARCH_INFO_V2__bindgen_ty_1 {
    #[doc = "!< architecture and architecture_id are the same. The former is NvU32 while the latter is an enum made for readability."]
    pub architecture: NvU32,
    #[doc = "!< specifies the architecture level for the GPU."]
    pub architecture_id: NV_GPU_ARCHITECTURE_ID,
}
#[test]
fn bindgen_test_layout_NV_GPU_ARCH_INFO_V2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_ARCH_INFO_V2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ARCH_INFO_V2__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ARCH_INFO_V2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).architecture) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_1),
            "::",
            stringify!(architecture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).architecture_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_1),
            "::",
            stringify!(architecture_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_GPU_ARCH_INFO_V2__bindgen_ty_2 {
    #[doc = "!< implementation and implementation_id are the same. The former is NvU32 while the latter is an enum made for readability."]
    pub implementation: NvU32,
    #[doc = "!< specifies the implementation of the architecture for the GPU."]
    pub implementation_id: NV_GPU_ARCH_IMPLEMENTATION_ID,
}
#[test]
fn bindgen_test_layout_NV_GPU_ARCH_INFO_V2__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_ARCH_INFO_V2__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ARCH_INFO_V2__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ARCH_INFO_V2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_2),
            "::",
            stringify!(implementation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_2),
            "::",
            stringify!(implementation_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_GPU_ARCH_INFO_V2__bindgen_ty_3 {
    #[doc = "!< revision and revision_id are the same. The former is NvU32 while the latter is an enum made for readability."]
    pub revision: NvU32,
    #[doc = "!< specifies the architecture revision of the GPU."]
    pub revision_id: NV_GPU_CHIP_REVISION,
}
#[test]
fn bindgen_test_layout_NV_GPU_ARCH_INFO_V2__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_ARCH_INFO_V2__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ARCH_INFO_V2__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ARCH_INFO_V2__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_3),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ARCH_INFO_V2__bindgen_ty_3),
            "::",
            stringify!(revision_id)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_GPU_ARCH_INFO_V2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_ARCH_INFO_V2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ARCH_INFO_V2>(),
        16usize,
        concat!("Size of: ", stringify!(NV_GPU_ARCH_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ARCH_INFO_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_ARCH_INFO_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ARCH_INFO_V2),
            "::",
            stringify!(version)
        )
    );
}
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_ARCH_INFO = NV_GPU_ARCH_INFO_V2;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_GetArchInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pGpuArchInfo: *mut NV_GPU_ARCH_INFO,
    ) -> NvAPI_Status;
}
#[doc = "!< Set i2cSpeedKhz to I2C_SPEED_DEFAULT if default I2C speed is to be chosen, ie.use the current frequency setting."]
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_DEFAULT: NV_I2C_SPEED = 0;
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_3KHZ: NV_I2C_SPEED = 1;
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_10KHZ: NV_I2C_SPEED = 2;
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_33KHZ: NV_I2C_SPEED = 3;
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_100KHZ: NV_I2C_SPEED = 4;
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_200KHZ: NV_I2C_SPEED = 5;
pub const NV_I2C_SPEED_NVAPI_I2C_SPEED_400KHZ: NV_I2C_SPEED = 6;
pub type NV_I2C_SPEED = ::std::os::raw::c_int;
#[doc = "! Used in NvAPI_I2CRead() and NvAPI_I2CWrite()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_I2C_INFO_V1 {
    #[doc = "!< The structure version."]
    pub version: NvU32,
    #[doc = "!< The Display Mask of the concerned display."]
    pub displayMask: NvU32,
    #[doc = "!< This flag indicates either the DDC port (TRUE) or the communication port\n!< (FALSE) of the concerned display."]
    pub bIsDDCPort: NvU8,
    #[doc = "!< The address of the I2C slave.  The address should be shifted left by one.  For\n!< example, the I2C address 0x50, often used for reading EDIDs, would be stored\n!< here as 0xA0.  This matches the position within the byte sent by the master, as\n!< the last bit is reserved to specify the read or write direction."]
    pub i2cDevAddress: NvU8,
    #[doc = "!< The I2C target register address.  May be NULL, which indicates no register\n!< address should be sent."]
    pub pbI2cRegAddress: *mut NvU8,
    #[doc = "!< The size in bytes of target register address.  If pbI2cRegAddress is NULL, this\n!< field must be 0."]
    pub regAddrSize: NvU32,
    #[doc = "!< The buffer of data which is to be read or written (depending on the command)."]
    pub pbData: *mut NvU8,
    #[doc = "!< The size of the data buffer, pbData, to be read or written."]
    pub cbSize: NvU32,
    #[doc = "!< The target speed of the transaction (between 28Kbps to 40Kbps; not guaranteed)."]
    pub i2cSpeed: NvU32,
}
#[test]
fn bindgen_test_layout_NV_I2C_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_I2C_INFO_V1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_I2C_INFO_V1>(),
        48usize,
        concat!("Size of: ", stringify!(NV_I2C_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_I2C_INFO_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_I2C_INFO_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayMask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V1),
            "::",
            stringify!(displayMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsDDCPort) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V1),
            "::",
            stringify!(bIsDDCPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2cDevAddress) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V1),
            "::",
            stringify!(i2cDevAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbI2cRegAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V1),
            "::",
            stringify!(pbI2cRegAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regAddrSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V1),
            "::",
            stringify!(regAddrSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V1),
            "::",
            stringify!(pbData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V1),
            "::",
            stringify!(cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2cSpeed) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V1),
            "::",
            stringify!(i2cSpeed)
        )
    );
}
#[doc = "! Used in NvAPI_I2CRead() and NvAPI_I2CWrite()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_I2C_INFO_V2 {
    #[doc = "!< The structure version."]
    pub version: NvU32,
    #[doc = "!< The Display Mask of the concerned display."]
    pub displayMask: NvU32,
    #[doc = "!< This flag indicates either the DDC port (TRUE) or the communication port\n!< (FALSE) of the concerned display."]
    pub bIsDDCPort: NvU8,
    #[doc = "!< The address of the I2C slave.  The address should be shifted left by one.  For\n!< example, the I2C address 0x50, often used for reading EDIDs, would be stored\n!< here as 0xA0.  This matches the position within the byte sent by the master, as\n!< the last bit is reserved to specify the read or write direction."]
    pub i2cDevAddress: NvU8,
    #[doc = "!< The I2C target register address.  May be NULL, which indicates no register\n!< address should be sent."]
    pub pbI2cRegAddress: *mut NvU8,
    #[doc = "!< The size in bytes of target register address.  If pbI2cRegAddress is NULL, this\n!< field must be 0."]
    pub regAddrSize: NvU32,
    #[doc = "!< The buffer of data which is to be read or written (depending on the command)."]
    pub pbData: *mut NvU8,
    #[doc = "!< The size of the data buffer, pbData, to be read or written."]
    pub cbSize: NvU32,
    #[doc = "!< Deprecated, Must be set to NVAPI_I2C_SPEED_DEPRECATED."]
    pub i2cSpeed: NvU32,
    #[doc = "!< The target speed of the transaction in (kHz) (Chosen from the enum NV_I2C_SPEED)."]
    pub i2cSpeedKhz: NV_I2C_SPEED,
}
#[test]
fn bindgen_test_layout_NV_I2C_INFO_V2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_I2C_INFO_V2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_I2C_INFO_V2>(),
        56usize,
        concat!("Size of: ", stringify!(NV_I2C_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_I2C_INFO_V2>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_I2C_INFO_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayMask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V2),
            "::",
            stringify!(displayMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsDDCPort) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V2),
            "::",
            stringify!(bIsDDCPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2cDevAddress) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V2),
            "::",
            stringify!(i2cDevAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbI2cRegAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V2),
            "::",
            stringify!(pbI2cRegAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regAddrSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V2),
            "::",
            stringify!(regAddrSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V2),
            "::",
            stringify!(pbData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V2),
            "::",
            stringify!(cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2cSpeed) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V2),
            "::",
            stringify!(i2cSpeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2cSpeedKhz) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V2),
            "::",
            stringify!(i2cSpeedKhz)
        )
    );
}
#[doc = "! Used in NvAPI_I2CRead() and NvAPI_I2CWrite()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_I2C_INFO_V3 {
    #[doc = "!< The structure version."]
    pub version: NvU32,
    #[doc = "!< The Display Mask of the concerned display."]
    pub displayMask: NvU32,
    #[doc = "!< This flag indicates either the DDC port (TRUE) or the communication port\n!< (FALSE) of the concerned display."]
    pub bIsDDCPort: NvU8,
    #[doc = "!< The address of the I2C slave.  The address should be shifted left by one.  For\n!< example, the I2C address 0x50, often used for reading EDIDs, would be stored\n!< here as 0xA0.  This matches the position within the byte sent by the master, as\n!< the last bit is reserved to specify the read or write direction."]
    pub i2cDevAddress: NvU8,
    #[doc = "!< The I2C target register address.  May be NULL, which indicates no register\n!< address should be sent."]
    pub pbI2cRegAddress: *mut NvU8,
    #[doc = "!< The size in bytes of target register address.  If pbI2cRegAddress is NULL, this\n!< field must be 0."]
    pub regAddrSize: NvU32,
    #[doc = "!< The buffer of data which is to be read or written (depending on the command)."]
    pub pbData: *mut NvU8,
    #[doc = "!< The size of the data buffer, pbData, to be read or written."]
    pub cbSize: NvU32,
    #[doc = "!< Deprecated, Must be set to NVAPI_I2C_SPEED_DEPRECATED."]
    pub i2cSpeed: NvU32,
    #[doc = "!< The target speed of the transaction in (kHz) (Chosen from the enum NV_I2C_SPEED)."]
    pub i2cSpeedKhz: NV_I2C_SPEED,
    #[doc = "!< The portid on which device is connected (remember to set bIsPortIdSet if this value is set)\n!< Optional for pre-Kepler"]
    pub portId: NvU8,
    #[doc = "!< set this flag on if and only if portid value is set"]
    pub bIsPortIdSet: NvU32,
}
#[test]
fn bindgen_test_layout_NV_I2C_INFO_V3() {
    const UNINIT: ::std::mem::MaybeUninit<NV_I2C_INFO_V3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_I2C_INFO_V3>(),
        64usize,
        concat!("Size of: ", stringify!(NV_I2C_INFO_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_I2C_INFO_V3>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_I2C_INFO_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayMask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V3),
            "::",
            stringify!(displayMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsDDCPort) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V3),
            "::",
            stringify!(bIsDDCPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2cDevAddress) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V3),
            "::",
            stringify!(i2cDevAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbI2cRegAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V3),
            "::",
            stringify!(pbI2cRegAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regAddrSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V3),
            "::",
            stringify!(regAddrSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V3),
            "::",
            stringify!(pbData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V3),
            "::",
            stringify!(cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2cSpeed) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V3),
            "::",
            stringify!(i2cSpeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2cSpeedKhz) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V3),
            "::",
            stringify!(i2cSpeedKhz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).portId) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V3),
            "::",
            stringify!(portId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsPortIdSet) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_I2C_INFO_V3),
            "::",
            stringify!(bIsPortIdSet)
        )
    );
}
#[doc = "! Used in NvAPI_I2CRead() and NvAPI_I2CWrite()"]
pub type NV_I2C_INFO = NV_I2C_INFO_V3;
extern "C" {
    #[doc = "!  This function reads the data buffer from the I2C port.\n!                 The I2C request must be for a DDC port: pI2cInfo->bIsDDCPort = 1.\n!\n!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,\n!                 NVAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned.\n!\n!                 If a register address is specified (i.e. regAddrSize is positive), then the transaction will be performed in\n!                 the combined format described in the I2C specification.  The register address will be written, followed by\n!                 reading into the data buffer.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 85\n!\n! \\param [in]   hPhysicalGPU     GPU selection.\n! \\param [out]  NV_I2C_INFO     *pI2cInfo The I2C data input structure\n!\n! \\retval   NVAPI_OK                            Completed request\n! \\retval   NVAPI_ERROR                         Miscellaneous error occurred.\n! \\retval   NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).\n! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.\n! \\retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION   Structure version is not supported.\n! \\retval   NVAPI_INVALID_ARGUMENT - argument does not meet specified requirements\n! \\retval   NVAPI_ARGUMENT_EXCEED_MAX_SIZE - an argument exceeds the maximum\n!\n! \\ingroup i2capi\n"]
    pub fn NvAPI_I2CRead(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pI2cInfo: *mut NV_I2C_INFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function writes the data buffer to the I2C port.\n!\n!                 The I2C request must be for a DDC port: pI2cInfo->bIsDDCPort = 1.\n!\n!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,\n!                 NVAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned.\n!\n!                 If a register address is specified (i.e. regAddrSize is positive), then the register address will be written\n!                 and the data buffer will immediately follow without a restart.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 85\n!\n! \\param [in]   hPhysicalGPU     GPU selection.\n! \\param [in]   pI2cInfo         The I2C data input structure\n!\n! \\retval   NVAPI_OK                            Completed request\n! \\retval   NVAPI_ERROR                         Miscellaneous error occurred.\n! \\retval   NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).\n! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.\n! \\retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION    Structure version is not supported.\n! \\retval   NVAPI_INVALID_ARGUMENT              Argument does not meet specified requirements\n! \\retval   NVAPI_ARGUMENT_EXCEED_MAX_SIZE      Argument exceeds the maximum\n!\n! \\ingroup i2capi\n"]
    pub fn NvAPI_I2CWrite(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pI2cInfo: *mut NV_I2C_INFO,
    ) -> NvAPI_Status;
}
pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_NVAPI_GPU_WORKSTATION_FEATURE_MASK_SWAPGROUP:
    NVAPI_GPU_WORKSTATION_FEATURE_MASK = 1;
pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_NVAPI_GPU_WORKSTATION_FEATURE_MASK_STEREO:
    NVAPI_GPU_WORKSTATION_FEATURE_MASK = 16;
pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_NVAPI_GPU_WORKSTATION_FEATURE_MASK_WARPING:
    NVAPI_GPU_WORKSTATION_FEATURE_MASK = 256;
pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_NVAPI_GPU_WORKSTATION_FEATURE_MASK_PIXINTENSITY:
    NVAPI_GPU_WORKSTATION_FEATURE_MASK = 512;
pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_NVAPI_GPU_WORKSTATION_FEATURE_MASK_GRAYSCALE:
    NVAPI_GPU_WORKSTATION_FEATURE_MASK = 1024;
pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_NVAPI_GPU_WORKSTATION_FEATURE_MASK_BPC10:
    NVAPI_GPU_WORKSTATION_FEATURE_MASK = 4096;
#[doc = "! \\ingroup gpu"]
pub type NVAPI_GPU_WORKSTATION_FEATURE_MASK = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_WorkstationFeatureSetup(
        hPhysicalGpu: NvPhysicalGpuHandle,
        featureEnableMask: NvU32,
        featureDisableMask: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_WorkstationFeatureQuery(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pConfiguredFeatureMask: *mut NvU32,
        pConsistentFeatureMask: *mut NvU32,
    ) -> NvAPI_Status;
}
pub const _NV_GPU_HDCP_FUSE_STATE_NV_GPU_HDCP_FUSE_STATE_UNKNOWN: _NV_GPU_HDCP_FUSE_STATE = 0;
pub const _NV_GPU_HDCP_FUSE_STATE_NV_GPU_HDCP_FUSE_STATE_DISABLED: _NV_GPU_HDCP_FUSE_STATE = 1;
pub const _NV_GPU_HDCP_FUSE_STATE_NV_GPU_HDCP_FUSE_STATE_ENABLED: _NV_GPU_HDCP_FUSE_STATE = 2;
#[doc = "! HDCP fuse states - used in NV_GPU_GET_HDCP_SUPPORT_STATUS"]
pub type _NV_GPU_HDCP_FUSE_STATE = ::std::os::raw::c_int;
#[doc = "! HDCP fuse states - used in NV_GPU_GET_HDCP_SUPPORT_STATUS"]
pub use self::_NV_GPU_HDCP_FUSE_STATE as NV_GPU_HDCP_FUSE_STATE;
pub const _NV_GPU_HDCP_KEY_SOURCE_NV_GPU_HDCP_KEY_SOURCE_UNKNOWN: _NV_GPU_HDCP_KEY_SOURCE = 0;
pub const _NV_GPU_HDCP_KEY_SOURCE_NV_GPU_HDCP_KEY_SOURCE_NONE: _NV_GPU_HDCP_KEY_SOURCE = 1;
pub const _NV_GPU_HDCP_KEY_SOURCE_NV_GPU_HDCP_KEY_SOURCE_CRYPTO_ROM: _NV_GPU_HDCP_KEY_SOURCE = 2;
pub const _NV_GPU_HDCP_KEY_SOURCE_NV_GPU_HDCP_KEY_SOURCE_SBIOS: _NV_GPU_HDCP_KEY_SOURCE = 3;
pub const _NV_GPU_HDCP_KEY_SOURCE_NV_GPU_HDCP_KEY_SOURCE_I2C_ROM: _NV_GPU_HDCP_KEY_SOURCE = 4;
pub const _NV_GPU_HDCP_KEY_SOURCE_NV_GPU_HDCP_KEY_SOURCE_FUSES: _NV_GPU_HDCP_KEY_SOURCE = 5;
#[doc = "! HDCP key sources - used in NV_GPU_GET_HDCP_SUPPORT_STATUS"]
pub type _NV_GPU_HDCP_KEY_SOURCE = ::std::os::raw::c_int;
#[doc = "! HDCP key sources - used in NV_GPU_GET_HDCP_SUPPORT_STATUS"]
pub use self::_NV_GPU_HDCP_KEY_SOURCE as NV_GPU_HDCP_KEY_SOURCE;
pub const _NV_GPU_HDCP_KEY_SOURCE_STATE_NV_GPU_HDCP_KEY_SOURCE_STATE_UNKNOWN:
    _NV_GPU_HDCP_KEY_SOURCE_STATE = 0;
pub const _NV_GPU_HDCP_KEY_SOURCE_STATE_NV_GPU_HDCP_KEY_SOURCE_STATE_ABSENT:
    _NV_GPU_HDCP_KEY_SOURCE_STATE = 1;
pub const _NV_GPU_HDCP_KEY_SOURCE_STATE_NV_GPU_HDCP_KEY_SOURCE_STATE_PRESENT:
    _NV_GPU_HDCP_KEY_SOURCE_STATE = 2;
#[doc = "! HDCP key source states - used in NV_GPU_GET_HDCP_SUPPORT_STATUS"]
pub type _NV_GPU_HDCP_KEY_SOURCE_STATE = ::std::os::raw::c_int;
#[doc = "! HDCP key source states - used in NV_GPU_GET_HDCP_SUPPORT_STATUS"]
pub use self::_NV_GPU_HDCP_KEY_SOURCE_STATE as NV_GPU_HDCP_KEY_SOURCE_STATE;
#[doc = "! HDPC support status - used in NvAPI_GPU_GetHDCPSupportStatus()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_GET_HDCP_SUPPORT_STATUS {
    pub version: NvU32,
    #[doc = "! Structure version constucted by macro #NV_GPU_GET_HDCP_SUPPORT_STATUS"]
    pub hdcpFuseState: NV_GPU_HDCP_FUSE_STATE,
    #[doc = "! GPU's HDCP fuse state"]
    pub hdcpKeySource: NV_GPU_HDCP_KEY_SOURCE,
    #[doc = "! GPU's HDCP key source"]
    pub hdcpKeySourceState: NV_GPU_HDCP_KEY_SOURCE_STATE,
}
#[test]
fn bindgen_test_layout_NV_GPU_GET_HDCP_SUPPORT_STATUS() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_GET_HDCP_SUPPORT_STATUS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_GET_HDCP_SUPPORT_STATUS>(),
        16usize,
        concat!("Size of: ", stringify!(NV_GPU_GET_HDCP_SUPPORT_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_GET_HDCP_SUPPORT_STATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_GET_HDCP_SUPPORT_STATUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_GET_HDCP_SUPPORT_STATUS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdcpFuseState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_GET_HDCP_SUPPORT_STATUS),
            "::",
            stringify!(hdcpFuseState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdcpKeySource) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_GET_HDCP_SUPPORT_STATUS),
            "::",
            stringify!(hdcpKeySource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdcpKeySourceState) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_GET_HDCP_SUPPORT_STATUS),
            "::",
            stringify!(hdcpKeySourceState)
        )
    );
}
extern "C" {
    #[doc = "!  \\ingroup gpu"]
    pub fn NvAPI_GPU_GetHDCPSupportStatus(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pGetHDCPSupportStatus: *mut NV_GPU_GET_HDCP_SUPPORT_STATUS,
    ) -> NvAPI_Status;
}
#[doc = "! @}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_COMPUTE_GPU_TOPOLOGY_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Total number of compute-capable GPUs"]
    pub gpuCount: NvU32,
    #[doc = "!< Array of compute-capable physical GPUs."]
    pub computeGpus: [NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1 {
    #[doc = "!< Compute-capable physical GPU handle"]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< One or more flags from \\ref nvcomp_gpu_top"]
    pub flags: NvU32,
}
#[test]
fn bindgen_test_layout_NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1),
            "::",
            stringify!(hPhysicalGpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_COMPUTE_GPU_TOPOLOGY_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_COMPUTE_GPU_TOPOLOGY_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_COMPUTE_GPU_TOPOLOGY_V1>(),
        136usize,
        concat!("Size of: ", stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_COMPUTE_GPU_TOPOLOGY_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1),
            "::",
            stringify!(gpuCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).computeGpus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_COMPUTE_GPU_TOPOLOGY_V1),
            "::",
            stringify!(computeGpus)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COMPUTE_GPU {
    #[doc = "!< Compute-capable physical GPU handle"]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< One or more flags from \\ref nvcomp_gpu_top"]
    pub flags: NvU32,
}
#[test]
fn bindgen_test_layout__NV_COMPUTE_GPU() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_COMPUTE_GPU> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_COMPUTE_GPU>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_COMPUTE_GPU))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COMPUTE_GPU>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_COMPUTE_GPU))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COMPUTE_GPU),
            "::",
            stringify!(hPhysicalGpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COMPUTE_GPU),
            "::",
            stringify!(flags)
        )
    );
}
pub type NV_COMPUTE_GPU = _NV_COMPUTE_GPU;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COMPUTE_GPU_TOPOLOGY_V2 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Size of array"]
    pub gpuCount: NvU32,
    #[doc = "!< Array of compute-capable physical GPUs (allocate memory of size of Physical gpuCount of system)."]
    pub computeGpus: *mut NV_COMPUTE_GPU,
}
#[test]
fn bindgen_test_layout__NV_COMPUTE_GPU_TOPOLOGY_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_COMPUTE_GPU_TOPOLOGY_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_COMPUTE_GPU_TOPOLOGY_V2>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_COMPUTE_GPU_TOPOLOGY_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COMPUTE_GPU_TOPOLOGY_V2>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_COMPUTE_GPU_TOPOLOGY_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COMPUTE_GPU_TOPOLOGY_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COMPUTE_GPU_TOPOLOGY_V2),
            "::",
            stringify!(gpuCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).computeGpus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COMPUTE_GPU_TOPOLOGY_V2),
            "::",
            stringify!(computeGpus)
        )
    );
}
pub type NV_COMPUTE_GPU_TOPOLOGY_V2 = _NV_COMPUTE_GPU_TOPOLOGY_V2;
pub type NV_COMPUTE_GPU_TOPOLOGY = NV_COMPUTE_GPU_TOPOLOGY_V2;
extern "C" {
    #[doc = "! DESCRIPTION:   This API enumerates one or more compute-capable GPUs.\n!                Note that this API is deprecated and should no longer be used for new software development.\n! \\deprecated  Do not use this function - it is deprecated in release 319.\n! SUPPORTED OS:  Windows 10 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in,out]      pComputeTopo  Pointer to the structure NV_COMPUTE_GPU_TOPOLOGY.\n!\n! \\retval ::NVAPI_OK                           The request was completed successfully.\n!                                              The gpuCount indicates if one or more compute-capable GPUs are found.\n!                                              gpuCount >= 1 means atleast one compute-capable GPU is found.\n! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Structure version is not supported, initialize to NV_COMPUTE_GPU_TOPOLOGY_VER.\n! \\retval ::NVAPI_ERROR                        Enumeration of the GPUs failed. Make sure at least one NVIDIA GPU exists in the system.\n!\n! \\ingroup gpucuda\n"]
    pub fn NvAPI_GPU_CudaEnumComputeCapableGpus(
        pComputeTopo: *mut NV_COMPUTE_GPU_TOPOLOGY,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API retrieves the fan speed tachometer reading for the specified physical GPU.\n!\n!   HOW TO USE:\n!                 - NvU32 Value = 0;\n!                 - ret = NvAPI_GPU_GetTachReading(hPhysicalGpu, &Value);\n!                 - On call success:\n!                 - Value contains the tachometer reading\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\param [in]    hPhysicalGpu   GPU selection.\n! \\param [out]   pValue         Pointer to a variable to get the tachometer reading\n!\n! \\retval ::NVAPI_OK - completed request\n! \\retval ::NVAPI_ERROR - miscellaneous error occurred\n! \\retval ::NVAPI_NOT_SUPPORTED - functionality not supported\n! \\retval ::NVAPI_API_NOT_INTIALIZED - nvapi not initialized\n! \\retval ::NVAPI_INVALID_ARGUMENT - invalid argument passed\n! \\retval ::NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)\n! \\retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle\n!\n! \\ingroup gpucooler\n"]
    pub fn NvAPI_GPU_GetTachReading(
        hPhysicalGPU: NvPhysicalGpuHandle,
        pValue: *mut NvU32,
    ) -> NvAPI_Status;
}
pub const _NV_ECC_CONFIGURATION_NV_ECC_CONFIGURATION_NOT_SUPPORTED: _NV_ECC_CONFIGURATION = 0;
#[doc = "!< Changes require a POST to take effect"]
pub const _NV_ECC_CONFIGURATION_NV_ECC_CONFIGURATION_DEFERRED: _NV_ECC_CONFIGURATION = 1;
#[doc = "!< Changes can optionally be made to take effect immediately"]
pub const _NV_ECC_CONFIGURATION_NV_ECC_CONFIGURATION_IMMEDIATE: _NV_ECC_CONFIGURATION = 2;
#[doc = "! \\addtogroup gpuecc\n! Used in NV_GPU_ECC_STATUS_INFO."]
pub type _NV_ECC_CONFIGURATION = ::std::os::raw::c_int;
#[doc = "! \\addtogroup gpuecc\n! Used in NV_GPU_ECC_STATUS_INFO."]
pub use self::_NV_ECC_CONFIGURATION as NV_ECC_CONFIGURATION;
#[doc = "! \\ingroup gpuecc\n! Used in NvAPI_GPU_GetECCStatusInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_ECC_STATUS_INFO {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "!< Supported ECC memory feature configuration options"]
    pub configurationOptions: NV_ECC_CONFIGURATION,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_NV_GPU_ECC_STATUS_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_ECC_STATUS_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ECC_STATUS_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(NV_GPU_ECC_STATUS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ECC_STATUS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_ECC_STATUS_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ECC_STATUS_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).configurationOptions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ECC_STATUS_INFO),
            "::",
            stringify!(configurationOptions)
        )
    );
}
impl NV_GPU_ECC_STATUS_INFO {
    #[inline]
    pub fn isSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isSupported: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isSupported: u32 = unsafe { ::std::mem::transmute(isSupported) };
            isSupported as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(isEnabled: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = "! \\ingroup gpuecc"]
    pub fn NvAPI_GPU_GetECCStatusInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pECCStatusInfo: *mut NV_GPU_ECC_STATUS_INFO,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpuecc\n! Used in NvAPI_GPU_GetECCErrorInfo()/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_ECC_ERROR_INFO {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub current: NV_GPU_ECC_ERROR_INFO__bindgen_ty_1,
    pub aggregate: NV_GPU_ECC_ERROR_INFO__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_ECC_ERROR_INFO__bindgen_ty_1 {
    #[doc = "!< Number of single-bit ECC errors detected since last boot"]
    pub singleBitErrors: NvU64,
    #[doc = "!< Number of double-bit ECC errors detected since last boot"]
    pub doubleBitErrors: NvU64,
}
#[test]
fn bindgen_test_layout_NV_GPU_ECC_ERROR_INFO__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_ECC_ERROR_INFO__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ECC_ERROR_INFO__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ECC_ERROR_INFO__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singleBitErrors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_1),
            "::",
            stringify!(singleBitErrors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doubleBitErrors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_1),
            "::",
            stringify!(doubleBitErrors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_ECC_ERROR_INFO__bindgen_ty_2 {
    #[doc = "!< Number of single-bit ECC errors detected since last counter reset"]
    pub singleBitErrors: NvU64,
    #[doc = "!< Number of double-bit ECC errors detected since last counter reset"]
    pub doubleBitErrors: NvU64,
}
#[test]
fn bindgen_test_layout_NV_GPU_ECC_ERROR_INFO__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_ECC_ERROR_INFO__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ECC_ERROR_INFO__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ECC_ERROR_INFO__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singleBitErrors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_2),
            "::",
            stringify!(singleBitErrors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doubleBitErrors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ECC_ERROR_INFO__bindgen_ty_2),
            "::",
            stringify!(doubleBitErrors)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_GPU_ECC_ERROR_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_ECC_ERROR_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ECC_ERROR_INFO>(),
        40usize,
        concat!("Size of: ", stringify!(NV_GPU_ECC_ERROR_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ECC_ERROR_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_GPU_ECC_ERROR_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ECC_ERROR_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ECC_ERROR_INFO),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aggregate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ECC_ERROR_INFO),
            "::",
            stringify!(aggregate)
        )
    );
}
extern "C" {
    #[doc = "\n! \\ingroup gpuecc"]
    pub fn NvAPI_GPU_GetECCErrorInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pECCErrorInfo: *mut NV_GPU_ECC_ERROR_INFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This function resets ECC memory error counters.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\requires Administrator privileges since release 430.39\n!\n! \\param [in]     hPhysicalGpu     A handle identifying the physical GPU for\n!                                  which ECC error information is to be\n!                                  cleared.\n! \\param [in]     bResetCurrent    Reset the current ECC error counters.\n! \\param [in]     bResetAggregate  Reset the aggregate ECC error counters.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!          specific meaning for this API, they are listed below.\n!\n! \\retval ::NVAPI_INVALID_USER_PRIVILEGE       - The application will require Administrator privileges to access this API.\n!                                                The application can be elevated to a higher permission level by selecting \"Run as Administrator\".\n!\n! \\ingroup gpuecc\n"]
    pub fn NvAPI_GPU_ResetECCErrorInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        bResetCurrent: NvU8,
        bResetAggregate: NvU8,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpuecc\n! Used in NvAPI_GPU_GetECCConfigurationInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_ECC_CONFIGURATION_INFO {
    pub version: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_NV_GPU_ECC_CONFIGURATION_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_ECC_CONFIGURATION_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_ECC_CONFIGURATION_INFO>(),
        8usize,
        concat!("Size of: ", stringify!(NV_GPU_ECC_CONFIGURATION_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_ECC_CONFIGURATION_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_ECC_CONFIGURATION_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_ECC_CONFIGURATION_INFO),
            "::",
            stringify!(version)
        )
    );
}
impl NV_GPU_ECC_CONFIGURATION_INFO {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isEnabledByDefault(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabledByDefault(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        isEnabledByDefault: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isEnabledByDefault: u32 = unsafe { ::std::mem::transmute(isEnabledByDefault) };
            isEnabledByDefault as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = "! \\ingroup gpuecc"]
    pub fn NvAPI_GPU_GetECCConfigurationInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pECCConfigurationInfo: *mut NV_GPU_ECC_CONFIGURATION_INFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This function updates the ECC memory configuration setting.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\requires Administrator privileges since release 430.39\n!\n! \\param [in]      hPhysicalGpu    A handle identifying the physical GPU for\n!                                  which to update the ECC configuration\n!                                  setting.\n! \\param [in]      bEnable         The new ECC configuration setting.\n! \\param [in]      bEnableImmediately   Request that the new setting take effect immediately.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!          specific meaning for this API, they are listed below.\n!\n! \\retval ::NVAPI_INVALID_CONFIGURATION        - Possibly SLI is enabled. Disable SLI and retry.\n! \\retval ::NVAPI_INVALID_USER_PRIVILEGE       - The application will require Administrator privileges to access this API.\n!                                                The application can be elevated to a higher permission level by selecting \"Run as Administrator\".\n!\n! \\ingroup gpuecc\n"]
    pub fn NvAPI_GPU_SetECCConfiguration(
        hPhysicalGpu: NvPhysicalGpuHandle,
        bEnable: NvU8,
        bEnableImmediately: NvU8,
    ) -> NvAPI_Status;
}
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_NONE: NV_QSYNC_EVENT = 0;
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_SYNC_LOSS: NV_QSYNC_EVENT = 1;
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_SYNC_GAIN: NV_QSYNC_EVENT = 2;
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_HOUSESYNC_GAIN: NV_QSYNC_EVENT = 3;
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_HOUSESYNC_LOSS: NV_QSYNC_EVENT = 4;
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_RJ45_GAIN: NV_QSYNC_EVENT = 5;
pub const NV_QSYNC_EVENT_NV_QSYNC_EVENT_RJ45_LOSS: NV_QSYNC_EVENT = 6;
pub type NV_QSYNC_EVENT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_QSYNC_EVENT_DATA {
    pub qsyncEvent: NV_QSYNC_EVENT,
    pub reserved: [NvU32; 7usize],
}
#[test]
fn bindgen_test_layout_NV_QSYNC_EVENT_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<NV_QSYNC_EVENT_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_QSYNC_EVENT_DATA>(),
        32usize,
        concat!("Size of: ", stringify!(NV_QSYNC_EVENT_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_QSYNC_EVENT_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_QSYNC_EVENT_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qsyncEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_QSYNC_EVENT_DATA),
            "::",
            stringify!(qsyncEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_QSYNC_EVENT_DATA),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = "! Callback for QSYNC event"]
pub type NVAPI_CALLBACK_QSYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        qyncEventData: NV_QSYNC_EVENT_DATA,
        callbackParam: *mut ::std::os::raw::c_void,
    ),
>;
pub const NV_EVENT_TYPE_NV_EVENT_TYPE_NONE: NV_EVENT_TYPE = 0;
pub const NV_EVENT_TYPE_NV_EVENT_TYPE_QSYNC: NV_EVENT_TYPE = 6;
#[doc = "! Enum for Event IDs"]
pub type NV_EVENT_TYPE = ::std::os::raw::c_int;
#[doc = "! Core NV_EVENT_REGISTER_CALLBACK structure declaration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_EVENT_REGISTER_CALLBACK {
    #[doc = "!< version field to ensure minimum version compatibility"]
    pub version: NvU32,
    #[doc = "!< ID of the event being sent"]
    pub eventId: NV_EVENT_TYPE,
    #[doc = "!< This value will be passed back to the callback function when an event occurs"]
    pub callbackParam: *mut ::std::os::raw::c_void,
    pub nvCallBackFunc: NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1 {
    #[doc = "!< Callback function pointer for QSYNC events"]
    pub nvQSYNCEventCallback: NVAPI_CALLBACK_QSYNCEVENT,
}
#[test]
fn bindgen_test_layout_NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvQSYNCEventCallback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1),
            "::",
            stringify!(nvQSYNCEventCallback)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_EVENT_REGISTER_CALLBACK() {
    const UNINIT: ::std::mem::MaybeUninit<NV_EVENT_REGISTER_CALLBACK> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_EVENT_REGISTER_CALLBACK>(),
        24usize,
        concat!("Size of: ", stringify!(NV_EVENT_REGISTER_CALLBACK))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_EVENT_REGISTER_CALLBACK>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_EVENT_REGISTER_CALLBACK))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EVENT_REGISTER_CALLBACK),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EVENT_REGISTER_CALLBACK),
            "::",
            stringify!(eventId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbackParam) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EVENT_REGISTER_CALLBACK),
            "::",
            stringify!(callbackParam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvCallBackFunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_EVENT_REGISTER_CALLBACK),
            "::",
            stringify!(nvCallBackFunc)
        )
    );
}
#[doc = "! Core NV_EVENT_REGISTER_CALLBACK structure declaration"]
pub type PNV_EVENT_REGISTER_CALLBACK = *mut NV_EVENT_REGISTER_CALLBACK;
#[doc = "!< NVIDIA RTX VR Ready"]
pub const _NV_GPU_WORKSTATION_FEATURE_TYPE_NV_GPU_WORKSTATION_FEATURE_TYPE_NVIDIA_RTX_VR_READY:
    _NV_GPU_WORKSTATION_FEATURE_TYPE = 1;
#[doc = "!< DEPRECATED name - do not use"]
pub const _NV_GPU_WORKSTATION_FEATURE_TYPE_NV_GPU_WORKSTATION_FEATURE_TYPE_QUADRO_VR_READY:
    _NV_GPU_WORKSTATION_FEATURE_TYPE = 1;
pub const _NV_GPU_WORKSTATION_FEATURE_TYPE_NV_GPU_WORKSTATION_FEATURE_TYPE_PROVIZ:
    _NV_GPU_WORKSTATION_FEATURE_TYPE = 2;
#[doc = "! \\ingroup gpu"]
pub type _NV_GPU_WORKSTATION_FEATURE_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
pub use self::_NV_GPU_WORKSTATION_FEATURE_TYPE as NV_GPU_WORKSTATION_FEATURE_TYPE;
extern "C" {
    #[doc = "! \\fn NvAPI_GPU_QueryWorkstationFeatureSupport(NvPhysicalGpuHandle physicalGpu, NV_GPU_WORKSTATION_FEATURE_TYPE gpuWorkstationFeature)\n! \\code\n! DESCRIPTION:     Indicates whether a queried workstation feature is supported by the requested GPU.\n!\n! SUPPORTED OS:  Windows 10 and higher\n!\n! \\since Release: 440\n!\n! DESCRIPTION:     This API, when called with a valid physical gpu handle as Input, lets caller know whether the given workstation feature is supported by this GPU.\n!\n! PARAMETERS:      physicalGpu(IN)            : The handle of the GPU for the which caller wants to get the support information.\n!                  gpuWorkstationFeature(IN ) : The feature for the GPU in question. One of the values from enum NV_GPU_WORKSTATION_FEATURE_TYPE.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status listed below\n!\n! \\retval ::NVAPI_OK the queried workstation feature is supported on the given GPU.\n! \\retval ::NVAPI_NO_IMPLEMENTATION the current driver doesn't support this interface.\n! \\retval ::NVAPI_INVALID_HANDLE the incoming physicalGpu handle is invalid.\n! \\retval ::NVAPI_NOT_SUPPORTED the requested gpuWorkstationFeature is not supported in the selected GPU.\n! \\retval ::NVAPI_SETTING_NOT_FOUND the requested gpuWorkstationFeature is unknown to the current driver version.\n!\n! \\endcode\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_QueryWorkstationFeatureSupport(
        physicalGpu: NvPhysicalGpuHandle,
        gpuWorkstationFeature: NV_GPU_WORKSTATION_FEATURE_TYPE,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_SCANOUT_INTENSITY_DATA_V1 {
    #[doc = "!< version of this structure"]
    pub version: NvU32,
    #[doc = "!< width of the input texture"]
    pub width: NvU32,
    #[doc = "!< height of the input texture"]
    pub height: NvU32,
    #[doc = "!< array of floating values building an intensity RGB texture"]
    pub blendingTexture: *mut f32,
}
#[test]
fn bindgen_test_layout_NV_SCANOUT_INTENSITY_DATA_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_SCANOUT_INTENSITY_DATA_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_SCANOUT_INTENSITY_DATA_V1>(),
        24usize,
        concat!("Size of: ", stringify!(NV_SCANOUT_INTENSITY_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_SCANOUT_INTENSITY_DATA_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_SCANOUT_INTENSITY_DATA_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_INTENSITY_DATA_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_INTENSITY_DATA_V1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_INTENSITY_DATA_V1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blendingTexture) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_INTENSITY_DATA_V1),
            "::",
            stringify!(blendingTexture)
        )
    );
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_SCANOUT_INTENSITY_DATA_V2 {
    #[doc = "!< version of this structure"]
    pub version: NvU32,
    #[doc = "!< width of the input texture"]
    pub width: NvU32,
    #[doc = "!< height of the input texture"]
    pub height: NvU32,
    #[doc = "!< array of floating values building an intensity RGB texture"]
    pub blendingTexture: *mut f32,
    #[doc = "!< array of floating values building an offset texture"]
    pub offsetTexture: *mut f32,
    #[doc = "!< number of channels per pixel in the offset texture"]
    pub offsetTexChannels: NvU32,
}
#[test]
fn bindgen_test_layout_NV_SCANOUT_INTENSITY_DATA_V2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_SCANOUT_INTENSITY_DATA_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_SCANOUT_INTENSITY_DATA_V2>(),
        40usize,
        concat!("Size of: ", stringify!(NV_SCANOUT_INTENSITY_DATA_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_SCANOUT_INTENSITY_DATA_V2>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_SCANOUT_INTENSITY_DATA_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_INTENSITY_DATA_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_INTENSITY_DATA_V2),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_INTENSITY_DATA_V2),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blendingTexture) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_INTENSITY_DATA_V2),
            "::",
            stringify!(blendingTexture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsetTexture) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_INTENSITY_DATA_V2),
            "::",
            stringify!(offsetTexture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsetTexChannels) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_INTENSITY_DATA_V2),
            "::",
            stringify!(offsetTexChannels)
        )
    );
}
#[doc = "! \\ingroup gpu"]
pub type NV_SCANOUT_INTENSITY_DATA = NV_SCANOUT_INTENSITY_DATA_V2;
extern "C" {
    #[doc = "!   DESCRIPTION: This API enables and sets up per-pixel intensity feature on the specified display.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]   displayId              combined physical display and GPU identifier of the display to apply the intensity control.\n! \\param [in]   scanoutIntensityData   the intensity texture info.\n! \\param [out]  pbSticky(OUT)           indicates whether the settings will be kept over a reboot.\n!\n! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.\n! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.\n! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs\n! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input data.\n! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION NV_SCANOUT_INTENSITY_DATA structure version mismatch.\n! \\retval ::NVAPI_OK Feature enabled.\n! \\retval ::NVAPI_ERROR Miscellaneous error occurred.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_SetScanoutIntensity(
        displayId: NvU32,
        scanoutIntensityData: *mut NV_SCANOUT_INTENSITY_DATA,
        pbSticky: *mut ::std::os::raw::c_int,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_SCANOUT_INTENSITY_STATE_DATA {
    #[doc = "!< version of this structure"]
    pub version: NvU32,
    #[doc = "!< intensity is enabled or not"]
    pub bEnabled: NvU32,
}
#[test]
fn bindgen_test_layout__NV_SCANOUT_INTENSITY_STATE_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_SCANOUT_INTENSITY_STATE_DATA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_SCANOUT_INTENSITY_STATE_DATA>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_SCANOUT_INTENSITY_STATE_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SCANOUT_INTENSITY_STATE_DATA>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_SCANOUT_INTENSITY_STATE_DATA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SCANOUT_INTENSITY_STATE_DATA),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bEnabled) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SCANOUT_INTENSITY_STATE_DATA),
            "::",
            stringify!(bEnabled)
        )
    );
}
#[doc = "! \\ingroup gpu"]
pub type NV_SCANOUT_INTENSITY_STATE_DATA = _NV_SCANOUT_INTENSITY_STATE_DATA;
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries current state of the intensity feature on the specified display.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]     displayId                       combined physical display and GPU identifier of the display to query the configuration.\n! \\param [in,out] scanoutIntensityStateData       intensity state data.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!          specific meaning for this API, they are listed below.\n!\n! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.\n! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.\n! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs.\n! \\retval ::NVAPI_OK Feature enabled.\n! \\retval ::NVAPI_ERROR Miscellaneous error occurred.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetScanoutIntensityState(
        displayId: NvU32,
        scanoutIntensityStateData: *mut NV_SCANOUT_INTENSITY_STATE_DATA,
    ) -> NvAPI_Status;
}
pub const NV_GPU_WARPING_VERTICE_FORMAT_NV_GPU_WARPING_VERTICE_FORMAT_TRIANGLESTRIP_XYUVRQ:
    NV_GPU_WARPING_VERTICE_FORMAT = 0;
pub const NV_GPU_WARPING_VERTICE_FORMAT_NV_GPU_WARPING_VERTICE_FORMAT_TRIANGLES_XYUVRQ:
    NV_GPU_WARPING_VERTICE_FORMAT = 1;
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_WARPING_VERTICE_FORMAT = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_SCANOUT_WARPING_DATA {
    #[doc = "!< version of this structure"]
    pub version: NvU32,
    #[doc = "!< width of the input texture"]
    pub vertices: *mut f32,
    #[doc = "!< format of the input vertices"]
    pub vertexFormat: NV_GPU_WARPING_VERTICE_FORMAT,
    #[doc = "!< number of the input vertices"]
    pub numVertices: ::std::os::raw::c_int,
    #[doc = "!< rectangle in desktop coordinates describing the source area for the warping"]
    pub textureRect: *mut NvSBox,
}
#[test]
fn bindgen_test_layout_NV_SCANOUT_WARPING_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<NV_SCANOUT_WARPING_DATA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_SCANOUT_WARPING_DATA>(),
        32usize,
        concat!("Size of: ", stringify!(NV_SCANOUT_WARPING_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_SCANOUT_WARPING_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_SCANOUT_WARPING_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_WARPING_DATA),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertices) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_WARPING_DATA),
            "::",
            stringify!(vertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertexFormat) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_WARPING_DATA),
            "::",
            stringify!(vertexFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numVertices) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_WARPING_DATA),
            "::",
            stringify!(numVertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).textureRect) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SCANOUT_WARPING_DATA),
            "::",
            stringify!(textureRect)
        )
    );
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API enables and sets up the warping feature on the specified display.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]    displayId               Combined physical display and GPU identifier of the display to apply the intensity control\n! \\param [in]    scanoutWarpingData      The warping data info\n! \\param [out]   pbSticky                Indicates whether the settings will be kept over a reboot.\n!\n! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.\n! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.\n! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs\n! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input data.\n! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION NV_SCANOUT_WARPING_DATA structure version mismatch.\n! \\retval ::NVAPI_OK Feature enabled.\n! \\retval ::NVAPI_ERROR Miscellaneous error occurred.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_SetScanoutWarping(
        displayId: NvU32,
        scanoutWarpingData: *mut NV_SCANOUT_WARPING_DATA,
        piMaxNumVertices: *mut ::std::os::raw::c_int,
        pbSticky: *mut ::std::os::raw::c_int,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_SCANOUT_WARPING_STATE_DATA {
    #[doc = "!< version of this structure"]
    pub version: NvU32,
    #[doc = "!< warping is enabled or not"]
    pub bEnabled: NvU32,
}
#[test]
fn bindgen_test_layout__NV_SCANOUT_WARPING_STATE_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_SCANOUT_WARPING_STATE_DATA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_SCANOUT_WARPING_STATE_DATA>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_SCANOUT_WARPING_STATE_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SCANOUT_WARPING_STATE_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_SCANOUT_WARPING_STATE_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SCANOUT_WARPING_STATE_DATA),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bEnabled) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SCANOUT_WARPING_STATE_DATA),
            "::",
            stringify!(bEnabled)
        )
    );
}
#[doc = "! \\ingroup gpu"]
pub type NV_SCANOUT_WARPING_STATE_DATA = _NV_SCANOUT_WARPING_STATE_DATA;
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries current state of the warping feature on the specified display.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]     displayId                      combined physical display and GPU identifier of the display to query the configuration.\n! \\param [in,out] scanoutWarpingStateData        warping state data.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!          specific meaning for this API, they are listed below.\n!\n! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.\n! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.\n! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs.\n! \\retval ::NVAPI_OK Feature enabled.\n! \\retval ::NVAPI_ERROR Miscellaneous error occurred.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetScanoutWarpingState(
        displayId: NvU32,
        scanoutWarpingStateData: *mut NV_SCANOUT_WARPING_STATE_DATA,
    ) -> NvAPI_Status;
}
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_WARPING_RESAMPLING_METHOD : NV_GPU_SCANOUT_COMPOSITION_PARAMETER = 0 ;
pub type NV_GPU_SCANOUT_COMPOSITION_PARAMETER = ::std::os::raw::c_int;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_SET_TO_DEFAULT : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 0 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BILINEAR : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 256 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_TRIANGULAR : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 257 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_BELL_SHAPED : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 258 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_BSPLINE : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 259 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_TRIANGULAR : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 260 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_BELL_SHAPED : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 261 ;
pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_BSPLINE : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = 262 ;
#[doc = "! This enum defines a collection of possible scanout composition values that can be used to configure\n! possible scanout composition settings.  (Currently the only parameter defined is the WARPING_RESAMPLING_METHOD)."]
pub type NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = ::std::os::raw::c_int;
extern "C" {
    #[doc = "!   DESCRIPTION: This API sets various parameters that configure the scanout composition feature on the specified display.\n!                (currently there is only one configurable parameter defined: WARPING_RESAMPLING_METHOD,\n!                 but this function is designed to support the addition of parameters as needed.)\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]    displayId               Combined physical display and GPU identifier of the display to apply the intensity control\n! \\param [in]    parameter               The scanout composition parameter to be set\n! \\param [in]    parameterValue          The data to be set for the specified parameter\n! \\param [in]    pContainer              Additional container for data associated with the specified parameter\n!\n! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.\n! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.\n! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs\n! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input data.\n! \\retval ::NVAPI_OK Feature enabled.\n! \\retval ::NVAPI_ERROR Miscellaneous error occurred.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_SetScanoutCompositionParameter(
        displayId: NvU32,
        parameter: NV_GPU_SCANOUT_COMPOSITION_PARAMETER,
        parameterValue: NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE,
        pContainer: *mut f32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries current state of one of the various scanout composition parameters on the specified display.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]     displayId           combined physical display and GPU identifier of the display to query the configuration.\n! \\param [in]     parameter           scanout composition parameter to by queried.\n! \\param [out] parameterData          scanout composition parameter data.\n! \\param [out]   pContainer           Additional container for returning data associated with the specified parameter\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!          specific meaning for this API, they are listed below.\n!\n! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.\n! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.\n! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs.\n! \\retval ::NVAPI_OK Feature enabled.\n! \\retval ::NVAPI_ERROR Miscellaneous error occurred.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetScanoutCompositionParameter(
        displayId: NvU32,
        parameter: NV_GPU_SCANOUT_COMPOSITION_PARAMETER,
        parameterData: *mut NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE,
        pContainer: *mut f32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries the desktop and scanout portion of the specified display.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]     displayId          combined physical display and GPU identifier of the display to query the configuration.\n! \\param [in,out] desktopRect        desktop area of the display in desktop coordinates.\n! \\param [in,out] scanoutRect        scanout area of the display relative to desktopRect.\n!\n! \\retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.\n! \\retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.\n! \\retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs.\n! \\retval ::NVAPI_OK Feature enabled.\n! \\retval ::NVAPI_ERROR Miscellaneous error occurred.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetScanoutConfiguration(
        displayId: NvU32,
        desktopRect: *mut NvSBox,
        scanoutRect: *mut NvSBox,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu\n! Used in NvAPI_GPU_GetScanoutConfigurationEx()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_SCANOUT_INFORMATION {
    #[doc = "!< Structure version, needs to be initialized with NV_SCANOUT_INFORMATION_VER."]
    pub version: NvU32,
    #[doc = "!< Operating system display device rect in desktop coordinates displayId is scanning out from."]
    pub sourceDesktopRect: NvSBox,
    #[doc = "!< Area inside the sourceDesktopRect which is scanned out to the display."]
    pub sourceViewportRect: NvSBox,
    #[doc = "!< Area inside the rect described by targetDisplayWidth/Height sourceViewportRect is scanned out to."]
    pub targetViewportRect: NvSBox,
    #[doc = "!< Horizontal size of the active resolution scanned out to the display."]
    pub targetDisplayWidth: NvU32,
    #[doc = "!< Vertical size of the active resolution scanned out to the display."]
    pub targetDisplayHeight: NvU32,
    #[doc = "!< If targets are cloned views of the sourceDesktopRect the cloned targets have an importance assigned (0:primary,1 secondary,...)."]
    pub cloneImportance: NvU32,
    #[doc = "!< Rotation performed between the sourceViewportRect and the targetViewportRect."]
    pub sourceToTargetRotation: NV_ROTATE,
}
#[test]
fn bindgen_test_layout__NV_SCANOUT_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_SCANOUT_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_SCANOUT_INFORMATION>(),
        68usize,
        concat!("Size of: ", stringify!(_NV_SCANOUT_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SCANOUT_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_SCANOUT_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SCANOUT_INFORMATION),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceDesktopRect) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SCANOUT_INFORMATION),
            "::",
            stringify!(sourceDesktopRect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceViewportRect) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SCANOUT_INFORMATION),
            "::",
            stringify!(sourceViewportRect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetViewportRect) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SCANOUT_INFORMATION),
            "::",
            stringify!(targetViewportRect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetDisplayWidth) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SCANOUT_INFORMATION),
            "::",
            stringify!(targetDisplayWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetDisplayHeight) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SCANOUT_INFORMATION),
            "::",
            stringify!(targetDisplayHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cloneImportance) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SCANOUT_INFORMATION),
            "::",
            stringify!(cloneImportance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceToTargetRotation) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SCANOUT_INFORMATION),
            "::",
            stringify!(sourceToTargetRotation)
        )
    );
}
#[doc = "! \\ingroup gpu\n! Used in NvAPI_GPU_GetScanoutConfigurationEx()."]
pub type NV_SCANOUT_INFORMATION = _NV_SCANOUT_INFORMATION;
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries the desktop and scanout portion of the specified display.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n! \\since Release: 331\n!\n! \\param [in]     displayId            combined physical display and GPU identifier of the display to query the configuration.\n! \\param [in,out] pScanoutInformation  desktop area to displayId mapping information.\n!\n! \\return This API can return any of the error codes enumerated in #NvAPI_Status.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetScanoutConfigurationEx(
        displayId: NvU32,
        pScanoutInformation: *mut NV_SCANOUT_INFORMATION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns the OS-AdapterID from physicalGpu Handle. OS-AdapterID\n!                is the Adapter ID that is used by Win7 CCD APIs.\n!                This API is deprecated. Please use NvAPI_GPU_GetLogicalGpuInfo to get the OS-AdapterID.\n!                NvAPI_GetLogicalGPUFromPhysicalGPU can be used to get the logical GPU handle associated with specified physical GPU handle.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 520. Instead, use NvAPI_GPU_GetLogicalGpuInfo.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]    hPhysicalGpu   PhysicalGpu Handle\n! \\param [out]   pOSAdapterId   Returns OS-AdapterId, it is typed as void * to\n!                               avoid dependency with windows.h. User must type cast it to LUID.\n!\n! \\retval ::NVAPI_INVALID_ARGUMENT pOSAdapterId is NULL; hPhysicalGpu is invalid\n! \\retval ::NVAPI_OK *pOSAdapterId contains valid data.\n! \\retval ::NVAPI_NOT_SUPPORTED  This API is not supported on the system.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetAdapterIdFromPhysicalGpu(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pOSAdapterId: *mut ::std::os::raw::c_void,
    ) -> NvAPI_Status;
}
#[doc = "!< Represents Bare Metal GPU"]
pub const _NV_VIRTUALIZATION_MODE_NV_VIRTUALIZATION_MODE_NONE: _NV_VIRTUALIZATION_MODE = 0;
#[doc = "!< Represents GPU-Passthrough"]
pub const _NV_VIRTUALIZATION_MODE_NV_VIRTUALIZATION_MODE_NMOS: _NV_VIRTUALIZATION_MODE = 1;
#[doc = "!< Represents vGPU inside virtual machine"]
pub const _NV_VIRTUALIZATION_MODE_NV_VIRTUALIZATION_MODE_VGX: _NV_VIRTUALIZATION_MODE = 2;
#[doc = "!< Represents VGX hypervisor in vGPU mode"]
pub const _NV_VIRTUALIZATION_MODE_NV_VIRTUALIZATION_MODE_HOST_VGPU: _NV_VIRTUALIZATION_MODE = 3;
#[doc = "! \\ingroup gpu"]
pub type _NV_VIRTUALIZATION_MODE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
pub use self::_NV_VIRTUALIZATION_MODE as NV_VIRTUALIZATION_MODE;
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_VIRTUALIZATION_INFO {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< one of NV_VIRTUALIZATION_MODE."]
    pub virtualizationMode: NV_VIRTUALIZATION_MODE,
    #[doc = "!< reserved for future use. Should be set to ZERO."]
    pub reserved: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GPU_VIRTUALIZATION_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_VIRTUALIZATION_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_VIRTUALIZATION_INFO>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_GPU_VIRTUALIZATION_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_VIRTUALIZATION_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GPU_VIRTUALIZATION_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_VIRTUALIZATION_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virtualizationMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_VIRTUALIZATION_INFO),
            "::",
            stringify!(virtualizationMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_VIRTUALIZATION_INFO),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_VIRTUALIZATION_INFO_V1 = _NV_GPU_VIRTUALIZATION_INFO;
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_VIRTUALIZATION_INFO = NV_GPU_VIRTUALIZATION_INFO_V1;
extern "C" {
    #[doc = "\n!\n! FUNCTION NAME: NvAPI_GPU_GetVirtualizationInfo\n!\n!   DESCRIPTION: This API returns virtualization information of the GPU\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 367\n!\n! \\param [in,out] pVirtualizationInfo         Pointer to NV_GPU_VIRTUALIZATION_INFO structure.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!          specific meaning for this API, they are listed below.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetVirtualizationInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pVirtualizationInfo: *mut NV_GPU_VIRTUALIZATION_INFO,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LOGICAL_GPU_DATA_V1 {
    #[doc = "!< [in]  Structure version."]
    pub version: NvU32,
    #[doc = "!< [out] Returns OS-AdapterId. User must send memory buffer of size atleast equal to the size of LUID structure before calling the NVAPI."]
    pub pOSAdapterId: *mut ::std::os::raw::c_void,
    #[doc = "!< [out] Number of physical GPU handles associated with the specified logical GPU handle."]
    pub physicalGpuCount: NvU32,
    #[doc = "!< [out] This array will be filled with physical GPU handles associated with the given logical GPU handle.\n!< The array index refers to the Physical Gpu Index (Idx).\n!< Idx value is the same as D3D11 MultiGPUDevice GPU index, D3D12 node index, OpenGL GL_NV_gpu_multicast GPU index.\n!< When converted to a bit mask (1 << Idx), it matches:\n!<    1. Vulkan deviceNodeMask in VkPhysicalDeviceIDProperties\n!<    2. CUDA deviceNodeMask returned by cuDeviceGetLuid"]
    pub physicalGpuHandles: [NvPhysicalGpuHandle; 64usize],
    #[doc = "!< Reserved for future use. Should be set to ZERO."]
    pub reserved: [NvU32; 8usize],
}
#[test]
fn bindgen_test_layout__NV_LOGICAL_GPU_DATA_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LOGICAL_GPU_DATA_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LOGICAL_GPU_DATA_V1>(),
        568usize,
        concat!("Size of: ", stringify!(_NV_LOGICAL_GPU_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LOGICAL_GPU_DATA_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_LOGICAL_GPU_DATA_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LOGICAL_GPU_DATA_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pOSAdapterId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LOGICAL_GPU_DATA_V1),
            "::",
            stringify!(pOSAdapterId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physicalGpuCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LOGICAL_GPU_DATA_V1),
            "::",
            stringify!(physicalGpuCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physicalGpuHandles) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LOGICAL_GPU_DATA_V1),
            "::",
            stringify!(physicalGpuHandles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LOGICAL_GPU_DATA_V1),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = "! \\ingroup gpu"]
pub type NV_LOGICAL_GPU_DATA_V1 = _NV_LOGICAL_GPU_DATA_V1;
#[doc = "! \\ingroup gpu"]
pub type NV_LOGICAL_GPU_DATA = NV_LOGICAL_GPU_DATA_V1;
extern "C" {
    #[doc = "!  This function is used to query Logical GPU information.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 421\n!\n! \\param [in]    hLogicalGpu            logical GPU Handle.\n! \\param [in,out] pLogicalGpuData        Pointer to NV_LOGICAL_GPU_DATA structure.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!          specific meaning for this API, they are listed below.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetLogicalGpuInfo(
        hLogicalGpu: NvLogicalGpuHandle,
        pLogicalGpuData: *mut NV_LOGICAL_GPU_DATA,
    ) -> NvAPI_Status;
}
#[doc = "! License string"]
pub type NvAPI_LicenseString = [::std::os::raw::c_char; 128usize];
pub const _NV_LICENSE_FEATURE_TYPE_NV_LICENSE_FEATURE_UNKNOWN: _NV_LICENSE_FEATURE_TYPE = 0;
pub const _NV_LICENSE_FEATURE_TYPE_NV_LICENSE_FEATURE_VGPU: _NV_LICENSE_FEATURE_TYPE = 1;
pub const _NV_LICENSE_FEATURE_TYPE_NV_LICENSE_FEATURE_NVIDIA_RTX: _NV_LICENSE_FEATURE_TYPE = 2;
#[doc = "!< DEPRECATED name - do not use"]
pub const _NV_LICENSE_FEATURE_TYPE_NV_LICENSE_FEATURE_QUADRO: _NV_LICENSE_FEATURE_TYPE = 2;
pub const _NV_LICENSE_FEATURE_TYPE_NV_LICENSE_FEATURE_GAMING: _NV_LICENSE_FEATURE_TYPE = 3;
pub const _NV_LICENSE_FEATURE_TYPE_NV_LICENSE_FEATURE_COMPUTE: _NV_LICENSE_FEATURE_TYPE = 4;
#[doc = "! Used in NV_LICENSE_FEATURE_DETAILS"]
pub type _NV_LICENSE_FEATURE_TYPE = ::std::os::raw::c_int;
#[doc = "! Used in NV_LICENSE_FEATURE_DETAILS"]
pub use self::_NV_LICENSE_FEATURE_TYPE as NV_LICENSE_FEATURE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSE_EXPIRY_DETAILS {
    #[doc = "!< Year value of license expiry"]
    pub year: NvU32,
    #[doc = "!< Month value of license expiry"]
    pub month: NvU16,
    #[doc = "!< Day value of license expiry"]
    pub day: NvU16,
    #[doc = "!< Hour value of license expiry"]
    pub hour: NvU16,
    #[doc = "!< Minutes value of license expiry"]
    pub min: NvU16,
    #[doc = "!< Seconds value of license expiry"]
    pub sec: NvU16,
    #[doc = "!< License expiry status"]
    pub status: NvU8,
}
#[test]
fn bindgen_test_layout__NV_LICENSE_EXPIRY_DETAILS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LICENSE_EXPIRY_DETAILS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSE_EXPIRY_DETAILS>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_LICENSE_EXPIRY_DETAILS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSE_EXPIRY_DETAILS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSE_EXPIRY_DETAILS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_EXPIRY_DETAILS),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_EXPIRY_DETAILS),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_EXPIRY_DETAILS),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_EXPIRY_DETAILS),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_EXPIRY_DETAILS),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_EXPIRY_DETAILS),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_EXPIRY_DETAILS),
            "::",
            stringify!(status)
        )
    );
}
pub type NV_LICENSE_EXPIRY_DETAILS = _NV_LICENSE_EXPIRY_DETAILS;
#[doc = "! Used in NV_LICENSABLE_FEATURES"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSE_FEATURE_DETAILS_V1 {
    #[doc = "!< IN - Structure version."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Feature code that corresponds to the licensable feature."]
    pub featureCode: NV_LICENSE_FEATURE_TYPE,
    #[doc = "!< Deprecated"]
    pub licenseInfo: NvAPI_LicenseString,
}
#[test]
fn bindgen_test_layout__NV_LICENSE_FEATURE_DETAILS_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LICENSE_FEATURE_DETAILS_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSE_FEATURE_DETAILS_V1>(),
        140usize,
        concat!("Size of: ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSE_FEATURE_DETAILS_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).featureCode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V1),
            "::",
            stringify!(featureCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licenseInfo) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V1),
            "::",
            stringify!(licenseInfo)
        )
    );
}
impl _NV_LICENSE_FEATURE_DETAILS_V1 {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Used in NV_LICENSABLE_FEATURES"]
pub type NV_LICENSE_FEATURE_DETAILS_V1 = _NV_LICENSE_FEATURE_DETAILS_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSE_FEATURE_DETAILS_V2 {
    #[doc = "!< Unused."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Feature code that corresponds to the licensable feature."]
    pub featureCode: NV_LICENSE_FEATURE_TYPE,
    #[doc = "!< Deprecated"]
    pub licenseInfo: NvAPI_LicenseString,
    #[doc = "!< Nvidia Grid licensable product name."]
    pub productName: NvAPI_LicenseString,
}
#[test]
fn bindgen_test_layout__NV_LICENSE_FEATURE_DETAILS_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LICENSE_FEATURE_DETAILS_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSE_FEATURE_DETAILS_V2>(),
        268usize,
        concat!("Size of: ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSE_FEATURE_DETAILS_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).featureCode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V2),
            "::",
            stringify!(featureCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licenseInfo) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V2),
            "::",
            stringify!(licenseInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).productName) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V2),
            "::",
            stringify!(productName)
        )
    );
}
impl _NV_LICENSE_FEATURE_DETAILS_V2 {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSE_FEATURE_DETAILS_V2 = _NV_LICENSE_FEATURE_DETAILS_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSE_FEATURE_DETAILS_V3 {
    #[doc = "!< Unused."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Feature code that corresponds to the licensable feature."]
    pub featureCode: NV_LICENSE_FEATURE_TYPE,
    #[doc = "!< Deprecated"]
    pub licenseInfo: NvAPI_LicenseString,
    #[doc = "!< Nvidia Grid licensable product name."]
    pub productName: NvAPI_LicenseString,
}
#[test]
fn bindgen_test_layout__NV_LICENSE_FEATURE_DETAILS_V3() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LICENSE_FEATURE_DETAILS_V3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSE_FEATURE_DETAILS_V3>(),
        268usize,
        concat!("Size of: ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSE_FEATURE_DETAILS_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).featureCode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V3),
            "::",
            stringify!(featureCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licenseInfo) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V3),
            "::",
            stringify!(licenseInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).productName) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V3),
            "::",
            stringify!(productName)
        )
    );
}
impl _NV_LICENSE_FEATURE_DETAILS_V3 {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isFeatureEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isFeatureEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        isFeatureEnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isFeatureEnabled: u32 = unsafe { ::std::mem::transmute(isFeatureEnabled) };
            isFeatureEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSE_FEATURE_DETAILS_V3 = _NV_LICENSE_FEATURE_DETAILS_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSE_FEATURE_DETAILS_V4 {
    #[doc = "!< Unused."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Feature code that corresponds to the licensable feature."]
    pub featureCode: NV_LICENSE_FEATURE_TYPE,
    #[doc = "!< Deprecated"]
    pub licenseInfo: NvAPI_LicenseString,
    #[doc = "!< Nvidia Grid licensable product name."]
    pub productName: NvAPI_LicenseString,
    #[doc = "!< License expiry information."]
    pub licenseExpiry: NV_LICENSE_EXPIRY_DETAILS,
}
#[test]
fn bindgen_test_layout__NV_LICENSE_FEATURE_DETAILS_V4() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LICENSE_FEATURE_DETAILS_V4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSE_FEATURE_DETAILS_V4>(),
        284usize,
        concat!("Size of: ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V4))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSE_FEATURE_DETAILS_V4>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSE_FEATURE_DETAILS_V4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V4),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).featureCode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V4),
            "::",
            stringify!(featureCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licenseInfo) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V4),
            "::",
            stringify!(licenseInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).productName) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V4),
            "::",
            stringify!(productName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licenseExpiry) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSE_FEATURE_DETAILS_V4),
            "::",
            stringify!(licenseExpiry)
        )
    );
}
impl _NV_LICENSE_FEATURE_DETAILS_V4 {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isFeatureEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isFeatureEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        isFeatureEnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isFeatureEnabled: u32 = unsafe { ::std::mem::transmute(isFeatureEnabled) };
            isFeatureEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSE_FEATURE_DETAILS_V4 = _NV_LICENSE_FEATURE_DETAILS_V4;
#[doc = "! Used in NV_LICENSABLE_FEATURES"]
pub type NV_LICENSE_FEATURE_DETAILS = NV_LICENSE_FEATURE_DETAILS_V1;
#[doc = "! Licensable features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSABLE_FEATURES_V1 {
    #[doc = "!< IN - Structure version."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< The number of licensable features."]
    pub licensableFeatureCount: NvU32,
    #[doc = "!< Dynamic signature required for Authentication of the components,\n!< signature length limited to NV_LICENSE_SIGNATURE_SIZE"]
    pub signature: [NvU8; 128usize],
    #[doc = "!< Array of licensable features"]
    pub licenseDetails: [NV_LICENSE_FEATURE_DETAILS_V1; 3usize],
}
#[test]
fn bindgen_test_layout__NV_LICENSABLE_FEATURES_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LICENSABLE_FEATURES_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSABLE_FEATURES_V1>(),
        560usize,
        concat!("Size of: ", stringify!(_NV_LICENSABLE_FEATURES_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSABLE_FEATURES_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSABLE_FEATURES_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licensableFeatureCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V1),
            "::",
            stringify!(licensableFeatureCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V1),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licenseDetails) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V1),
            "::",
            stringify!(licenseDetails)
        )
    );
}
impl _NV_LICENSABLE_FEATURES_V1 {
    #[inline]
    pub fn isLicenseSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLicenseSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isLicenseSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isLicenseSupported: u32 = unsafe { ::std::mem::transmute(isLicenseSupported) };
            isLicenseSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Licensable features"]
pub type NV_LICENSABLE_FEATURES_V1 = _NV_LICENSABLE_FEATURES_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSABLE_FEATURES_V2 {
    #[doc = "!< IN - Structure version."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< The number of licensable features."]
    pub licensableFeatureCount: NvU32,
    #[doc = "!< Dynamic signature required for Authentication of the components,\n!< signature length limited to NV_LICENSE_SIGNATURE_SIZE"]
    pub signature: [NvU8; 128usize],
    #[doc = "!< Array of licensable features"]
    pub licenseDetails: [NV_LICENSE_FEATURE_DETAILS_V2; 3usize],
}
#[test]
fn bindgen_test_layout__NV_LICENSABLE_FEATURES_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LICENSABLE_FEATURES_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSABLE_FEATURES_V2>(),
        944usize,
        concat!("Size of: ", stringify!(_NV_LICENSABLE_FEATURES_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSABLE_FEATURES_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSABLE_FEATURES_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licensableFeatureCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V2),
            "::",
            stringify!(licensableFeatureCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V2),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licenseDetails) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V2),
            "::",
            stringify!(licenseDetails)
        )
    );
}
impl _NV_LICENSABLE_FEATURES_V2 {
    #[inline]
    pub fn isLicenseSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLicenseSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isLicenseSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isLicenseSupported: u32 = unsafe { ::std::mem::transmute(isLicenseSupported) };
            isLicenseSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSABLE_FEATURES_V2 = _NV_LICENSABLE_FEATURES_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSABLE_FEATURES_V3 {
    #[doc = "!< IN - Structure version."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< The number of licensable features."]
    pub licensableFeatureCount: NvU32,
    #[doc = "!< Dynamic signature required for Authentication of the components,\n!< signature length limited to NV_LICENSE_SIGNATURE_SIZE"]
    pub signature: [NvU8; 128usize],
    #[doc = "!< Array of licensable features"]
    pub licenseDetails: [NV_LICENSE_FEATURE_DETAILS_V3; 3usize],
}
#[test]
fn bindgen_test_layout__NV_LICENSABLE_FEATURES_V3() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LICENSABLE_FEATURES_V3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSABLE_FEATURES_V3>(),
        944usize,
        concat!("Size of: ", stringify!(_NV_LICENSABLE_FEATURES_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSABLE_FEATURES_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSABLE_FEATURES_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licensableFeatureCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V3),
            "::",
            stringify!(licensableFeatureCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V3),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licenseDetails) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V3),
            "::",
            stringify!(licenseDetails)
        )
    );
}
impl _NV_LICENSABLE_FEATURES_V3 {
    #[inline]
    pub fn isLicenseSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLicenseSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isLicenseSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isLicenseSupported: u32 = unsafe { ::std::mem::transmute(isLicenseSupported) };
            isLicenseSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSABLE_FEATURES_V3 = _NV_LICENSABLE_FEATURES_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LICENSABLE_FEATURES_V4 {
    #[doc = "!< IN - Structure version."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< The number of licensable features."]
    pub licensableFeatureCount: NvU32,
    #[doc = "!< Dynamic signature required for Authentication of the components,\n!< signature length limited to NV_LICENSE_SIGNATURE_SIZE"]
    pub signature: [NvU8; 128usize],
    #[doc = "!< Array of licensable features"]
    pub licenseDetails: [NV_LICENSE_FEATURE_DETAILS_V4; 3usize],
}
#[test]
fn bindgen_test_layout__NV_LICENSABLE_FEATURES_V4() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LICENSABLE_FEATURES_V4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LICENSABLE_FEATURES_V4>(),
        992usize,
        concat!("Size of: ", stringify!(_NV_LICENSABLE_FEATURES_V4))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LICENSABLE_FEATURES_V4>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_LICENSABLE_FEATURES_V4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V4),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licensableFeatureCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V4),
            "::",
            stringify!(licensableFeatureCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V4),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).licenseDetails) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LICENSABLE_FEATURES_V4),
            "::",
            stringify!(licenseDetails)
        )
    );
}
impl _NV_LICENSABLE_FEATURES_V4 {
    #[inline]
    pub fn isLicenseSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLicenseSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isLicenseSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isLicenseSupported: u32 = unsafe { ::std::mem::transmute(isLicenseSupported) };
            isLicenseSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSABLE_FEATURES_V4 = _NV_LICENSABLE_FEATURES_V4;
pub type NV_LICENSABLE_FEATURES = NV_LICENSABLE_FEATURES_V4;
extern "C" {
    #[doc = "!   DESCRIPTION:   This function call identifies whether licenses are supported on this system and if\n!                  they are supported, returns the details of the features that can be licensed.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\param [in]  hPhysicalGpu                   GPU selection\n! \\param [in,out] pLicensableFeatures         Licensable features information.\n!\n! \\return This API can return any of the error codes enumerated in #NvAPI_Status.\n!         If there are return error codes with specific meaning for this API, they are listed below.\n!\n! \\ingroup gridlicense\n"]
    pub fn NvAPI_GPU_GetLicensableFeatures(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pLicensableFeatures: *mut NV_LICENSABLE_FEATURES,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_VR_READY_V1 {
    #[doc = "!< Structure Version."]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_GPU_VR_READY_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_VR_READY_V1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_VR_READY_V1>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_GPU_VR_READY_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_VR_READY_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GPU_VR_READY_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_VR_READY_V1),
            "::",
            stringify!(version)
        )
    );
}
impl _NV_GPU_VR_READY_V1 {
    #[inline]
    pub fn isVRReady(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isVRReady(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isVRReady: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isVRReady: u32 = unsafe { ::std::mem::transmute(isVRReady) };
            isVRReady as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GPU_VR_READY_V1 = _NV_GPU_VR_READY_V1;
pub type NV_GPU_VR_READY = NV_GPU_VR_READY_V1;
extern "C" {
    #[doc = "! DESCRIPTION: This API will return NVIDIA GPU VR Ready state.\n!\n! SUPPORTED OS:  Windows 10 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 465\n!\n! \\param [in,out] pGpuVrReadyData - This structure will be filled with required information.\n!\n! \\return  This API can return any of the error codes enumerated in\n!          #NvAPI_Status.  If there are return error codes with specific\n!          meaning for this API, they are listed below.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_GPU_GetVRReadyData(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pGpuVrReadyData: *mut NV_GPU_VR_READY,
    ) -> NvAPI_Status;
}
#[doc = "!< No Slowdown detected"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_NONE: _NVAPI_GPU_PERF_DECREASE = 0;
#[doc = "!< Thermal slowdown/shutdown/POR thermal protection"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_REASON_THERMAL_PROTECTION:
    _NVAPI_GPU_PERF_DECREASE = 1;
#[doc = "!< Power capping / pstate cap"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_REASON_POWER_CONTROL:
    _NVAPI_GPU_PERF_DECREASE = 2;
#[doc = "!< AC->BATT event"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_REASON_AC_BATT: _NVAPI_GPU_PERF_DECREASE =
    4;
#[doc = "!< API triggered slowdown"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_REASON_API_TRIGGERED:
    _NVAPI_GPU_PERF_DECREASE = 8;
#[doc = "!< Power connector missing"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_REASON_INSUFFICIENT_POWER:
    _NVAPI_GPU_PERF_DECREASE = 16;
#[doc = "!< Unknown reason"]
pub const _NVAPI_GPU_PERF_DECREASE_NV_GPU_PERF_DECREASE_REASON_UNKNOWN: _NVAPI_GPU_PERF_DECREASE =
    -2147483648;
#[doc = "! Used in NvAPI_GPU_GetPerfDecreaseInfo.\n! Bit masks for knowing the exact reason for performance decrease"]
pub type _NVAPI_GPU_PERF_DECREASE = ::std::os::raw::c_int;
#[doc = "! Used in NvAPI_GPU_GetPerfDecreaseInfo.\n! Bit masks for knowing the exact reason for performance decrease"]
pub use self::_NVAPI_GPU_PERF_DECREASE as NVAPI_GPU_PERF_DECREASE;
extern "C" {
    #[doc = "! DESCRIPTION:   This function retrieves - in NvU32 variable - reasons for the current performance decrease.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n! \\param [in]      hPhysicalGPU    (IN)    - GPU for which performance decrease is to be evaluated.\n! \\param [out]  pPerfDecrInfo    (OUT)    - Pointer to a NvU32 variable containing performance decrease info\n!\n! \\return      This API can return any of the error codes enumerated in #NvAPI_Status.\n!\n! \\ingroup gpuPerf\n"]
    pub fn NvAPI_GPU_GetPerfDecreaseInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pPerfDecrInfo: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpupstate\n! Used in NvAPI_GPU_GetPstatesInfoEx()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V1 {
    pub version: NvU32,
    #[doc = "!< - bit 0 indicates if perfmon is enabled or not\n!< - bit 1 indicates if dynamic Pstate is capable or not\n!< - bit 2 indicates if dynamic Pstate is enable or not\n!< - all other bits must be set to 0"]
    pub flags: NvU32,
    #[doc = "!< The number of available p-states"]
    pub numPstates: NvU32,
    #[doc = "!< The number of clock domains supported by each P-State"]
    pub numClocks: NvU32,
    pub pstates: [NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1 {
    #[doc = "!< ID of the p-state."]
    pub pstateId: NV_GPU_PERF_PSTATE_ID,
    #[doc = "!< - bit 0 indicates if the PCIE limit is GEN1 or GEN2\n!< - bit 1 indicates if the Pstate is overclocked or not\n!< - bit 2 indicates if the Pstate is overclockable or not\n!< - all other bits must be set to 0"]
    pub flags: NvU32,
    pub clocks: [NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "!< ID of the clock domain"]
    pub domainId: NV_GPU_PUBLIC_CLOCK_ID,
    #[doc = "!< Reserved. Must be set to 0"]
    pub flags: NvU32,
    #[doc = "!< Clock frequency in kHz"]
    pub freq: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domainId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(domainId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(freq)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1>(),
        392usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pstateId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(pstateId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clocks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(clocks)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PERF_PSTATES_INFO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V1>(),
        6288usize,
        concat!("Size of: ", stringify!(NV_GPU_PERF_PSTATES_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_PERF_PSTATES_INFO_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPstates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1),
            "::",
            stringify!(numPstates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numClocks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1),
            "::",
            stringify!(numClocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pstates) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V1),
            "::",
            stringify!(pstates)
        )
    );
}
#[doc = "! \\ingroup gpupstate"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V2 {
    pub version: NvU32,
    #[doc = "!< - bit 0 indicates if perfmon is enabled or not\n!< - bit 1 indicates if dynamic Pstate is capable or not\n!< - bit 2 indicates if dynamic Pstate is enable or not\n!< - all other bits must be set to 0"]
    pub flags: NvU32,
    #[doc = "!< The number of available p-states"]
    pub numPstates: NvU32,
    #[doc = "!< The number of clock domains supported by each P-State"]
    pub numClocks: NvU32,
    pub numVoltages: NvU32,
    #[doc = "!< Valid index range is 0 to numVoltages-1"]
    pub pstates: [NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1 {
    #[doc = "!< ID of the p-state."]
    pub pstateId: NV_GPU_PERF_PSTATE_ID,
    #[doc = "!< - bit 0 indicates if the PCIE limit is GEN1 or GEN2\n!< - bit 1 indicates if the Pstate is overclocked or not\n!< - bit 2 indicates if the Pstate is overclockable or not\n!< - all other bits must be set to 0"]
    pub flags: NvU32,
    pub clocks: [NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1; 32usize],
    pub voltages: [NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1 {
    pub domainId: NV_GPU_PUBLIC_CLOCK_ID,
    #[doc = "!< bit 0 indicates if this clock is overclockable\n!< all other bits must be set to 0"]
    pub flags: NvU32,
    pub freq: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domainId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(domainId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(freq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "!< ID of the voltage domain, containing flags and mvolt info"]
    pub domainId: NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID,
    #[doc = "!< Reserved for future use. Must be set to 0"]
    pub flags: NvU32,
    #[doc = "!< Voltage in mV"]
    pub mvolt: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domainId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(domainId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mvolt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mvolt)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1>(),
        584usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pstateId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1),
            "::",
            stringify!(pstateId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clocks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1),
            "::",
            stringify!(clocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voltages) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1),
            "::",
            stringify!(voltages)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_GPU_PERF_PSTATES_INFO_V2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_PERF_PSTATES_INFO_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_PERF_PSTATES_INFO_V2>(),
        9364usize,
        concat!("Size of: ", stringify!(NV_GPU_PERF_PSTATES_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_PERF_PSTATES_INFO_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_PERF_PSTATES_INFO_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPstates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2),
            "::",
            stringify!(numPstates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numClocks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2),
            "::",
            stringify!(numClocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numVoltages) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2),
            "::",
            stringify!(numVoltages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pstates) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_PERF_PSTATES_INFO_V2),
            "::",
            stringify!(pstates)
        )
    );
}
#[doc = "! \\ingroup gpupstate"]
pub type NV_GPU_PERF_PSTATES_INFO = NV_GPU_PERF_PSTATES_INFO_V2;
extern "C" {
    #[doc = "! DESCRIPTION:     This API retrieves all performance states (P-States) information. This is the same as\n!                  NvAPI_GPU_GetPstatesInfo(), but supports an input flag for various options.\n!\n!                  P-States are GPU active/executing performance capability and power consumption states.\n!\n!                  P-States ranges from P0 to P15, with P0 being the highest performance/power state, and\n!                  P15 being the lowest performance/power state. Each P-State, if available, maps to a\n!                  performance level. Not all P-States are available on a given system. The definitions\n!                  of each P-State are currently as follows: \\n\n!                  - P0/P1 - Maximum 3D performance\n!                  - P2/P3 - Balanced 3D performance-power\n!                  - P8 - Basic HD video playback\n!                  - P10 - DVD playback\n!                  - P12 - Minimum idle power consumption\n!\n! \\deprecated  Do not use this function - it is deprecated in release 304. Instead, use NvAPI_GPU_GetPstates20.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]     hPhysicalGPU       GPU selection.\n! \\param [out]    pPerfPstatesInfo   P-States information retrieved, as detailed below: \\n\n!                  - flags is reserved for future use.\n!                  - numPstates is the number of available P-States\n!                  - numClocks is the number of clock domains supported by each P-State\n!                  - pstates has valid index range from 0 to numPstates - 1\n!                  - pstates[i].pstateId is the ID of the P-State,\n!                      containing the following info:\n!                    - pstates[i].flags containing the following info:\n!                        - bit 0 indicates if the PCIE limit is GEN1 or GEN2\n!                        - bit 1 indicates if the Pstate is overclocked or not\n!                        - bit 2 indicates if the Pstate is overclockable or not\n!                    - pstates[i].clocks has valid index range from 0 to numClocks -1\n!                    - pstates[i].clocks[j].domainId is the public ID of the clock domain,\n!                        containing the following info:\n!                      - pstates[i].clocks[j].flags containing the following info:\n!                          bit 0 indicates if the clock domain is overclockable or not\n!                      - pstates[i].clocks[j].freq is the clock frequency in kHz\n!                    - pstates[i].voltages has a valid index range from 0 to numVoltages - 1\n!                    - pstates[i].voltages[j].domainId is the ID of the voltage domain,\n!                        containing the following info:\n!                      - pstates[i].voltages[j].flags is reserved for future use.\n!                      - pstates[i].voltages[j].mvolt is the voltage in mV\n!                  inputFlags(IN)   - This can be used to select various options:\n!                    - if bit 0 is set, pPerfPstatesInfo would contain the default settings\n!                        instead of the current, possibily overclocked settings.\n!                    - if bit 1 is set, pPerfPstatesInfo would contain the maximum clock\n!                        frequencies instead of the nominal frequencies.\n!                    - if bit 2 is set, pPerfPstatesInfo would contain the minimum clock\n!                        frequencies instead of the nominal frequencies.\n!                    - all other bits must be set to 0.\n!\n! \\retval ::NVAPI_OK                            Completed request\n! \\retval ::NVAPI_ERROR                         Miscellaneous error occurred\n! \\retval ::NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide)\n! \\retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle\n! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the NV_GPU_PERF_PSTATES struct is not supported\n!\n! \\ingroup gpupstate\n"]
    pub fn NvAPI_GPU_GetPstatesInfoEx(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pPerfPstatesInfo: *mut NV_GPU_PERF_PSTATES_INFO,
        inputFlags: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This API retrieves all performance states (P-States) 2.0 information.\n!\n!                 P-States are GPU active/executing performance capability states.\n!                 They range from P0 to P15, with P0 being the highest performance state,\n!                 and P15 being the lowest performance state. Each P-State, if available,\n!                 maps to a performance level. Not all P-States are available on a given system.\n!                 The definition of each P-States are currently as follow:\n!                 - P0/P1 - Maximum 3D performance\n!                 - P2/P3 - Balanced 3D performance-power\n!                 - P8 - Basic HD video playback\n!                 - P10 - DVD playback\n!                 - P12 - Minimum idle power consumption\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 295\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]   hPhysicalGPU  GPU selection\n! \\param [out]  pPstatesInfo  P-States information retrieved, as documented in declaration above\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API,\n!          they are listed below.\n!\n! \\ingroup gpupstate\n"]
    pub fn NvAPI_GPU_GetPstates20(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pPstatesInfo: *mut NV_GPU_PERF_PSTATES20_INFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This function retrieves the current performance state (P-State).\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 165\n!\n! TCC_SUPPORTED\n!\n! \\param [in]      hPhysicalGPU     GPU selection\n! \\param [out]     pCurrentPstate   The ID of the current P-State of the GPU - see \\ref NV_GPU_PERF_PSTATES.\n!\n! \\retval    NVAPI_OK                             Completed request\n! \\retval    NVAPI_ERROR                          Miscellaneous error occurred.\n! \\retval    NVAPI_HANDLE_INVALIDATED             Handle passed has been invalidated (see user guide).\n! \\retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.\n! \\retval    NVAPI_NOT_SUPPORTED                  P-States is not supported on this setup.\n!\n! \\ingroup   gpupstate\n"]
    pub fn NvAPI_GPU_GetCurrentPstate(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pCurrentPstate: *mut NV_GPU_PERF_PSTATE_ID,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpupstate\n! Used in NvAPI_GPU_GetDynamicPstatesInfoEx()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_DYNAMIC_PSTATES_INFO_EX {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< bit 0 indicates if the dynamic Pstate is enabled or not"]
    pub flags: NvU32,
    pub utilization: [NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "!< Percentage of time where the domain is considered busy in the last 1 second interval"]
    pub percentage: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).percentage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1),
            "::",
            stringify!(percentage)
        )
    );
}
impl NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1 {
    #[inline]
    pub fn bIsPresent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsPresent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bIsPresent: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsPresent: u32 = unsafe { ::std::mem::transmute(bIsPresent) };
            bIsPresent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_DYNAMIC_PSTATES_INFO_EX() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_DYNAMIC_PSTATES_INFO_EX> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_DYNAMIC_PSTATES_INFO_EX>(),
        72usize,
        concat!("Size of: ", stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_DYNAMIC_PSTATES_INFO_EX>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utilization) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_DYNAMIC_PSTATES_INFO_EX),
            "::",
            stringify!(utilization)
        )
    );
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API retrieves the NV_GPU_DYNAMIC_PSTATES_INFO_EX structure for the specified physical GPU.\n!                Each domain's info is indexed in the array.  For example:\n!                - pDynamicPstatesInfo->utilization[NVAPI_GPU_UTILIZATION_DOMAIN_GPU] holds the info for the GPU domain. \\p\n!                There are currently 4 domains for which GPU utilization and dynamic P-State thresholds can be retrieved:\n!                   graphic engine (GPU), frame buffer (FB), video engine (VID), and bus interface (BUS).\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n!\n! TCC_SUPPORTED\n! \\since Release: 185\n!\n! \\retval ::NVAPI_OK\n! \\retval ::NVAPI_ERROR\n! \\retval ::NVAPI_INVALID_ARGUMENT  pDynamicPstatesInfo is NULL\n! \\retval ::NVAPI_HANDLE_INVALIDATED\n! \\retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE\n! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the INFO struct is not supported\n!\n! \\ingroup gpupstate\n"]
    pub fn NvAPI_GPU_GetDynamicPstatesInfoEx(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pDynamicPstatesInfoEx: *mut NV_GPU_DYNAMIC_PSTATES_INFO_EX,
    ) -> NvAPI_Status;
}
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_NONE: NV_THERMAL_TARGET = 0;
#[doc = "!< GPU core temperature requires NvPhysicalGpuHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_GPU: NV_THERMAL_TARGET = 1;
#[doc = "!< GPU memory temperature requires NvPhysicalGpuHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_MEMORY: NV_THERMAL_TARGET = 2;
#[doc = "!< GPU power supply temperature requires NvPhysicalGpuHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_POWER_SUPPLY: NV_THERMAL_TARGET = 4;
#[doc = "!< GPU board ambient temperature requires NvPhysicalGpuHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_BOARD: NV_THERMAL_TARGET = 8;
#[doc = "!< Visual Computing Device Board temperature requires NvVisualComputingDeviceHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_VCD_BOARD: NV_THERMAL_TARGET = 9;
#[doc = "!< Visual Computing Device Inlet temperature requires NvVisualComputingDeviceHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_VCD_INLET: NV_THERMAL_TARGET = 10;
#[doc = "!< Visual Computing Device Outlet temperature requires NvVisualComputingDeviceHandle"]
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_VCD_OUTLET: NV_THERMAL_TARGET = 11;
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_ALL: NV_THERMAL_TARGET = 15;
pub const NV_THERMAL_TARGET_NVAPI_THERMAL_TARGET_UNKNOWN: NV_THERMAL_TARGET = -1;
#[doc = "! \\ingroup gputhermal\n! Used in NV_GPU_THERMAL_SETTINGS"]
pub type NV_THERMAL_TARGET = ::std::os::raw::c_int;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_NONE: NV_THERMAL_CONTROLLER = 0;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_GPU_INTERNAL: NV_THERMAL_CONTROLLER = 1;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_ADM1032: NV_THERMAL_CONTROLLER = 2;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_MAX6649: NV_THERMAL_CONTROLLER = 3;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_MAX1617: NV_THERMAL_CONTROLLER = 4;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_LM99: NV_THERMAL_CONTROLLER = 5;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_LM89: NV_THERMAL_CONTROLLER = 6;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_LM64: NV_THERMAL_CONTROLLER = 7;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_ADT7473: NV_THERMAL_CONTROLLER = 8;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_SBMAX6649: NV_THERMAL_CONTROLLER = 9;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_VBIOSEVT: NV_THERMAL_CONTROLLER = 10;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_OS: NV_THERMAL_CONTROLLER = 11;
pub const NV_THERMAL_CONTROLLER_NVAPI_THERMAL_CONTROLLER_UNKNOWN: NV_THERMAL_CONTROLLER = -1;
#[doc = "! \\ingroup gputhermal\n! Used in NV_GPU_THERMAL_SETTINGS"]
pub type NV_THERMAL_CONTROLLER = ::std::os::raw::c_int;
#[doc = "! \\ingroup gputhermal\n! Used in NvAPI_GPU_GetThermalSettings()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_THERMAL_SETTINGS_V1 {
    #[doc = "!< structure version"]
    pub version: NvU32,
    #[doc = "!< number of associated thermal sensors"]
    pub count: NvU32,
    pub sensor: [NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1 {
    #[doc = "!< internal, ADM1032, MAX6649..."]
    pub controller: NV_THERMAL_CONTROLLER,
    #[doc = "!< The min default temperature value of the thermal sensor in degree Celsius"]
    pub defaultMinTemp: NvU32,
    #[doc = "!< The max default temperature value of the thermal sensor in degree Celsius"]
    pub defaultMaxTemp: NvU32,
    #[doc = "!< The current temperature value of the thermal sensor in degree Celsius"]
    pub currentTemp: NvU32,
    #[doc = "!< Thermal sensor targeted @ GPU, memory, chipset, powersupply, Visual Computing Device, etc."]
    pub target: NV_THERMAL_TARGET,
}
#[test]
fn bindgen_test_layout_NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).controller) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1),
            "::",
            stringify!(controller)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultMinTemp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1),
            "::",
            stringify!(defaultMinTemp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultMaxTemp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1),
            "::",
            stringify!(defaultMaxTemp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentTemp) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1),
            "::",
            stringify!(currentTemp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1),
            "::",
            stringify!(target)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_GPU_THERMAL_SETTINGS_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_THERMAL_SETTINGS_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_THERMAL_SETTINGS_V1>(),
        68usize,
        concat!("Size of: ", stringify!(NV_GPU_THERMAL_SETTINGS_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_THERMAL_SETTINGS_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_THERMAL_SETTINGS_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V1),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V1),
            "::",
            stringify!(sensor)
        )
    );
}
#[doc = "! \\ingroup gputhermal"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_THERMAL_SETTINGS_V2 {
    #[doc = "!< structure version"]
    pub version: NvU32,
    #[doc = "!< number of associated thermal sensors"]
    pub count: NvU32,
    pub sensor: [NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1 {
    #[doc = "!< internal, ADM1032, MAX6649..."]
    pub controller: NV_THERMAL_CONTROLLER,
    #[doc = "!< Minimum default temperature value of the thermal sensor in degree Celsius"]
    pub defaultMinTemp: NvS32,
    #[doc = "!< Maximum default temperature value of the thermal sensor in degree Celsius"]
    pub defaultMaxTemp: NvS32,
    #[doc = "!< Current temperature value of the thermal sensor in degree Celsius"]
    pub currentTemp: NvS32,
    #[doc = "!< Thermal sensor targeted - GPU, memory, chipset, powersupply, Visual Computing Device, etc"]
    pub target: NV_THERMAL_TARGET,
}
#[test]
fn bindgen_test_layout_NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).controller) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1),
            "::",
            stringify!(controller)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultMinTemp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1),
            "::",
            stringify!(defaultMinTemp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultMaxTemp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1),
            "::",
            stringify!(defaultMaxTemp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentTemp) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1),
            "::",
            stringify!(currentTemp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1),
            "::",
            stringify!(target)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_GPU_THERMAL_SETTINGS_V2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_THERMAL_SETTINGS_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_THERMAL_SETTINGS_V2>(),
        68usize,
        concat!("Size of: ", stringify!(NV_GPU_THERMAL_SETTINGS_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_THERMAL_SETTINGS_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_THERMAL_SETTINGS_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V2),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_THERMAL_SETTINGS_V2),
            "::",
            stringify!(sensor)
        )
    );
}
#[doc = "! \\ingroup gputhermal"]
pub type NV_GPU_THERMAL_SETTINGS = NV_GPU_THERMAL_SETTINGS_V2;
extern "C" {
    #[doc = "!  This function retrieves the thermal information of all thermal sensors or specific thermal sensor associated with the selected GPU.\n!  Thermal sensors are indexed 0 to NVAPI_MAX_THERMAL_SENSORS_PER_GPU-1.\n!\n!  - To retrieve specific thermal sensor info, set the sensorIndex to the required thermal sensor index.\n!  - To retrieve info for all sensors, set sensorIndex to NVAPI_THERMAL_TARGET_ALL.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 85\n!\n! \\param [in]   hPhysicalGPU      GPU selection.\n! \\param [in]   sensorIndex       Explicit thermal sensor index selection.\n! \\param [out]  pThermalSettings  Array of thermal settings.\n!\n! \\retval   NVAPI_OK                           Completed request\n! \\retval   NVAPI_ERROR                        Miscellaneous error occurred.\n! \\retval   NVAPI_INVALID_ARGUMENT             pThermalInfo is NULL.\n! \\retval   NVAPI_HANDLE_INVALIDATED           Handle passed has been invalidated (see user guide).\n! \\retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE Handle passed is not a physical GPU handle.\n! \\retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the INFO struct is not supported.\n! \\ingroup gputhermal\n"]
    pub fn NvAPI_GPU_GetThermalSettings(
        hPhysicalGpu: NvPhysicalGpuHandle,
        sensorIndex: NvU32,
        pThermalSettings: *mut NV_GPU_THERMAL_SETTINGS,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpuclock\n! Used in NvAPI_GPU_GetAllClockFrequencies()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_CLOCK_FREQUENCIES_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< These bits are reserved for future use."]
    pub reserved: NvU32,
    pub domain: [NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Clock frequency (kHz)"]
    pub frequency: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1),
            "::",
            stringify!(frequency)
        )
    );
}
impl NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1 {
    #[inline]
    pub fn bIsPresent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsPresent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsPresent: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsPresent: u32 = unsafe { ::std::mem::transmute(bIsPresent) };
            bIsPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_CLOCK_FREQUENCIES_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_CLOCK_FREQUENCIES_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLOCK_FREQUENCIES_V1>(),
        264usize,
        concat!("Size of: ", stringify!(NV_GPU_CLOCK_FREQUENCIES_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLOCK_FREQUENCIES_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_CLOCK_FREQUENCIES_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V1),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V1),
            "::",
            stringify!(domain)
        )
    );
}
pub const NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NV_GPU_CLOCK_FREQUENCIES_CURRENT_FREQ:
    NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE = 0;
pub const NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NV_GPU_CLOCK_FREQUENCIES_BASE_CLOCK:
    NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE = 1;
pub const NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NV_GPU_CLOCK_FREQUENCIES_BOOST_CLOCK:
    NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE = 2;
pub const NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NUM:
    NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE = 3;
#[doc = "! \\ingroup gpuclock\n! Used in NvAPI_GPU_GetAllClockFrequencies()"]
pub type NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpuclock\n! Used in NvAPI_GPU_GetAllClockFrequencies()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_CLOCK_FREQUENCIES_V2 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub domain: [NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Clock frequency (kHz)"]
    pub frequency: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1),
            "::",
            stringify!(frequency)
        )
    );
}
impl NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1 {
    #[inline]
    pub fn bIsPresent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsPresent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsPresent: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsPresent: u32 = unsafe { ::std::mem::transmute(bIsPresent) };
            bIsPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_GPU_CLOCK_FREQUENCIES_V2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_CLOCK_FREQUENCIES_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLOCK_FREQUENCIES_V2>(),
        264usize,
        concat!("Size of: ", stringify!(NV_GPU_CLOCK_FREQUENCIES_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLOCK_FREQUENCIES_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_GPU_CLOCK_FREQUENCIES_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLOCK_FREQUENCIES_V2),
            "::",
            stringify!(domain)
        )
    );
}
impl NV_GPU_CLOCK_FREQUENCIES_V2 {
    #[inline]
    pub fn ClockType(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ClockType(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ClockType: NvU32,
        reserved: NvU32,
        reserved1: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ClockType: u32 = unsafe { ::std::mem::transmute(ClockType) };
            ClockType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup gpuclock\n! Used in NvAPI_GPU_GetAllClockFrequencies()"]
pub type NV_GPU_CLOCK_FREQUENCIES = NV_GPU_CLOCK_FREQUENCIES_V2;
extern "C" {
    #[doc = "!   This function retrieves the NV_GPU_CLOCK_FREQUENCIES structure for the specified physical GPU.\n!\n!   For each clock domain:\n!      - bIsPresent is set for each domain that is present on the GPU\n!      - frequency is the domain's clock freq in kHz\n!\n!   Each domain's info is indexed in the array.  For example:\n!   clkFreqs.domain[NVAPI_GPU_PUBLIC_CLOCK_MEMORY] holds the info for the MEMORY domain.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 295\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API,\n!          they are listed below.\n! \\retval  NVAPI_INVALID_ARGUMENT     pClkFreqs is NULL.\n! \\ingroup gpuclock\n"]
    pub fn NvAPI_GPU_GetAllClockFrequencies(
        hPhysicalGPU: NvPhysicalGpuHandle,
        pClkFreqs: *mut NV_GPU_CLOCK_FREQUENCIES,
    ) -> NvAPI_Status;
}
pub const _NV_GPU_ILLUMINATION_ATTRIB_NV_GPU_IA_LOGO_BRIGHTNESS: _NV_GPU_ILLUMINATION_ATTRIB = 0;
pub const _NV_GPU_ILLUMINATION_ATTRIB_NV_GPU_IA_SLI_BRIGHTNESS: _NV_GPU_ILLUMINATION_ATTRIB = 1;
#[doc = "! \\ingroup gpu"]
pub type _NV_GPU_ILLUMINATION_ATTRIB = ::std::os::raw::c_int;
#[doc = "! \\ingroup gpu"]
pub use self::_NV_GPU_ILLUMINATION_ATTRIB as NV_GPU_ILLUMINATION_ATTRIB;
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< The handle of the GPU that you are checking for the specified attribute.\n!< note that this is the GPU that is managing the attribute.\n!< Only a single GPU can manage an given attribute on a given HW element,\n!< regardless of how many are attatched.\n!< I.E. only one GPU will be used to control the brightness of the LED on an SLI bridge,\n!< regardless of how many are physicaly attached.\n!< You enumerate thru the GPUs with this call to determine which GPU is managing the attribute."]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< An enumeration value specifying the Illumination attribute to be querried.\n!<     refer to enum \\ref NV_GPU_ILLUMINATION_ATTRIB."]
    pub Attribute: NV_GPU_ILLUMINATION_ATTRIB,
    #[doc = "!< A boolean indicating if the attribute is supported."]
    pub bSupported: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1),
            "::",
            stringify!(hPhysicalGpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attribute) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1),
            "::",
            stringify!(Attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSupported) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1),
            "::",
            stringify!(bSupported)
        )
    );
}
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1 = _NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1;
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM = NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_QueryIlluminationSupport(
        pIlluminationSupportInfo: *mut NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_GET_ILLUMINATION_PARM_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< The handle of the GPU that you are checking for the specified attribute.\n!< Note that this is the GPU that is managing the attribute.\n!< Only a single GPU can manage an given attribute on a given HW element,\n!< regardless of how many are attatched.\n!< I.E. only one GPU will be used to control the brightness of the LED on an SLI bridge,\n!< regardless of how many are physicaly attached.\n!< You enumerate thru the GPUs with this call to determine which GPU is managing the attribute."]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< An enumeration value specifying the Illumination attribute to be querried.\n!< refer to enum \\ref NV_GPU_ILLUMINATION_ATTRIB."]
    pub Attribute: NV_GPU_ILLUMINATION_ATTRIB,
    #[doc = "!< A DWORD that will contain the current value of the specified attribute."]
    pub Value: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GPU_GET_ILLUMINATION_PARM_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_GET_ILLUMINATION_PARM_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_GET_ILLUMINATION_PARM_V1>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_GPU_GET_ILLUMINATION_PARM_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_GET_ILLUMINATION_PARM_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_GET_ILLUMINATION_PARM_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_GET_ILLUMINATION_PARM_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_GET_ILLUMINATION_PARM_V1),
            "::",
            stringify!(hPhysicalGpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attribute) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_GET_ILLUMINATION_PARM_V1),
            "::",
            stringify!(Attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_GET_ILLUMINATION_PARM_V1),
            "::",
            stringify!(Value)
        )
    );
}
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_GET_ILLUMINATION_PARM_V1 = _NV_GPU_GET_ILLUMINATION_PARM_V1;
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_GET_ILLUMINATION_PARM = NV_GPU_GET_ILLUMINATION_PARM_V1;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_GetIllumination(
        pIlluminationInfo: *mut NV_GPU_GET_ILLUMINATION_PARM,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup gpu"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_SET_ILLUMINATION_PARM_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< The handle of the GPU that you are checking for the specified attribute.\n!< Note that this is the GPU that is managing the attribute.\n!< Only a single GPU can manage an given attribute on a given HW element,\n!< regardless of how many are attatched.\n!< I.E. only one GPU will be used to control the brightness of the LED on an SLI bridge,\n!< regardless of how many are physicaly attached.\n!< You enumerate thru the GPUs with this call to determine which GPU is managing the attribute."]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< An enumeration value specifying the Illumination attribute to be querried.\n!< refer to enum \\ref NV_GPU_ILLUMINATION_ATTRIB."]
    pub Attribute: NV_GPU_ILLUMINATION_ATTRIB,
    #[doc = "!< A DWORD containing the new value for the specified attribute.\n!< This should be specified as a percentage of the full range of the attribute\n!< (0-100; 0 = off, 100 = full brightness)\n!< If a value is specified outside this range, NVAPI_INVALID_ARGUMENT will be returned."]
    pub Value: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GPU_SET_ILLUMINATION_PARM_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_SET_ILLUMINATION_PARM_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_SET_ILLUMINATION_PARM_V1>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_GPU_SET_ILLUMINATION_PARM_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_SET_ILLUMINATION_PARM_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_SET_ILLUMINATION_PARM_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_SET_ILLUMINATION_PARM_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_SET_ILLUMINATION_PARM_V1),
            "::",
            stringify!(hPhysicalGpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attribute) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_SET_ILLUMINATION_PARM_V1),
            "::",
            stringify!(Attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_SET_ILLUMINATION_PARM_V1),
            "::",
            stringify!(Value)
        )
    );
}
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_SET_ILLUMINATION_PARM_V1 = _NV_GPU_SET_ILLUMINATION_PARM_V1;
#[doc = "! \\ingroup gpu"]
pub type NV_GPU_SET_ILLUMINATION_PARM = NV_GPU_SET_ILLUMINATION_PARM_V1;
extern "C" {
    #[doc = "! \\ingroup gpu"]
    pub fn NvAPI_GPU_SetIllumination(
        pIlluminationInfo: *mut NV_GPU_SET_ILLUMINATION_PARM,
    ) -> NvAPI_Status;
}
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB:
    NV_GPU_CLIENT_ILLUM_CTRL_MODE = 0;
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB:
    NV_GPU_CLIENT_ILLUM_CTRL_MODE = 1;
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL:
    NV_GPU_CLIENT_ILLUM_CTRL_MODE = 0;
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR:
    NV_GPU_CLIENT_ILLUM_CTRL_MODE = 1;
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_NV_GPU_CLIENT_ILLUM_CTRL_MODE_INVALID:
    NV_GPU_CLIENT_ILLUM_CTRL_MODE = 255;
#[doc = " Enumeration of control modes that can be applied to Illumination Zones."]
pub type NV_GPU_CLIENT_ILLUM_CTRL_MODE = ::std::os::raw::c_int;
pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_GPU_TOP_0:
    NV_GPU_CLIENT_ILLUM_ZONE_LOCATION = 0;
pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_GPU_FRONT_0:
    NV_GPU_CLIENT_ILLUM_ZONE_LOCATION = 8;
pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_GPU_BACK_0:
    NV_GPU_CLIENT_ILLUM_ZONE_LOCATION = 12;
pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_SLI_TOP_0:
    NV_GPU_CLIENT_ILLUM_ZONE_LOCATION = 32;
pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_INVALID:
    NV_GPU_CLIENT_ILLUM_ZONE_LOCATION = -1;
#[doc = " Enumeration of locations where an Illumination Zone might be present.\n Encoding used -\n   1:0 - Number specifier (0)\n   4:2 - Location (TOP)\n   7:5 - Type (GPU/SLI)"]
pub type NV_GPU_CLIENT_ILLUM_ZONE_LOCATION = ::std::os::raw::c_int;
pub const NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_INVALID:
    NV_GPU_CLIENT_ILLUM_DEVICE_TYPE = 0;
pub const NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_MCUV10:
    NV_GPU_CLIENT_ILLUM_DEVICE_TYPE = 1;
pub const NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_GPIO_PWM_RGBW_V10:
    NV_GPU_CLIENT_ILLUM_DEVICE_TYPE = 2;
pub const NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_GPIO_PWM_SINGLE_COLOR_V10 : NV_GPU_CLIENT_ILLUM_DEVICE_TYPE = 3 ;
#[doc = " Enumeration of ILLUM_DEVICEs."]
pub type NV_GPU_CLIENT_ILLUM_DEVICE_TYPE = ::std::os::raw::c_int;
pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_NV_GPU_CLIENT_ILLUM_ZONE_TYPE_INVALID:
    NV_GPU_CLIENT_ILLUM_ZONE_TYPE = 0;
pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGB:
    NV_GPU_CLIENT_ILLUM_ZONE_TYPE = 1;
pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_NV_GPU_CLIENT_ILLUM_ZONE_TYPE_COLOR_FIXED:
    NV_GPU_CLIENT_ILLUM_ZONE_TYPE = 2;
pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGBW:
    NV_GPU_CLIENT_ILLUM_ZONE_TYPE = 3;
pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_NV_GPU_CLIENT_ILLUM_ZONE_TYPE_SINGLE_COLOR:
    NV_GPU_CLIENT_ILLUM_ZONE_TYPE = 4;
#[doc = " Enumeration of ILLUM_ZONEs."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_TYPE = ::std::os::raw::c_int;
pub const NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE_NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_HALF_HALT : NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE = 0 ;
pub const NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE_NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_FULL_HALT : NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE = 1 ;
pub const NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE_NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_FULL_REPEAT : NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE = 2 ;
pub const NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE_NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_INVALID : NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE = 255 ;
#[doc = " Enumeration of Cycle types for piecewise linear control mode."]
pub type NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE = ::std::os::raw::c_int;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1\n Describes the static information of illumination device type MCUV10."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10 {
    #[doc = " I2C Device Index: Pointing to the illumination device in I2C Devices Table."]
    pub i2cDevIdx: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2cDevIdx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10),
            "::",
            stringify!(i2cDevIdx)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1\n Describes the static information of illumination device type MCUV10."]
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10 = _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1\n Describes the static information of illum device type GPIO_PWM_RGBW."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW {
    #[doc = " Red drive GPIO pin."]
    pub gpioPinRed: NvU8,
    #[doc = " Green drive GPIO pin."]
    pub gpioPinGreen: NvU8,
    #[doc = " Blue drive GPIO pin."]
    pub gpioPinBlue: NvU8,
    #[doc = " White drive GPIO pin."]
    pub gpioPinWhite: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpioPinRed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW),
            "::",
            stringify!(gpioPinRed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpioPinGreen) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW),
            "::",
            stringify!(gpioPinGreen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpioPinBlue) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW),
            "::",
            stringify!(gpioPinBlue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpioPinWhite) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW),
            "::",
            stringify!(gpioPinWhite)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1\n Describes the static information of illum device type GPIO_PWM_RGBW."]
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW =
    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1\n Describes the static information of illum device type GPIO_PWM_SINGLE_COLOR."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR {
    #[doc = " Single Color GPIO pin."]
    pub gpioPinSingleColor: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpioPinSingleColor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR),
            "::",
            stringify!(gpioPinSingleColor)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1\n Describes the static information of illum device type GPIO_PWM_SINGLE_COLOR."]
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1 {
    #[doc = " Type of the illumination device."]
    pub type_: NV_GPU_CLIENT_ILLUM_DEVICE_TYPE,
    #[doc = " Supported control modes for this illumination device."]
    pub ctrlModeMask: NvU32,
    pub data: _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[doc = " Union of illumination device info data. Interpreted as per\n @ref NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1::type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1 {
    pub mcuv10: NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10,
    pub gpioPwmRgbwv10: NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW,
    pub gpioPwmSingleColorv10: NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mcuv10) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(mcuv10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpioPwmRgbwv10) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(gpioPwmRgbwv10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpioPwmSingleColorv10) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(gpioPwmSingleColorv10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1>(),
        136usize,
        concat!("Size of: ", stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrlModeMask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1),
            "::",
            stringify!(ctrlModeMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1),
            "::",
            stringify!(rsvd)
        )
    );
}
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1 = _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1 {
    #[doc = " Version of structure. Must always be first member."]
    pub version: NvU32,
    #[doc = " Number of illumination devices present."]
    pub numIllumDevices: NvU32,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
    pub devices: [NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1; 32usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1>(),
        4424usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numIllumDevices) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1),
            "::",
            stringify!(numIllumDevices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1),
            "::",
            stringify!(rsvd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devices) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1),
            "::",
            stringify!(devices)
        )
    );
}
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1 = _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1;
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS = NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1;
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 400\n! \\param [in]  hPhysicalGpu       The physical GPU handle\n! \\param [out] pIllumDevicesInfo  Pointer to structure containing static\n!                                 information about illumination devices.\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API,\n!          they are listed below.\n"]
    pub fn NvAPI_GPU_ClientIllumDevicesGetInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pIllumDevicesInfo: *mut NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS,
    ) -> NvAPI_Status;
}
#[doc = " Structure representing the data required for synchronization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1 {
    #[doc = " Boolean representing the need for synchronization."]
    pub bSync: NvBool,
    #[doc = " Time stamp value required for synchronization."]
    pub timeStampms: NvU64,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout_NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1>(),
        80usize,
        concat!("Size of: ", stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSync) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1),
            "::",
            stringify!(bSync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStampms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1),
            "::",
            stringify!(timeStampms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Structure representing the device control parameters of each ILLUM_DEVICE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1 {
    #[doc = " Type of the illum device."]
    pub type_: NV_GPU_CLIENT_ILLUM_DEVICE_TYPE,
    #[doc = " Structure containing the synchronization data for the illumination device."]
    pub syncData: NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout_NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1>(),
        152usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1),
            "::",
            stringify!(syncData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Structure representing the device control parameters of each ILLUM_DEVICE."]
pub type NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL = NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1;
#[doc = " Structure representing the control parameters of ILLUM_DEVICE-s."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1 {
    #[doc = " Version of structure. Must always be first member."]
    pub version: NvU32,
    #[doc = " Number of illumination devices present."]
    pub numIllumDevices: NvU32,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
    pub devices: [NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1; 32usize],
}
#[test]
fn bindgen_test_layout_NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1>(),
        4936usize,
        concat!(
            "Size of: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numIllumDevices) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1),
            "::",
            stringify!(numIllumDevices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1),
            "::",
            stringify!(rsvd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devices) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1),
            "::",
            stringify!(devices)
        )
    );
}
#[doc = " Structure representing the control parameters of ILLUM_DEVICE-s."]
pub type NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS = NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1;
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 400\n! \\param [in]  hPhysicalGpu          The physical GPU handle\n! \\param [inout] pIllumDevicesControl  Pointer to structure containing control\n!                                 information about illum devices.\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API,\n!          they are listed below.\n"]
    pub fn NvAPI_GPU_ClientIllumDevicesGetControl(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pClientIllumDevicesControl: *mut NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 400\n! \\param [in]  hPhysicalGpu          The physical GPU handle\n! \\param [inout] pClientIllumDevicesControl  Pointer to structure containing control\n!                                 information about illum devices.\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API,\n!          they are listed below.\n"]
    pub fn NvAPI_GPU_ClientIllumDevicesSetControl(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pClientIllumDevicesControl: *mut NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB {
    pub rsvd: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB),
            "::",
            stringify!(rsvd)
        )
    );
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB = _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1\n Describes the static information of illum zone type RGBW."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW {
    pub rsvd: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1\n Describes the static information of illum zone type RGBW."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW = _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1\n Describes the static information of illum zone type SINGLE_COLOR."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR {
    pub rsvd: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1\n Describes the static information of illum zone type SINGLE_COLOR."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1 {
    pub type_: NV_GPU_CLIENT_ILLUM_ZONE_TYPE,
    #[doc = " Index pointing to an Illumination Device that controls this zone."]
    pub illumDeviceIdx: NvU8,
    #[doc = " Provider index for representing logical to physical zone mapping."]
    pub provIdx: NvU8,
    #[doc = " Location of the zone on the board."]
    pub zoneLocation: NV_GPU_CLIENT_ILLUM_ZONE_LOCATION,
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1,
    pub rsvd: [NvU8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1 {
    pub rgb: NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB,
    pub rgbw: NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW,
    pub singleColor: NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(rgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgbw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(rgbw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singleColor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(singleColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1>(),
        140usize,
        concat!("Size of: ", stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).illumDeviceIdx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1),
            "::",
            stringify!(illumDeviceIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).provIdx) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1),
            "::",
            stringify!(provIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zoneLocation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1),
            "::",
            stringify!(zoneLocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1),
            "::",
            stringify!(rsvd)
        )
    );
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1 = _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1 {
    #[doc = " Version of structure. Must always be first member."]
    pub version: NvU32,
    #[doc = " Number of illumination zones present."]
    pub numIllumZones: NvU32,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
    pub zones: [NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1; 32usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1>(),
        4552usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numIllumZones) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1),
            "::",
            stringify!(numIllumZones)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1),
            "::",
            stringify!(rsvd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zones) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1),
            "::",
            stringify!(zones)
        )
    );
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1 = _NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1;
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS = NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1;
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 400\n! \\param [in]  hPhysicalGpu     The physical GPU handle\n! \\param [out] pIllumZonesInfo  Pointer to structure containing static\n!                               information about illumination devices.\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API,\n!          they are listed below.\n"]
    pub fn NvAPI_GPU_ClientIllumZonesGetInfo(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pIllumZonesInfo: *mut NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS,
    ) -> NvAPI_Status;
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB\n Parameters required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS {
    #[doc = " Red compenent of color applied to the zone."]
    pub colorR: NvU8,
    #[doc = " Green compenent of color applied to the zone."]
    pub colorG: NvU8,
    #[doc = " Blue compenent of color applied to the zone."]
    pub colorB: NvU8,
    #[doc = " Brightness perecentage value of the zone."]
    pub brightnessPct: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS),
            "::",
            stringify!(colorR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorG) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS),
            "::",
            stringify!(colorG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorB) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS),
            "::",
            stringify!(colorB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).brightnessPct) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS),
            "::",
            stringify!(brightnessPct)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB\n Parameters required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB\n Data required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB {
    #[doc = " Parameters required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
    pub rgbParams: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgbParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB),
            "::",
            stringify!(rgbParams)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB\n Data required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB\n Data required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR {
    #[doc = " Type of cycle effect to apply."]
    pub cycleType: NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE,
    #[doc = " Number of times to repeat function within group period."]
    pub grpCount: NvU8,
    #[doc = " Time in ms to transition from color A to color B."]
    pub riseTimems: NvU16,
    #[doc = " Time in ms to transition from color B to color A."]
    pub fallTimems: NvU16,
    #[doc = " Time in ms to remain at color A before color A to color B transition."]
    pub ATimems: NvU16,
    #[doc = " Time in ms to remain at color B before color B to color A transition."]
    pub BTimems: NvU16,
    #[doc = " Time in ms to remain idle before next group of repeated function cycles."]
    pub grpIdleTimems: NvU16,
    #[doc = " Time in ms to offset the cycle relative to other zones."]
    pub phaseOffsetms: NvU16,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cycleType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
            "::",
            stringify!(cycleType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grpCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
            "::",
            stringify!(grpCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).riseTimems) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
            "::",
            stringify!(riseTimems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fallTimems) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
            "::",
            stringify!(fallTimems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ATimems) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
            "::",
            stringify!(ATimems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BTimems) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
            "::",
            stringify!(BTimems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grpIdleTimems) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
            "::",
            stringify!(grpIdleTimems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phaseOffsetms) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR),
            "::",
            stringify!(phaseOffsetms)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB\n Data required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB\n Data required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB {
    #[doc = " Parameters required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
    pub rgbParams: [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS; 2usize],
    pub piecewiseLinearData: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgbParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB),
            "::",
            stringify!(rgbParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piecewiseLinearData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB),
            "::",
            stringify!(piecewiseLinearData)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB\n Data required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1\n Describes the control data for illumination zone of type\n \\ref NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGB."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB {
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[doc = " Union of illumination zone control data for zone of type NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGB.\n Interpreted as per ctrlMode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1 {
    pub manualRGB: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB,
    pub piecewiseLinearRGB: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).manualRGB) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1),
            "::",
            stringify!(manualRGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piecewiseLinearRGB) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1),
            "::",
            stringify!(piecewiseLinearRGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1\n Describes the control data for illumination zone of type\n \\ref NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB = _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED\n Parameters required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_RGB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS {
    #[doc = " Brightness percentage value of the zone."]
    pub brightnessPct: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).brightnessPct) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS),
            "::",
            stringify!(brightnessPct)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED\n Parameters required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED\n Data required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED {
    #[doc = " Parameters required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
    pub colorFixedParams: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFixedParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED),
            "::",
            stringify!(colorFixedParams)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED\n Data required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED\n Data required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED {
    #[doc = " Parameters required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
    pub colorFixedParams: [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS; 2usize],
    pub piecewiseLinearData: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED>(
        ),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFixedParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED),
            "::",
            stringify!(colorFixedParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piecewiseLinearData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED),
            "::",
            stringify!(piecewiseLinearData)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED\n Data required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1\n Describes the control data for illum zone of type\n \\ref NV_GPU_CLIENT_ILLUM_ZONE_TYPE_COLOR_FIXED."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED {
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[doc = " Union of illum zone control data for zone of type NV_GPU_CLIENT_ILLUM_ZONE_TYPE_COLOR_FIXED.\n Interpreted as per ctrlMode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1 {
    pub manualColorFixed: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED,
    pub piecewiseLinearColorFixed:
        NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).manualColorFixed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1),
            "::",
            stringify!(manualColorFixed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piecewiseLinearColorFixed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1),
            "::",
            stringify!(piecewiseLinearColorFixed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1\n Describes the control data for illum zone of type\n \\ref NV_GPU_CLIENT_ILLUM_ZONE_TYPE_COLOR_FIXED."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED;
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW\n Parameters required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGBW."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS {
    #[doc = " Red component of color applied to the zone."]
    pub colorR: NvU8,
    #[doc = " Green component of color applied to the zone."]
    pub colorG: NvU8,
    #[doc = " Blue component of color applied to the zone."]
    pub colorB: NvU8,
    #[doc = " White component of color applied to the zone."]
    pub colorW: NvU8,
    #[doc = " Brightness percentage value of the zone."]
    pub brightnessPct: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS),
            "::",
            stringify!(colorR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorG) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS),
            "::",
            stringify!(colorG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorB) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS),
            "::",
            stringify!(colorB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorW) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS),
            "::",
            stringify!(colorW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).brightnessPct) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS),
            "::",
            stringify!(brightnessPct)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW\n Parameters required to represent control mode of type\n \\ref NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGBW."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGBW\n Data required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_RGBW."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW {
    #[doc = " Parameters required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_RGBW."]
    pub rgbwParams: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgbwParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW),
            "::",
            stringify!(rgbwParams)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGBW\n Data required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_RGBW."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGBW\n Data required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGBW."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW {
    #[doc = " Parameters required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGBW."]
    pub rgbwParams: [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS; 2usize],
    pub piecewiseLinearData: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgbwParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW),
            "::",
            stringify!(rgbwParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piecewiseLinearData) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW),
            "::",
            stringify!(piecewiseLinearData)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGBW\n Data required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGBW."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_V1\n Describes the control data for illum zone of type\n \\ref NV_GPU_ILLUM_ZONE_TYPE_RGBW."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW {
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[doc = " Union of illum zone control data for zone of type NV_GPU_ILLUM_ZONE_TYPE_RGBW.\n Interpreted as per ctrlMode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1 {
    pub manualRGBW: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW,
    pub piecewiseLinearRGBW: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).manualRGBW) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1),
            "::",
            stringify!(manualRGBW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piecewiseLinearRGBW) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1),
            "::",
            stringify!(piecewiseLinearRGBW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_V1\n Describes the control data for illum zone of type\n \\ref NV_GPU_ILLUM_ZONE_TYPE_RGBW."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW = _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR\n Parameters required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_SINGLE_COLOR."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS {
    #[doc = " Brightness percentage value of the zone."]
    pub brightnessPct: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).brightnessPct) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS),
            "::",
            stringify!(brightnessPct)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR\n Parameters required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_SINGLE_COLOR."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR\n Data required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_SINGLE_COLOR."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR {
    #[doc = " Parameters required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_SINGLE_COLOR."]
    pub singleColorParams: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singleColorParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR),
            "::",
            stringify!(singleColorParams)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR\n Data required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_MANUAL_SINGLE_COLOR."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR\n Data required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_SINGLE_COLOR."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR {
    #[doc = " Parameters required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_SINGLE_COLOR."]
    pub singleColorParams:
        [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS; 2usize],
    pub piecewiseLinearData: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR>(
        ),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singleColorParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR),
            "::",
            stringify!(singleColorParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piecewiseLinearData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR),
            "::",
            stringify!(piecewiseLinearData)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR\n Data required to represent control mode of type\n \\ref NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_SINGLE_COLOR."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR;
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_V1\n Describes the control data for illum zone of type\n \\ref NV_GPU_ILLUM_ZONE_TYPE_SINGLE_COLOR."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR {
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1,
    #[doc = " Reserved for future."]
    pub rsvd: [NvU8; 64usize],
}
#[doc = " Union of illum zone control data for zone of type NV_GPU_ILLUM_ZONE_TYPE_SINGLE_COLOR.\n Interpreted as per ctrlMode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1 {
    pub manualSingleColor: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR,
    pub piecewiseLinearSingleColor:
        NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).manualSingleColor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1),
            "::",
            stringify!(manualSingleColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piecewiseLinearSingleColor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1),
            "::",
            stringify!(piecewiseLinearSingleColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Used in \\ref NV_GPU_ILLUM_ZONE_CONTROL_V1\n Describes the control data for illum zone of type\n \\ref NV_GPU_ILLUM_ZONE_TYPE_SINGLE_COLOR."]
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1 {
    pub type_: NV_GPU_CLIENT_ILLUM_ZONE_TYPE,
    pub ctrlMode: NV_GPU_CLIENT_ILLUM_CTRL_MODE,
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1,
    pub rsvd: [NvU8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1 {
    pub rgb: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB,
    pub colorFixed: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED,
    pub rgbw: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW,
    pub singleColor: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR,
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1),
            "::",
            stringify!(rgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFixed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1),
            "::",
            stringify!(colorFixed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgbw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1),
            "::",
            stringify!(rgbw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singleColor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1),
            "::",
            stringify!(singleColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1>(),
        200usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrlMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1),
            "::",
            stringify!(ctrlMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1),
            "::",
            stringify!(rsvd)
        )
    );
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1 = _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " Number of illumination zones present."]
    pub numIllumZonesControl: NvU32,
    #[doc = " Reserved bytes for possible future extension of this struct."]
    pub rsvd: [NvU8; 64usize],
    pub zones: [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1; 32usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1>(),
        6476usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numIllumZonesControl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1),
            "::",
            stringify!(numIllumZonesControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1),
            "::",
            stringify!(rsvd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zones) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1),
            "::",
            stringify!(zones)
        )
    );
}
impl _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1 {
    #[inline]
    pub fn bDefault(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDefault(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvdField(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_rsvdField(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bDefault: NvU32,
        rsvdField: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bDefault: u32 = unsafe { ::std::mem::transmute(bDefault) };
            bDefault as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let rsvdField: u32 = unsafe { ::std::mem::transmute(rsvdField) };
            rsvdField as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1 = _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1;
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS = NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1;
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 400\n! \\param [in]  hPhysicalGpu        The physical GPU handle\n! \\param [out] pIllumZonesControl  Pointer to structure containing control\n!                                  information about illumination zones.\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API,\n!          they are listed below.\n"]
    pub fn NvAPI_GPU_ClientIllumZonesGetControl(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pIllumZonesControl: *mut NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! TCC_SUPPORTED\n!\n! \\since Release: 400\n! \\param [in]  hPhysicalGpu        The physical GPU handle\n! \\param [out] pIllumZonesControl  Pointer to structure containing control\n!                                  information about illumination zones.\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API,\n!          they are listed below.\n"]
    pub fn NvAPI_GPU_ClientIllumZonesSetControl(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pIllumZonesControl: *mut NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API registers the process for events. This API should be called for each eventcallback.\n!                The handle returned to the client will be common across all eventCallbacks.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  eventCallback  Pointer to NV_EVENT_REGISTER_CALLBACK structure to call\n!                             on new events\n! \\param [out] phClient       Handle to client for use with\n!                             unregister function\n!\n! \\retval ::NVAPI_OK - completed request\n! \\retval ::NVAPI_API_NOT_INTIALIZED - NvAPI not initialized\n! \\retval ::NVAPI_INVALID_ARGUMENT - Invalid argument\n! \\retval ::NVAPI_ERROR - miscellaneous error occurred\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_Event_RegisterCallback(
        eventCallback: PNV_EVENT_REGISTER_CALLBACK,
        phClient: *mut NvEventHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API unregister an event handle.\n!                This API should be called only once per process(irrespective of the number of callbacks registered).\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]    hClient  Handle associated with this listeners\n!                         event queue. Same as returned from\n!                         NvAPI_Event_RegisterCallback().\n!\n! \\retval ::NVAPI_OK - completed request\n! \\retval ::NVAPI_API_NOT_INTIALIZED - NvAPI not initialized\n! \\retval ::NVAPI_INVALID_ARGUMENT - Invalid argument\n! \\retval ::NVAPI_ERROR - miscellaneous error occurred\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_Event_UnregisterCallback(hClient: NvEventHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns the handle of the NVIDIA display specified by the enum\n!                index (thisEnum). The client should keep enumerating until it\n!                returns error.\n!\n!                Note: Display handles can get invalidated on a modeset, so the calling applications need to\n!                renum the handles after every modeset.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\param [in]  thisEnum      The index of the NVIDIA display.\n! \\param [out] pNvDispHandle Pointer to the NVIDIA display handle.\n!\n! \\retval NVAPI_INVALID_ARGUMENT        Either the handle pointer is NULL or enum index too big\n! \\retval NVAPI_OK                      Return a valid NvDisplayHandle based on the enum index\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND No NVIDIA device found in the system\n! \\retval NVAPI_END_ENUMERATION         No more display device to enumerate\n! \\ingroup disphandle\n"]
    pub fn NvAPI_EnumNvidiaDisplayHandle(
        thisEnum: NvU32,
        pNvDispHandle: *mut NvDisplayHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function returns the handle of the NVIDIA unattached display specified by the enum\n!                index (thisEnum). The client should keep enumerating until it\n!                returns error.\n!                Note: Display handles can get invalidated on a modeset, so the calling applications need to\n!                renum the handles after every modeset.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\param [in]  thisEnum                  The index of the NVIDIA display.\n! \\param [out] pNvUnAttachedDispHandle   Pointer to the NVIDIA display handle of the unattached display.\n!\n! \\retval NVAPI_INVALID_ARGUMENT         Either the handle pointer is NULL or enum index too big\n! \\retval NVAPI_OK                       Return a valid NvDisplayHandle based on the enum index\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA device found in the system\n! \\retval NVAPI_END_ENUMERATION          No more display device to enumerate.\n! \\ingroup disphandle\n"]
    pub fn NvAPI_EnumNvidiaUnAttachedDisplayHandle(
        thisEnum: NvU32,
        pNvUnAttachedDispHandle: *mut NvUnAttachedDisplayHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function converts the unattached display handle to an active attached display handle.\n!\n! At least one GPU must be present in the system and running an NVIDIA display driver.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\retval NVAPI_INVALID_ARGUMENT         hNvUnAttachedDisp is not valid or pNvDisplay is NULL.\n! \\retval NVAPI_OK                       One or more handles were returned\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_CreateDisplayFromUnAttachedDisplay(
        hNvUnAttachedDisp: NvUnAttachedDisplayHandle,
        pNvDisplay: *mut NvDisplayHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the handle of the NVIDIA display that is associated\n!  with the given display \"name\" (such as \"\\\\.\\DISPLAY1\").\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\retval NVAPI_INVALID_ARGUMENT         Either argument is NULL\n! \\retval NVAPI_OK                      *pNvDispHandle is now valid\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA device maps to that display name\n! \\ingroup disphandle\n"]
    pub fn NvAPI_GetAssociatedNvidiaDisplayHandle(
        szDisplayName: *const ::std::os::raw::c_char,
        pNvDispHandle: *mut NvDisplayHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This function returns the handle of an unattached NVIDIA display that is\n!                associated with the given display name (such as \"\\\\DISPLAY1\").\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 185\n!\n! \\retval ::NVAPI_INVALID_ARGUMENT          Either argument is NULL.\n! \\retval ::NVAPI_OK                       *pNvUnAttachedDispHandle is now valid.\n! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   No NVIDIA device maps to that display name.\n!\n! \\ingroup disphandle\n"]
    pub fn NvAPI_DISP_GetAssociatedUnAttachedNvidiaDisplayHandle(
        szDisplayName: *const ::std::os::raw::c_char,
        pNvUnAttachedDispHandle: *mut NvUnAttachedDisplayHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  For a given NVIDIA display handle, this function returns a string (such as \"\\\\.\\DISPLAY1\") to identify the display.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\retval NVAPI_INVALID_ARGUMENT          Either argument is NULL\n! \\retval NVAPI_OK                       *pNvDispHandle is now valid\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND   No NVIDIA device maps to that display name\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_GetAssociatedNvidiaDisplayName(
        NvDispHandle: NvDisplayHandle,
        szDisplayName: *mut ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function returns the display name given, for example, \"\\\\DISPLAY1\", using the unattached NVIDIA display handle\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 95\n!\n! \\retval NVAPI_INVALID_ARGUMENT          Either argument is NULL\n! \\retval NVAPI_OK                       *pNvDispHandle is now valid\n! \\retval NVAPI_NVIDIA_DEVICE_NOT_FOUND   No NVIDIA device maps to that display name\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_GetUnAttachedAssociatedDisplayName(
        hNvUnAttachedDisp: NvUnAttachedDisplayHandle,
        szDisplayName: *mut ::std::os::raw::c_char,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function enables hardware cursor support\n!\n! SUPPORTED OS:  Windows XP\n!\n!\n!\n! \\since Release: 80\n!\n! \\return NVAPI_ERROR or NVAPI_OK\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_EnableHWCursor(hNvDisplay: NvDisplayHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function disables hardware cursor support\n!\n! SUPPORTED OS:  Windows XP\n!\n!\n! \\since Release: 80\n!\n! \\return  NVAPI_ERROR or NVAPI_OK\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DisableHWCursor(hNvDisplay: NvDisplayHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function gets the V-blank counter\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 80\n!\n! \\return NVAPI_ERROR or NVAPI_OK\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_GetVBlankCounter(
        hNvDisplay: NvDisplayHandle,
        pCounter: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This function overrides the refresh rate on the given display/outputsMask.\n!  The new refresh rate can be applied right away in this API call or deferred to be applied with the\n!  next OS modeset. The override is good for only one modeset (regardless whether it's deferred or immediate).\n!\n!\n! SUPPORTED OS:  Windows XP\n!\n!\n! \\since Release: 80\n!\n!  \\param [in] hNvDisplay    The NVIDIA display handle. It can be NVAPI_DEFAULT_HANDLE or a handle\n!                           enumerated from NvAPI_EnumNVidiaDisplayHandle().\n!  \\param [in] outputsMask  A set of bits that identify all target outputs which are associated with the NVIDIA\n!                           display handle to apply the refresh rate override. When SLI is enabled, the\n!                           outputsMask only applies to the GPU that is driving the display output.\n!  \\param [in] refreshRate  The override value. \"0.0\" means cancel the override.\n!  \\param [in] bSetDeferred\n!              - \"0\": Apply the refresh rate override immediately in this API call.\\p\n!              - \"1\": Apply refresh rate at the next OS modeset.\n!\n!  \\retval  NVAPI_INVALID_ARGUMENT hNvDisplay or outputsMask is invalid\n!  \\retval  NVAPI_OK               The refresh rate override is correct set\n!  \\retval  NVAPI_ERROR            The operation failed\n!  \\ingroup dispcontrol\n"]
    pub fn NvAPI_SetRefreshRateOverride(
        hNvDisplay: NvDisplayHandle,
        outputsMask: NvU32,
        refreshRate: f32,
        bSetDeferred: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This function gets the active outputId associated with the display handle.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 90\n!\n! \\param [in]  hNvDisplay  NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().\n! \\param [out] outputId    The active display output ID associated with the selected display handle hNvDisplay.\n!                          The outputid will have only one bit set. In the case of Clone or Span mode, this will indicate the\n!                          display outputId of the primary display that the GPU is driving. See \\ref handles.\n!\n! \\retval  NVAPI_OK                      Call successful.\n! \\retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND No NVIDIA GPU driving a display was found.\n! \\retval  NVAPI_EXPECTED_DISPLAY_HANDLE hNvDisplay is not a valid display handle.\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_GetAssociatedDisplayOutputId(
        hNvDisplay: NvDisplayHandle,
        pOutputId: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol\n! Used in NvAPI_GetDisplayPortInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAY_PORT_INFO_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< DPCD version of the monitor"]
    pub dpcd_ver: NvU32,
    #[doc = "!< Maximum supported link rate"]
    pub maxLinkRate: NV_DP_LINK_RATE,
    #[doc = "!< Maximum supported lane count"]
    pub maxLaneCount: NV_DP_LANE_COUNT,
    #[doc = "!< Current link rate"]
    pub curLinkRate: NV_DP_LINK_RATE,
    #[doc = "!< Current lane count"]
    pub curLaneCount: NV_DP_LANE_COUNT,
    #[doc = "!< Current color format"]
    pub colorFormat: NV_DP_COLOR_FORMAT,
    #[doc = "!< Dynamic range"]
    pub dynamicRange: NV_DP_DYNAMIC_RANGE,
    #[doc = "!< Ignored in RGB space"]
    pub colorimetry: NV_DP_COLORIMETRY,
    #[doc = "!< Current bit-per-component"]
    pub bpc: NV_DP_BPC,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_DISPLAY_PORT_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_DISPLAY_PORT_INFO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAY_PORT_INFO_V1>(),
        44usize,
        concat!("Size of: ", stringify!(_NV_DISPLAY_PORT_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAY_PORT_INFO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_DISPLAY_PORT_INFO_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_PORT_INFO_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dpcd_ver) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_PORT_INFO_V1),
            "::",
            stringify!(dpcd_ver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxLinkRate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_PORT_INFO_V1),
            "::",
            stringify!(maxLinkRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxLaneCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_PORT_INFO_V1),
            "::",
            stringify!(maxLaneCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curLinkRate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_PORT_INFO_V1),
            "::",
            stringify!(curLinkRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curLaneCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_PORT_INFO_V1),
            "::",
            stringify!(curLaneCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_PORT_INFO_V1),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamicRange) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_PORT_INFO_V1),
            "::",
            stringify!(dynamicRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_PORT_INFO_V1),
            "::",
            stringify!(colorimetry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpc) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_PORT_INFO_V1),
            "::",
            stringify!(bpc)
        )
    );
}
impl _NV_DISPLAY_PORT_INFO_V1 {
    #[inline]
    pub fn isDp(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDp(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isInternalDp(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isInternalDp(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isColorCtrlSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isColorCtrlSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is6BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is6BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is8BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is8BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is10BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is10BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is12BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is12BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is16BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is16BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCrCb420Supported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCrCb420Supported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCrCb422Supported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCrCb422Supported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCrCb444Supported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCrCb444Supported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isRgb444SupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isRgb444SupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCbCr444SupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCbCr444SupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCbCr422SupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCbCr422SupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCbCr420SupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCbCr420SupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is6BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is6BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is8BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is8BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is10BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is10BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is12BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is12BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is16BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is16BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC709Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC709Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonsYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonsYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonAdobeYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonAdobeYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonAdobeRGBCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonAdobeRGBCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBT2020RGBCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBT2020RGBCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBT2020YCCCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBT2020YCCCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBT2020cYCCCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBT2020cYCCCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isDp: NvU32,
        isInternalDp: NvU32,
        isColorCtrlSupported: NvU32,
        is6BPCSupported: NvU32,
        is8BPCSupported: NvU32,
        is10BPCSupported: NvU32,
        is12BPCSupported: NvU32,
        is16BPCSupported: NvU32,
        isYCrCb420Supported: NvU32,
        isYCrCb422Supported: NvU32,
        isYCrCb444Supported: NvU32,
        isRgb444SupportedOnCurrentMode: NvU32,
        isYCbCr444SupportedOnCurrentMode: NvU32,
        isYCbCr422SupportedOnCurrentMode: NvU32,
        isYCbCr420SupportedOnCurrentMode: NvU32,
        is6BPCSupportedOnCurrentMode: NvU32,
        is8BPCSupportedOnCurrentMode: NvU32,
        is10BPCSupportedOnCurrentMode: NvU32,
        is12BPCSupportedOnCurrentMode: NvU32,
        is16BPCSupportedOnCurrentMode: NvU32,
        isMonxvYCC601Capable: NvU32,
        isMonxvYCC709Capable: NvU32,
        isMonsYCC601Capable: NvU32,
        isMonAdobeYCC601Capable: NvU32,
        isMonAdobeRGBCapable: NvU32,
        isMonBT2020RGBCapable: NvU32,
        isMonBT2020YCCCapable: NvU32,
        isMonBT2020cYCCCapable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isDp: u32 = unsafe { ::std::mem::transmute(isDp) };
            isDp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isInternalDp: u32 = unsafe { ::std::mem::transmute(isInternalDp) };
            isInternalDp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isColorCtrlSupported: u32 = unsafe { ::std::mem::transmute(isColorCtrlSupported) };
            isColorCtrlSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is6BPCSupported: u32 = unsafe { ::std::mem::transmute(is6BPCSupported) };
            is6BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is8BPCSupported: u32 = unsafe { ::std::mem::transmute(is8BPCSupported) };
            is8BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is10BPCSupported: u32 = unsafe { ::std::mem::transmute(is10BPCSupported) };
            is10BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is12BPCSupported: u32 = unsafe { ::std::mem::transmute(is12BPCSupported) };
            is12BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is16BPCSupported: u32 = unsafe { ::std::mem::transmute(is16BPCSupported) };
            is16BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let isYCrCb420Supported: u32 = unsafe { ::std::mem::transmute(isYCrCb420Supported) };
            isYCrCb420Supported as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let isYCrCb422Supported: u32 = unsafe { ::std::mem::transmute(isYCrCb422Supported) };
            isYCrCb422Supported as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let isYCrCb444Supported: u32 = unsafe { ::std::mem::transmute(isYCrCb444Supported) };
            isYCrCb444Supported as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let isRgb444SupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(isRgb444SupportedOnCurrentMode) };
            isRgb444SupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let isYCbCr444SupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(isYCbCr444SupportedOnCurrentMode) };
            isYCbCr444SupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let isYCbCr422SupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(isYCbCr422SupportedOnCurrentMode) };
            isYCbCr422SupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let isYCbCr420SupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(isYCbCr420SupportedOnCurrentMode) };
            isYCbCr420SupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let is6BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is6BPCSupportedOnCurrentMode) };
            is6BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is8BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is8BPCSupportedOnCurrentMode) };
            is8BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let is10BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is10BPCSupportedOnCurrentMode) };
            is10BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let is12BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is12BPCSupportedOnCurrentMode) };
            is12BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let is16BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is16BPCSupportedOnCurrentMode) };
            is16BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let isMonxvYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC601Capable) };
            isMonxvYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let isMonxvYCC709Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC709Capable) };
            isMonxvYCC709Capable as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let isMonsYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonsYCC601Capable) };
            isMonsYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let isMonAdobeYCC601Capable: u32 =
                unsafe { ::std::mem::transmute(isMonAdobeYCC601Capable) };
            isMonAdobeYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let isMonAdobeRGBCapable: u32 = unsafe { ::std::mem::transmute(isMonAdobeRGBCapable) };
            isMonAdobeRGBCapable as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let isMonBT2020RGBCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBT2020RGBCapable) };
            isMonBT2020RGBCapable as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let isMonBT2020YCCCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBT2020YCCCapable) };
            isMonBT2020YCCCapable as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let isMonBT2020cYCCCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBT2020cYCCCapable) };
            isMonBT2020cYCCCapable as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol\n! Used in NvAPI_GetDisplayPortInfo()."]
pub type NV_DISPLAY_PORT_INFO_V1 = _NV_DISPLAY_PORT_INFO_V1;
#[doc = "! \\ingroup dispcontrol\n! Used in NvAPI_GetDisplayPortInfo()."]
pub type NV_DISPLAY_PORT_INFO = NV_DISPLAY_PORT_INFO_V1;
extern "C" {
    #[doc = "\n! \\ingroup        dispcontrol"]
    pub fn NvAPI_GetDisplayPortInfo(
        hNvDisplay: NvDisplayHandle,
        outputId: NvU32,
        pInfo: *mut NV_DISPLAY_PORT_INFO,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol\n! DisplayPort configuration settings - used in NvAPI_SetDisplayPort()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_DISPLAY_PORT_CONFIG {
    #[doc = "!< Structure version - 2 is the latest"]
    pub version: NvU32,
    #[doc = "!< Link rate"]
    pub linkRate: NV_DP_LINK_RATE,
    #[doc = "!< Lane count"]
    pub laneCount: NV_DP_LANE_COUNT,
    #[doc = "!< Color format to set"]
    pub colorFormat: NV_DP_COLOR_FORMAT,
    #[doc = "!< Dynamic range"]
    pub dynamicRange: NV_DP_DYNAMIC_RANGE,
    #[doc = "!< Ignored in RGB space"]
    pub colorimetry: NV_DP_COLORIMETRY,
    #[doc = "!< Bit-per-component"]
    pub bpc: NV_DP_BPC,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_NV_DISPLAY_PORT_CONFIG() {
    const UNINIT: ::std::mem::MaybeUninit<NV_DISPLAY_PORT_CONFIG> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_DISPLAY_PORT_CONFIG>(),
        32usize,
        concat!("Size of: ", stringify!(NV_DISPLAY_PORT_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_DISPLAY_PORT_CONFIG>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_DISPLAY_PORT_CONFIG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PORT_CONFIG),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linkRate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PORT_CONFIG),
            "::",
            stringify!(linkRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).laneCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PORT_CONFIG),
            "::",
            stringify!(laneCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PORT_CONFIG),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamicRange) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PORT_CONFIG),
            "::",
            stringify!(dynamicRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PORT_CONFIG),
            "::",
            stringify!(colorimetry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_DISPLAY_PORT_CONFIG),
            "::",
            stringify!(bpc)
        )
    );
}
impl NV_DISPLAY_PORT_CONFIG {
    #[inline]
    pub fn isHPD(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isHPD(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isSetDeferred(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSetDeferred(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isChromaLpfOff(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isChromaLpfOff(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isDitherOff(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDitherOff(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn testLinkTrain(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_testLinkTrain(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn testColorChange(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_testColorChange(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isHPD: NvU32,
        isSetDeferred: NvU32,
        isChromaLpfOff: NvU32,
        isDitherOff: NvU32,
        testLinkTrain: NvU32,
        testColorChange: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isHPD: u32 = unsafe { ::std::mem::transmute(isHPD) };
            isHPD as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isSetDeferred: u32 = unsafe { ::std::mem::transmute(isSetDeferred) };
            isSetDeferred as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isChromaLpfOff: u32 = unsafe { ::std::mem::transmute(isChromaLpfOff) };
            isChromaLpfOff as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isDitherOff: u32 = unsafe { ::std::mem::transmute(isDitherOff) };
            isDitherOff as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let testLinkTrain: u32 = unsafe { ::std::mem::transmute(testLinkTrain) };
            testLinkTrain as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let testColorChange: u32 = unsafe { ::std::mem::transmute(testColorChange) };
            testColorChange as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = "! \\ingroup          dispcontrol"]
    pub fn NvAPI_SetDisplayPort(
        hNvDisplay: NvDisplayHandle,
        outputId: NvU32,
        pCfg: *mut NV_DISPLAY_PORT_CONFIG,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol\n! Used in NvAPI_GetHDMISupportInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDMI_SUPPORT_INFO_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Revision number of the EDID 861 extension"]
    pub EDID861ExtRev: NvU32,
}
#[test]
fn bindgen_test_layout__NV_HDMI_SUPPORT_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDMI_SUPPORT_INFO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDMI_SUPPORT_INFO_V1>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_HDMI_SUPPORT_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDMI_SUPPORT_INFO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDMI_SUPPORT_INFO_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDMI_SUPPORT_INFO_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EDID861ExtRev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDMI_SUPPORT_INFO_V1),
            "::",
            stringify!(EDID861ExtRev)
        )
    );
}
impl _NV_HDMI_SUPPORT_INFO_V1 {
    #[inline]
    pub fn isGpuHDMICapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isGpuHDMICapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonUnderscanCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonUnderscanCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBasicAudioCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBasicAudioCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonYCbCr444Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonYCbCr444Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonYCbCr422Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonYCbCr422Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC709Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC709Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonHDMI(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonHDMI(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isGpuHDMICapable: NvU32,
        isMonUnderscanCapable: NvU32,
        isMonBasicAudioCapable: NvU32,
        isMonYCbCr444Capable: NvU32,
        isMonYCbCr422Capable: NvU32,
        isMonxvYCC601Capable: NvU32,
        isMonxvYCC709Capable: NvU32,
        isMonHDMI: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isGpuHDMICapable: u32 = unsafe { ::std::mem::transmute(isGpuHDMICapable) };
            isGpuHDMICapable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isMonUnderscanCapable: u32 =
                unsafe { ::std::mem::transmute(isMonUnderscanCapable) };
            isMonUnderscanCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isMonBasicAudioCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBasicAudioCapable) };
            isMonBasicAudioCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isMonYCbCr444Capable: u32 = unsafe { ::std::mem::transmute(isMonYCbCr444Capable) };
            isMonYCbCr444Capable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isMonYCbCr422Capable: u32 = unsafe { ::std::mem::transmute(isMonYCbCr422Capable) };
            isMonYCbCr422Capable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isMonxvYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC601Capable) };
            isMonxvYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isMonxvYCC709Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC709Capable) };
            isMonxvYCC709Capable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let isMonHDMI: u32 = unsafe { ::std::mem::transmute(isMonHDMI) };
            isMonHDMI as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol\n! Used in NvAPI_GetHDMISupportInfo()."]
pub type NV_HDMI_SUPPORT_INFO_V1 = _NV_HDMI_SUPPORT_INFO_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDMI_SUPPORT_INFO_V2 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Revision number of the EDID 861 extension"]
    pub EDID861ExtRev: NvU32,
}
#[test]
fn bindgen_test_layout__NV_HDMI_SUPPORT_INFO_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDMI_SUPPORT_INFO_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDMI_SUPPORT_INFO_V2>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_HDMI_SUPPORT_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDMI_SUPPORT_INFO_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDMI_SUPPORT_INFO_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDMI_SUPPORT_INFO_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EDID861ExtRev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDMI_SUPPORT_INFO_V2),
            "::",
            stringify!(EDID861ExtRev)
        )
    );
}
impl _NV_HDMI_SUPPORT_INFO_V2 {
    #[inline]
    pub fn isGpuHDMICapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isGpuHDMICapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonUnderscanCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonUnderscanCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBasicAudioCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBasicAudioCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonYCbCr444Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonYCbCr444Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonYCbCr422Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonYCbCr422Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC709Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC709Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonHDMI(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonHDMI(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonsYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonsYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonAdobeYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonAdobeYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonAdobeRGBCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonAdobeRGBCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isGpuHDMICapable: NvU32,
        isMonUnderscanCapable: NvU32,
        isMonBasicAudioCapable: NvU32,
        isMonYCbCr444Capable: NvU32,
        isMonYCbCr422Capable: NvU32,
        isMonxvYCC601Capable: NvU32,
        isMonxvYCC709Capable: NvU32,
        isMonHDMI: NvU32,
        isMonsYCC601Capable: NvU32,
        isMonAdobeYCC601Capable: NvU32,
        isMonAdobeRGBCapable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isGpuHDMICapable: u32 = unsafe { ::std::mem::transmute(isGpuHDMICapable) };
            isGpuHDMICapable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isMonUnderscanCapable: u32 =
                unsafe { ::std::mem::transmute(isMonUnderscanCapable) };
            isMonUnderscanCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isMonBasicAudioCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBasicAudioCapable) };
            isMonBasicAudioCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isMonYCbCr444Capable: u32 = unsafe { ::std::mem::transmute(isMonYCbCr444Capable) };
            isMonYCbCr444Capable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isMonYCbCr422Capable: u32 = unsafe { ::std::mem::transmute(isMonYCbCr422Capable) };
            isMonYCbCr422Capable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isMonxvYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC601Capable) };
            isMonxvYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isMonxvYCC709Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC709Capable) };
            isMonxvYCC709Capable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let isMonHDMI: u32 = unsafe { ::std::mem::transmute(isMonHDMI) };
            isMonHDMI as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let isMonsYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonsYCC601Capable) };
            isMonsYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let isMonAdobeYCC601Capable: u32 =
                unsafe { ::std::mem::transmute(isMonAdobeYCC601Capable) };
            isMonAdobeYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let isMonAdobeRGBCapable: u32 = unsafe { ::std::mem::transmute(isMonAdobeRGBCapable) };
            isMonAdobeRGBCapable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_HDMI_SUPPORT_INFO_V2 = _NV_HDMI_SUPPORT_INFO_V2;
pub type NV_HDMI_SUPPORT_INFO = NV_HDMI_SUPPORT_INFO_V2;
extern "C" {
    #[doc = "! \\ingroup dispcontrol"]
    pub fn NvAPI_GetHDMISupportInfo(
        hNvDisplay: NvDisplayHandle,
        outputId: NvU32,
        pInfo: *mut NV_HDMI_SUPPORT_INFO,
    ) -> NvAPI_Status;
}
#[doc = "!< Returns the fields in the infoframe with values set by the manufacturer - NVIDIA/OEM."]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_GET_DEFAULT: NV_INFOFRAME_CMD = 0;
#[doc = "!< Sets the fields in the infoframe to auto, and infoframe to the default infoframe for use in a set."]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_RESET: NV_INFOFRAME_CMD = 1;
#[doc = "!< Get the current infoframe state."]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_GET: NV_INFOFRAME_CMD = 2;
#[doc = "!< Set the current infoframe state (flushed to the monitor), the values are one time and do not persist."]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_SET: NV_INFOFRAME_CMD = 3;
#[doc = "!< Get the override infoframe state, non-override fields will be set to value = AUTO, overridden fields will have the current override values."]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_GET_OVERRIDE: NV_INFOFRAME_CMD = 4;
#[doc = "!< Set the override infoframe state, non-override fields will be set to value = AUTO, other values indicate override; persist across modeset/reboot"]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_SET_OVERRIDE: NV_INFOFRAME_CMD = 5;
#[doc = "!< get properties associated with infoframe (each of the infoframe type will have properties)"]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_GET_PROPERTY: NV_INFOFRAME_CMD = 6;
#[doc = "!< set properties associated with infoframe"]
pub const NV_INFOFRAME_CMD_NV_INFOFRAME_CMD_SET_PROPERTY: NV_INFOFRAME_CMD = 7;
#[doc = "! \\ingroup dispcontrol"]
pub type NV_INFOFRAME_CMD = ::std::os::raw::c_int;
#[doc = "!< Driver determines whether to send infoframes."]
pub const NV_INFOFRAME_PROPERTY_MODE_NV_INFOFRAME_PROPERTY_MODE_AUTO: NV_INFOFRAME_PROPERTY_MODE =
    0;
#[doc = "!< Driver always sends infoframe."]
pub const NV_INFOFRAME_PROPERTY_MODE_NV_INFOFRAME_PROPERTY_MODE_ENABLE: NV_INFOFRAME_PROPERTY_MODE =
    1;
#[doc = "!< Driver never sends infoframe."]
pub const NV_INFOFRAME_PROPERTY_MODE_NV_INFOFRAME_PROPERTY_MODE_DISABLE:
    NV_INFOFRAME_PROPERTY_MODE = 2;
#[doc = "!< Driver only sends infoframe when client requests it via infoframe escape call."]
pub const NV_INFOFRAME_PROPERTY_MODE_NV_INFOFRAME_PROPERTY_MODE_ALLOW_OVERRIDE:
    NV_INFOFRAME_PROPERTY_MODE = 3;
pub type NV_INFOFRAME_PROPERTY_MODE = ::std::os::raw::c_int;
pub const NV_INFOFRAME_PROPERTY_BLACKLIST_NV_INFOFRAME_PROPERTY_BLACKLIST_FALSE:
    NV_INFOFRAME_PROPERTY_BLACKLIST = 0;
pub const NV_INFOFRAME_PROPERTY_BLACKLIST_NV_INFOFRAME_PROPERTY_BLACKLIST_TRUE:
    NV_INFOFRAME_PROPERTY_BLACKLIST = 1;
#[doc = "! Returns whether the current monitor is in blacklist or force this monitor to be in blacklist."]
pub type NV_INFOFRAME_PROPERTY_BLACKLIST = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct NV_INFOFRAME_PROPERTY {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_NV_INFOFRAME_PROPERTY() {
    assert_eq!(
        ::std::mem::size_of::<NV_INFOFRAME_PROPERTY>(),
        4usize,
        concat!("Size of: ", stringify!(NV_INFOFRAME_PROPERTY))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_INFOFRAME_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_INFOFRAME_PROPERTY))
    );
}
impl NV_INFOFRAME_PROPERTY {
    #[inline]
    pub fn mode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn blackList(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_blackList(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mode: NvU32,
        blackList: NvU32,
        reserved: NvU32,
        version: NvU32,
        length: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mode: u32 = unsafe { ::std::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let blackList: u32 = unsafe { ::std::mem::transmute(blackList) };
            blackList as u64
        });
        __bindgen_bitfield_unit.set(6usize, 10u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NODATA:
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = 0;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_OVERSCAN:
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = 1;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_UNDERSCAN:
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = 2;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_FUTURE:
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = 3;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = 7;
#[doc = "! Byte1 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NOT_PRESENT:
    NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = 0;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_VERTICAL_PRESENT : NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_HORIZONTAL_PRESENT : NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_BOTH_PRESENT:
    NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = 3;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = 7;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO_NV_INFOFRAME_FIELD_VALUE_AVI_AFI_ABSENT:
    NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO = 0;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO_NV_INFOFRAME_FIELD_VALUE_AVI_AFI_PRESENT:
    NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO = 1;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO_NV_INFOFRAME_FIELD_VALUE_AVI_AFI_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO = 3;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_RGB:
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = 0;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_YCbCr422 : NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_YCbCr444 : NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_FUTURE : NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = 7;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_F17_NV_INFOFRAME_FIELD_VALUE_AVI_F17_FALSE:
    NV_INFOFRAME_FIELD_VALUE_AVI_F17 = 0;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_F17_NV_INFOFRAME_FIELD_VALUE_AVI_F17_TRUE:
    NV_INFOFRAME_FIELD_VALUE_AVI_F17 = 1;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_F17_NV_INFOFRAME_FIELD_VALUE_AVI_F17_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_F17 = 3;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_F17 = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NO_AFD : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE01 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE02 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE03 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_LETTERBOX_GT16x9 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE05 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE06 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE07 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_EQUAL_CODEDFRAME : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 8 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_4x3 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 9 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_16x9 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 10 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_14x9 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 11 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE12 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 12 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_4x3_ON_14x9 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 13 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_16x9_ON_14x9 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 14 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_16x9_ON_4x3 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 15 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = 31 ;
#[doc = "! Byte2 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NO_DATA : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_4x3 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_16x9 : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_FUTURE : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME = 7 ;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NO_DATA : NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_SMPTE_170M : NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_ITUR_BT709 : NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_USE_EXTENDED_COLORIMETRY : NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = 7;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NO_DATA : NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_HORIZONTAL : NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_VERTICAL : NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_BOTH : NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING = 7 ;
#[doc = "! Byte 3 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_DEFAULT : NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_LIMITED_RANGE : NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_FULL_RANGE : NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_RESERVED : NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION = 7 ;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_XVYCC601 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_XVYCC709 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_SYCC601 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_ADOBEYCC601 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_ADOBERGB : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED05 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED06 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED07 : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = 15 ;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ITC_NV_INFOFRAME_FIELD_VALUE_AVI_ITC_VIDEO_CONTENT:
    NV_INFOFRAME_FIELD_VALUE_AVI_ITC = 0;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ITC_NV_INFOFRAME_FIELD_VALUE_AVI_ITC_ITCONTENT:
    NV_INFOFRAME_FIELD_VALUE_AVI_ITC = 1;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_ITC_NV_INFOFRAME_FIELD_VALUE_AVI_ITC_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_ITC = 3;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_ITC = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NONE : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X02 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X03 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X04 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X05 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X06 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X07 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X08 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X09 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 8 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X10 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 9 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED10 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 10 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED11 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 11 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED12 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 12 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED13 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 13 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED14 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 14 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED15 : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 15 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = 31 ;
#[doc = "! Byte 4 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_GRAPHICS : NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_PHOTO : NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_CINEMA : NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_GAME:
    NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = 3;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = 7;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_LIMITED_RANGE : NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_FULL_RANGE : NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_RESERVED02 : NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_RESERVED03 : NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_AUTO : NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION = 7 ;
pub type NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION = ::std::os::raw::c_int;
#[doc = "! Adding an Auto bit to each field"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct NV_INFOFRAME_VIDEO {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 23usize]>,
}
#[test]
fn bindgen_test_layout_NV_INFOFRAME_VIDEO() {
    assert_eq!(
        ::std::mem::size_of::<NV_INFOFRAME_VIDEO>(),
        24usize,
        concat!("Size of: ", stringify!(NV_INFOFRAME_VIDEO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_INFOFRAME_VIDEO>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_INFOFRAME_VIDEO))
    );
}
impl NV_INFOFRAME_VIDEO {
    #[inline]
    pub fn vic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelRepeat(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_pixelRepeat(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn colorSpace(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_colorSpace(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn colorimetry(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_colorimetry(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn extendedColorimetry(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_extendedColorimetry(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rgbQuantizationRange(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rgbQuantizationRange(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn yccQuantizationRange(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_yccQuantizationRange(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn itContent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_itContent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn contentTypes(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_contentTypes(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scanInfo(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_scanInfo(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn activeFormatInfoPresent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_activeFormatInfoPresent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn activeFormatAspectRatio(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_activeFormatAspectRatio(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn picAspectRatio(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_picAspectRatio(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn nonuniformScaling(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_nonuniformScaling(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn barInfo(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_barInfo(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn top_bar(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_top_bar(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn bottom_bar(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_bottom_bar(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn left_bar(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(128usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_left_bar(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(128usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn right_bar(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(160usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_right_bar(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(160usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn Future17(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(177usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Future17(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(177usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Future47(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(179usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Future47(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(179usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vic: NvU32,
        pixelRepeat: NvU32,
        colorSpace: NvU32,
        colorimetry: NvU32,
        extendedColorimetry: NvU32,
        rgbQuantizationRange: NvU32,
        yccQuantizationRange: NvU32,
        itContent: NvU32,
        contentTypes: NvU32,
        scanInfo: NvU32,
        activeFormatInfoPresent: NvU32,
        activeFormatAspectRatio: NvU32,
        picAspectRatio: NvU32,
        nonuniformScaling: NvU32,
        barInfo: NvU32,
        top_bar: NvU32,
        bottom_bar: NvU32,
        left_bar: NvU32,
        right_bar: NvU32,
        Future17: NvU32,
        Future47: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 23usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 23usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vic: u32 = unsafe { ::std::mem::transmute(vic) };
            vic as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let pixelRepeat: u32 = unsafe { ::std::mem::transmute(pixelRepeat) };
            pixelRepeat as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let colorSpace: u32 = unsafe { ::std::mem::transmute(colorSpace) };
            colorSpace as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let colorimetry: u32 = unsafe { ::std::mem::transmute(colorimetry) };
            colorimetry as u64
        });
        __bindgen_bitfield_unit.set(19usize, 4u8, {
            let extendedColorimetry: u32 = unsafe { ::std::mem::transmute(extendedColorimetry) };
            extendedColorimetry as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let rgbQuantizationRange: u32 = unsafe { ::std::mem::transmute(rgbQuantizationRange) };
            rgbQuantizationRange as u64
        });
        __bindgen_bitfield_unit.set(26usize, 3u8, {
            let yccQuantizationRange: u32 = unsafe { ::std::mem::transmute(yccQuantizationRange) };
            yccQuantizationRange as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let itContent: u32 = unsafe { ::std::mem::transmute(itContent) };
            itContent as u64
        });
        __bindgen_bitfield_unit.set(32usize, 3u8, {
            let contentTypes: u32 = unsafe { ::std::mem::transmute(contentTypes) };
            contentTypes as u64
        });
        __bindgen_bitfield_unit.set(35usize, 3u8, {
            let scanInfo: u32 = unsafe { ::std::mem::transmute(scanInfo) };
            scanInfo as u64
        });
        __bindgen_bitfield_unit.set(38usize, 2u8, {
            let activeFormatInfoPresent: u32 =
                unsafe { ::std::mem::transmute(activeFormatInfoPresent) };
            activeFormatInfoPresent as u64
        });
        __bindgen_bitfield_unit.set(40usize, 5u8, {
            let activeFormatAspectRatio: u32 =
                unsafe { ::std::mem::transmute(activeFormatAspectRatio) };
            activeFormatAspectRatio as u64
        });
        __bindgen_bitfield_unit.set(45usize, 3u8, {
            let picAspectRatio: u32 = unsafe { ::std::mem::transmute(picAspectRatio) };
            picAspectRatio as u64
        });
        __bindgen_bitfield_unit.set(48usize, 3u8, {
            let nonuniformScaling: u32 = unsafe { ::std::mem::transmute(nonuniformScaling) };
            nonuniformScaling as u64
        });
        __bindgen_bitfield_unit.set(51usize, 3u8, {
            let barInfo: u32 = unsafe { ::std::mem::transmute(barInfo) };
            barInfo as u64
        });
        __bindgen_bitfield_unit.set(64usize, 17u8, {
            let top_bar: u32 = unsafe { ::std::mem::transmute(top_bar) };
            top_bar as u64
        });
        __bindgen_bitfield_unit.set(96usize, 17u8, {
            let bottom_bar: u32 = unsafe { ::std::mem::transmute(bottom_bar) };
            bottom_bar as u64
        });
        __bindgen_bitfield_unit.set(128usize, 17u8, {
            let left_bar: u32 = unsafe { ::std::mem::transmute(left_bar) };
            left_bar as u64
        });
        __bindgen_bitfield_unit.set(160usize, 17u8, {
            let right_bar: u32 = unsafe { ::std::mem::transmute(right_bar) };
            right_bar as u64
        });
        __bindgen_bitfield_unit.set(177usize, 2u8, {
            let Future17: u32 = unsafe { ::std::mem::transmute(Future17) };
            Future17 as u64
        });
        __bindgen_bitfield_unit.set(179usize, 2u8, {
            let Future47: u32 = unsafe { ::std::mem::transmute(Future47) };
            Future47 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_IN_HEADER : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_2 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_3 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_4 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_5 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_6 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_7 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_8 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = 15 ;
#[doc = "! Byte 1 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_IN_HEADER : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_PCM : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AC3 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MPEG1 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MP3 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MPEG2 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AACLC : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DTS : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_ATRAC : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 8 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DSD : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 9 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_EAC3 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 10 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DTSHD : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 11 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MLP : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 12 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DST : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 13 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_WMAPRO : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 14 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_USE_CODING_EXTENSION_TYPE : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 15 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = 31 ;
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_IN_HEADER : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_16BITS : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_20BITS : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_24BITS : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = 7 ;
#[doc = "! Byte 2 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_IN_HEADER : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_32000HZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_44100HZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_48000HZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_88200KHZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_96000KHZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_176400KHZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_192000KHZ : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = 15 ;
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_USE_CODING_TYPE : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_HEAAC : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_HEAACV2 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_MPEGSURROUND : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE04 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE05 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE06 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE07 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE08 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 8 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE09 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 9 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE10 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 10 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE11 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 11 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE12 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 12 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE13 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 13 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE14 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 14 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE15 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 15 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE16 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 16 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE17 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 17 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE18 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 18 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE19 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 19 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE20 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 20 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE21 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 21 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE22 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 22 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE23 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 23 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE24 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 24 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE25 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 25 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE26 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 26 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE27 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 27 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE28 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 28 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE29 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 29 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE30 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 30 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE31 : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 31 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = 63 ;
#[doc = "! Byte 3 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 8 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 9 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 10 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 11 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 12 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 13 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 14 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 15 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 16 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 17 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 18 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 19 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 20 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 21 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 22 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 23 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 24 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 25 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 26 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 27 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 28 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 29 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 30 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 31 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_FCH_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 32 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_FCH_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 33 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_X_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 34 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_X_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 35 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 36 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 37 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_X_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 38 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_X_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 39 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_RC_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 40 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_RC_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 41 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FCH_RC_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 42 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FCH_RC_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 43 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_FCH_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 44 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_FCH_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 45 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 46 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 47 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_FC_X_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 48 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_FC_LFE_FR_FL : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 49 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = 511 ;
#[doc = "! Byte 4 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NO_DATA : NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_0DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_PLUS10DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_RESERVED03 : NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL = 7 ;
#[doc = "! Byte 5 related"]
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_0DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_1DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_2DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 2 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_3DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 3 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_4DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 4 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_5DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 5 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_6DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 6 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_7DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 7 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_8DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 8 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_9DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 9 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_10DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 10 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_11DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 11 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_12DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 12 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_13DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 13 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_14DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 14 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_15DB : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 15 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_AUTO : NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = 31 ;
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES = ::std::os::raw::c_int;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_PERMITTED : NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX = 0 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_PROHIBITED : NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX = 1 ;
pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_AUTO:
    NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX = 3;
pub type NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct NV_INFOFRAME_AUDIO {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 14usize]>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_NV_INFOFRAME_AUDIO() {
    assert_eq!(
        ::std::mem::size_of::<NV_INFOFRAME_AUDIO>(),
        16usize,
        concat!("Size of: ", stringify!(NV_INFOFRAME_AUDIO))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_INFOFRAME_AUDIO>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_INFOFRAME_AUDIO))
    );
}
impl NV_INFOFRAME_AUDIO {
    #[inline]
    pub fn codingType(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_codingType(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn codingExtensionType(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_codingExtensionType(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn sampleSize(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sampleSize(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn sampleRate(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sampleRate(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn channelCount(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_channelCount(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn speakerPlacement(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_speakerPlacement(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn downmixInhibit(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_downmixInhibit(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lfePlaybackLevel(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_lfePlaybackLevel(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn levelShift(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_levelShift(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Future12(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Future12(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Future2x(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Future2x(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Future3x(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Future3x(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Future52(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Future52(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Future6(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future6(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Future7(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future7(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Future8(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(73usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future8(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(73usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Future9(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(82usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future9(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(82usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Future10(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future10(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        codingType: NvU32,
        codingExtensionType: NvU32,
        sampleSize: NvU32,
        sampleRate: NvU32,
        channelCount: NvU32,
        speakerPlacement: NvU32,
        downmixInhibit: NvU32,
        lfePlaybackLevel: NvU32,
        levelShift: NvU32,
        Future12: NvU32,
        Future2x: NvU32,
        Future3x: NvU32,
        Future52: NvU32,
        Future6: NvU32,
        Future7: NvU32,
        Future8: NvU32,
        Future9: NvU32,
        Future10: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 14usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 14usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let codingType: u32 = unsafe { ::std::mem::transmute(codingType) };
            codingType as u64
        });
        __bindgen_bitfield_unit.set(5usize, 6u8, {
            let codingExtensionType: u32 = unsafe { ::std::mem::transmute(codingExtensionType) };
            codingExtensionType as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let sampleSize: u32 = unsafe { ::std::mem::transmute(sampleSize) };
            sampleSize as u64
        });
        __bindgen_bitfield_unit.set(14usize, 4u8, {
            let sampleRate: u32 = unsafe { ::std::mem::transmute(sampleRate) };
            sampleRate as u64
        });
        __bindgen_bitfield_unit.set(18usize, 4u8, {
            let channelCount: u32 = unsafe { ::std::mem::transmute(channelCount) };
            channelCount as u64
        });
        __bindgen_bitfield_unit.set(22usize, 9u8, {
            let speakerPlacement: u32 = unsafe { ::std::mem::transmute(speakerPlacement) };
            speakerPlacement as u64
        });
        __bindgen_bitfield_unit.set(32usize, 2u8, {
            let downmixInhibit: u32 = unsafe { ::std::mem::transmute(downmixInhibit) };
            downmixInhibit as u64
        });
        __bindgen_bitfield_unit.set(34usize, 3u8, {
            let lfePlaybackLevel: u32 = unsafe { ::std::mem::transmute(lfePlaybackLevel) };
            lfePlaybackLevel as u64
        });
        __bindgen_bitfield_unit.set(37usize, 5u8, {
            let levelShift: u32 = unsafe { ::std::mem::transmute(levelShift) };
            levelShift as u64
        });
        __bindgen_bitfield_unit.set(42usize, 2u8, {
            let Future12: u32 = unsafe { ::std::mem::transmute(Future12) };
            Future12 as u64
        });
        __bindgen_bitfield_unit.set(44usize, 4u8, {
            let Future2x: u32 = unsafe { ::std::mem::transmute(Future2x) };
            Future2x as u64
        });
        __bindgen_bitfield_unit.set(48usize, 4u8, {
            let Future3x: u32 = unsafe { ::std::mem::transmute(Future3x) };
            Future3x as u64
        });
        __bindgen_bitfield_unit.set(52usize, 2u8, {
            let Future52: u32 = unsafe { ::std::mem::transmute(Future52) };
            Future52 as u64
        });
        __bindgen_bitfield_unit.set(54usize, 9u8, {
            let Future6: u32 = unsafe { ::std::mem::transmute(Future6) };
            Future6 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 9u8, {
            let Future7: u32 = unsafe { ::std::mem::transmute(Future7) };
            Future7 as u64
        });
        __bindgen_bitfield_unit.set(73usize, 9u8, {
            let Future8: u32 = unsafe { ::std::mem::transmute(Future8) };
            Future8 as u64
        });
        __bindgen_bitfield_unit.set(82usize, 9u8, {
            let Future9: u32 = unsafe { ::std::mem::transmute(Future9) };
            Future9 as u64
        });
        __bindgen_bitfield_unit.set(96usize, 9u8, {
            let Future10: u32 = unsafe { ::std::mem::transmute(Future10) };
            Future10 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_INFOFRAME_DATA {
    #[doc = "!< version of this structure"]
    pub version: NvU32,
    #[doc = "!< size of this structure"]
    pub size: NvU16,
    #[doc = "!< The actions to perform from NV_INFOFRAME_CMD"]
    pub cmd: NvU8,
    #[doc = "!< type of infoframe"]
    pub type_: NvU8,
    pub infoframe: NV_INFOFRAME_DATA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_INFOFRAME_DATA__bindgen_ty_1 {
    #[doc = "!< This is NVIDIA-specific and corresponds to the property cmds and associated infoframe."]
    pub property: NV_INFOFRAME_PROPERTY,
    pub audio: NV_INFOFRAME_AUDIO,
    pub video: NV_INFOFRAME_VIDEO,
}
#[test]
fn bindgen_test_layout_NV_INFOFRAME_DATA__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_INFOFRAME_DATA__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_INFOFRAME_DATA__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(NV_INFOFRAME_DATA__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_INFOFRAME_DATA__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_INFOFRAME_DATA__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_INFOFRAME_DATA__bindgen_ty_1),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_INFOFRAME_DATA__bindgen_ty_1),
            "::",
            stringify!(audio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_INFOFRAME_DATA__bindgen_ty_1),
            "::",
            stringify!(video)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_INFOFRAME_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<NV_INFOFRAME_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_INFOFRAME_DATA>(),
        32usize,
        concat!("Size of: ", stringify!(NV_INFOFRAME_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_INFOFRAME_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_INFOFRAME_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_INFOFRAME_DATA),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_INFOFRAME_DATA),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_INFOFRAME_DATA),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_INFOFRAME_DATA),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).infoframe) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_INFOFRAME_DATA),
            "::",
            stringify!(infoframe)
        )
    );
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API controls the InfoFrame values.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]     displayId         Monitor Identifier\n! \\param [in,out] pInfoframeData    Contains data corresponding to InfoFrame\n!\n! \\return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!            specific meaning for this API, they are listed below.\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_Disp_InfoFrameControl(
        displayId: NvU32,
        pInfoframeData: *mut NV_INFOFRAME_DATA,
    ) -> NvAPI_Status;
}
pub const NV_COLOR_CMD_NV_COLOR_CMD_GET: NV_COLOR_CMD = 1;
pub const NV_COLOR_CMD_NV_COLOR_CMD_SET: NV_COLOR_CMD = 2;
pub const NV_COLOR_CMD_NV_COLOR_CMD_IS_SUPPORTED_COLOR: NV_COLOR_CMD = 3;
pub const NV_COLOR_CMD_NV_COLOR_CMD_GET_DEFAULT: NV_COLOR_CMD = 4;
pub type NV_COLOR_CMD = ::std::os::raw::c_int;
pub const NV_COLOR_FORMAT_NV_COLOR_FORMAT_RGB: NV_COLOR_FORMAT = 0;
pub const NV_COLOR_FORMAT_NV_COLOR_FORMAT_YUV422: NV_COLOR_FORMAT = 1;
pub const NV_COLOR_FORMAT_NV_COLOR_FORMAT_YUV444: NV_COLOR_FORMAT = 2;
pub const NV_COLOR_FORMAT_NV_COLOR_FORMAT_YUV420: NV_COLOR_FORMAT = 3;
pub const NV_COLOR_FORMAT_NV_COLOR_FORMAT_DEFAULT: NV_COLOR_FORMAT = 254;
pub const NV_COLOR_FORMAT_NV_COLOR_FORMAT_AUTO: NV_COLOR_FORMAT = 255;
#[doc = "!  See Table 14 of CEA-861E.  Not all of this is supported by the GPU."]
pub type NV_COLOR_FORMAT = ::std::os::raw::c_int;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_RGB: NV_COLOR_COLORIMETRY = 0;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_YCC601: NV_COLOR_COLORIMETRY = 1;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_YCC709: NV_COLOR_COLORIMETRY = 2;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_XVYCC601: NV_COLOR_COLORIMETRY = 3;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_XVYCC709: NV_COLOR_COLORIMETRY = 4;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_SYCC601: NV_COLOR_COLORIMETRY = 5;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_ADOBEYCC601: NV_COLOR_COLORIMETRY = 6;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_ADOBERGB: NV_COLOR_COLORIMETRY = 7;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_BT2020RGB: NV_COLOR_COLORIMETRY = 8;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_BT2020YCC: NV_COLOR_COLORIMETRY = 9;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_BT2020cYCC: NV_COLOR_COLORIMETRY = 10;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_DEFAULT: NV_COLOR_COLORIMETRY = 254;
pub const NV_COLOR_COLORIMETRY_NV_COLOR_COLORIMETRY_AUTO: NV_COLOR_COLORIMETRY = 255;
pub type NV_COLOR_COLORIMETRY = ::std::os::raw::c_int;
pub const _NV_DYNAMIC_RANGE_NV_DYNAMIC_RANGE_VESA: _NV_DYNAMIC_RANGE = 0;
pub const _NV_DYNAMIC_RANGE_NV_DYNAMIC_RANGE_CEA: _NV_DYNAMIC_RANGE = 1;
pub const _NV_DYNAMIC_RANGE_NV_DYNAMIC_RANGE_AUTO: _NV_DYNAMIC_RANGE = 255;
pub type _NV_DYNAMIC_RANGE = ::std::os::raw::c_int;
pub use self::_NV_DYNAMIC_RANGE as NV_DYNAMIC_RANGE;
pub const _NV_BPC_NV_BPC_DEFAULT: _NV_BPC = 0;
pub const _NV_BPC_NV_BPC_6: _NV_BPC = 1;
pub const _NV_BPC_NV_BPC_8: _NV_BPC = 2;
pub const _NV_BPC_NV_BPC_10: _NV_BPC = 3;
pub const _NV_BPC_NV_BPC_12: _NV_BPC = 4;
pub const _NV_BPC_NV_BPC_16: _NV_BPC = 5;
pub type _NV_BPC = ::std::os::raw::c_int;
pub use self::_NV_BPC as NV_BPC;
#[doc = "!< app/nvcpl make decision to select the desire color format"]
pub const _NV_COLOR_SELECTION_POLICY_NV_COLOR_SELECTION_POLICY_USER: _NV_COLOR_SELECTION_POLICY = 0;
#[doc = "!< driver/ OS make decision to select the best color format"]
pub const _NV_COLOR_SELECTION_POLICY_NV_COLOR_SELECTION_POLICY_BEST_QUALITY:
    _NV_COLOR_SELECTION_POLICY = 1;
pub const _NV_COLOR_SELECTION_POLICY_NV_COLOR_SELECTION_POLICY_DEFAULT: _NV_COLOR_SELECTION_POLICY =
    1;
pub const _NV_COLOR_SELECTION_POLICY_NV_COLOR_SELECTION_POLICY_UNKNOWN: _NV_COLOR_SELECTION_POLICY =
    255;
pub type _NV_COLOR_SELECTION_POLICY = ::std::os::raw::c_int;
pub use self::_NV_COLOR_SELECTION_POLICY as NV_COLOR_SELECTION_POLICY;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_DEFAULT: _NV_DESKTOP_COLOR_DEPTH = 0;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_8BPC: _NV_DESKTOP_COLOR_DEPTH = 1;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_10BPC: _NV_DESKTOP_COLOR_DEPTH = 2;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT: _NV_DESKTOP_COLOR_DEPTH = 3;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT_WCG: _NV_DESKTOP_COLOR_DEPTH =
    4;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT_HDR: _NV_DESKTOP_COLOR_DEPTH =
    5;
pub const _NV_DESKTOP_COLOR_DEPTH_NV_DESKTOP_COLOR_DEPTH_MAX_VALUE: _NV_DESKTOP_COLOR_DEPTH = 5;
pub type _NV_DESKTOP_COLOR_DEPTH = ::std::os::raw::c_int;
pub use self::_NV_DESKTOP_COLOR_DEPTH as NV_DESKTOP_COLOR_DEPTH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Size of this structure"]
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V1__bindgen_ty_1 {
    #[doc = "!< One of NV_COLOR_FORMAT enum values."]
    pub colorFormat: NvU8,
    #[doc = "!< One of NV_COLOR_COLORIMETRY enum values."]
    pub colorimetry: NvU8,
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_COLOR_DATA_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V1__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V1__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(colorimetry)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_COLOR_DATA_V1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V1>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V1),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V1),
            "::",
            stringify!(data)
        )
    );
}
pub type NV_COLOR_DATA_V1 = _NV_COLOR_DATA_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Size of this structure"]
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V2__bindgen_ty_1 {
    #[doc = "!< One of NV_COLOR_FORMAT enum values."]
    pub colorFormat: NvU8,
    #[doc = "!< One of NV_COLOR_COLORIMETRY enum values."]
    pub colorimetry: NvU8,
    #[doc = "!< One of NV_DYNAMIC_RANGE enum values."]
    pub dynamicRange: NvU8,
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_COLOR_DATA_V2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V2__bindgen_ty_1>(),
        3usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V2__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V2__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(colorimetry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamicRange) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(dynamicRange)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_COLOR_DATA_V2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V2>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V2),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V2),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V2),
            "::",
            stringify!(data)
        )
    );
}
pub type NV_COLOR_DATA_V2 = _NV_COLOR_DATA_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V3 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Size of this structure"]
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V3__bindgen_ty_1 {
    #[doc = "!< One of NV_COLOR_FORMAT enum values."]
    pub colorFormat: NvU8,
    #[doc = "!< One of NV_COLOR_COLORIMETRY enum values."]
    pub colorimetry: NvU8,
    #[doc = "!< One of NV_DYNAMIC_RANGE enum values."]
    pub dynamicRange: NvU8,
    #[doc = "!< One of NV_BPC enum values."]
    pub bpc: NV_BPC,
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V3__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_COLOR_DATA_V3__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V3__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V3__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V3__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V3__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V3__bindgen_ty_1),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V3__bindgen_ty_1),
            "::",
            stringify!(colorimetry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamicRange) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V3__bindgen_ty_1),
            "::",
            stringify!(dynamicRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V3__bindgen_ty_1),
            "::",
            stringify!(bpc)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V3() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_COLOR_DATA_V3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V3>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V3),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V3),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V3),
            "::",
            stringify!(data)
        )
    );
}
pub type NV_COLOR_DATA_V3 = _NV_COLOR_DATA_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V4 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Size of this structure"]
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V4__bindgen_ty_1 {
    #[doc = "!< One of NV_COLOR_FORMAT enum values."]
    pub colorFormat: NvU8,
    #[doc = "!< One of NV_COLOR_COLORIMETRY enum values."]
    pub colorimetry: NvU8,
    #[doc = "!< One of NV_DYNAMIC_RANGE enum values."]
    pub dynamicRange: NvU8,
    #[doc = "!< One of NV_BPC enum values."]
    pub bpc: NV_BPC,
    #[doc = "!< One of the color selection policy"]
    pub colorSelectionPolicy: NV_COLOR_SELECTION_POLICY,
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V4__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_COLOR_DATA_V4__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V4__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V4__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1),
            "::",
            stringify!(colorimetry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamicRange) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1),
            "::",
            stringify!(dynamicRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1),
            "::",
            stringify!(bpc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorSelectionPolicy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V4__bindgen_ty_1),
            "::",
            stringify!(colorSelectionPolicy)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V4() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_COLOR_DATA_V4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V4>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V4))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V4>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V4),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V4),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V4),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V4),
            "::",
            stringify!(data)
        )
    );
}
pub type NV_COLOR_DATA_V4 = _NV_COLOR_DATA_V4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V5 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Size of this structure"]
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_COLOR_DATA_V5__bindgen_ty_1 {
    #[doc = "!< One of NV_COLOR_FORMAT enum values."]
    pub colorFormat: NvU8,
    #[doc = "!< One of NV_COLOR_COLORIMETRY enum values."]
    pub colorimetry: NvU8,
    #[doc = "!< One of NV_DYNAMIC_RANGE enum values."]
    pub dynamicRange: NvU8,
    #[doc = "!< One of NV_BPC enum values."]
    pub bpc: NV_BPC,
    #[doc = "!< One of the color selection policy"]
    pub colorSelectionPolicy: NV_COLOR_SELECTION_POLICY,
    #[doc = "!< One of NV_DESKTOP_COLOR_DEPTH enum values."]
    pub depth: NV_DESKTOP_COLOR_DEPTH,
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V5__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_COLOR_DATA_V5__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V5__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V5__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorimetry) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1),
            "::",
            stringify!(colorimetry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamicRange) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1),
            "::",
            stringify!(dynamicRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1),
            "::",
            stringify!(bpc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorSelectionPolicy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1),
            "::",
            stringify!(colorSelectionPolicy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V5__bindgen_ty_1),
            "::",
            stringify!(depth)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_COLOR_DATA_V5() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_COLOR_DATA_V5> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_COLOR_DATA_V5>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_COLOR_DATA_V5))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_COLOR_DATA_V5>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_COLOR_DATA_V5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V5),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V5),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V5),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_COLOR_DATA_V5),
            "::",
            stringify!(data)
        )
    );
}
pub type NV_COLOR_DATA_V5 = _NV_COLOR_DATA_V5;
pub type NV_COLOR_DATA = NV_COLOR_DATA_V5;
extern "C" {
    pub fn NvAPI_Disp_ColorControl(
        displayId: NvU32,
        pColorData: *mut NV_COLOR_DATA,
    ) -> NvAPI_Status;
}
#[doc = "!< Tells the type of structure used to define the Static Metadata Descriptor block."]
pub const NV_STATIC_METADATA_DESCRIPTOR_ID_NV_STATIC_METADATA_TYPE_1:
    NV_STATIC_METADATA_DESCRIPTOR_ID = 0;
#[doc = "! @}"]
pub type NV_STATIC_METADATA_DESCRIPTOR_ID = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Static Metadata Descriptor Id (0 for static metadata type 1)"]
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub display_data: _NV_HDR_CAPABILITIES_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V1__bindgen_ty_1 {
    #[doc = "!< x coordinate of color primary 0 (e.g. Red) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x0: NvU16,
    #[doc = "!< y coordinate of color primary 0 (e.g. Red) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y0: NvU16,
    #[doc = "!< x coordinate of color primary 1 (e.g. Green) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x1: NvU16,
    #[doc = "!< y coordinate of color primary 1 (e.g. Green) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y1: NvU16,
    #[doc = "!< x coordinate of color primary 2 (e.g. Blue) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x2: NvU16,
    #[doc = "!< y coordinate of color primary 2 (e.g. Blue) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y2: NvU16,
    #[doc = "!< x coordinate of white point of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_x: NvU16,
    #[doc = "!< y coordinate of white point of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_y: NvU16,
    #[doc = "!< Maximum display luminance = desired max luminance of HDR content ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub desired_content_max_luminance: NvU16,
    #[doc = "!< Minimum display luminance = desired min luminance of HDR content ([0x0001-0xFFFF] = [1.0 - 6.55350] cd/m^2)"]
    pub desired_content_min_luminance: NvU16,
    #[doc = "!< Desired maximum Frame-Average Light Level (MaxFALL) of HDR content ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub desired_content_max_frame_average_luminance: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>(),
        22usize,
        concat!(
            "Size of: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y0) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y1) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayWhitePoint_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(displayWhitePoint_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayWhitePoint_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(displayWhitePoint_y)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_max_luminance) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(desired_content_max_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_min_luminance) as usize - ptr as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(desired_content_min_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_max_frame_average_luminance) as usize
                - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(desired_content_max_frame_average_luminance)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_CAPABILITIES_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V1>(),
        36usize,
        concat!("Size of: ", stringify!(_NV_HDR_CAPABILITIES_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDR_CAPABILITIES_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).static_metadata_descriptor_id) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1),
            "::",
            stringify!(static_metadata_descriptor_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V1),
            "::",
            stringify!(display_data)
        )
    );
}
impl _NV_HDR_CAPABILITIES_V1 {
    #[inline]
    pub fn isST2084EotfSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isST2084EotfSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalHdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalHdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isEdrSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEdrSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverExpandDefaultHdrParameters(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverExpandDefaultHdrParameters(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalSdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalSdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isST2084EotfSupported: NvU32,
        isTraditionalHdrGammaSupported: NvU32,
        isEdrSupported: NvU32,
        driverExpandDefaultHdrParameters: NvU32,
        isTraditionalSdrGammaSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isST2084EotfSupported: u32 =
                unsafe { ::std::mem::transmute(isST2084EotfSupported) };
            isST2084EotfSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isTraditionalHdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalHdrGammaSupported) };
            isTraditionalHdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isEdrSupported: u32 = unsafe { ::std::mem::transmute(isEdrSupported) };
            isEdrSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverExpandDefaultHdrParameters: u32 =
                unsafe { ::std::mem::transmute(driverExpandDefaultHdrParameters) };
            driverExpandDefaultHdrParameters as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isTraditionalSdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalSdrGammaSupported) };
            isTraditionalSdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_HDR_CAPABILITIES_V1 = _NV_HDR_CAPABILITIES_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Static Metadata Descriptor Id (0 for static metadata type 1)"]
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub display_data: _NV_HDR_CAPABILITIES_V2__bindgen_ty_1,
    pub dv_static_metadata: _NV_HDR_CAPABILITIES_V2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V2__bindgen_ty_1 {
    #[doc = "!< x coordinate of color primary 0 (e.g. Red) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x0: NvU16,
    #[doc = "!< y coordinate of color primary 0 (e.g. Red) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y0: NvU16,
    #[doc = "!< x coordinate of color primary 1 (e.g. Green) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x1: NvU16,
    #[doc = "!< y coordinate of color primary 1 (e.g. Green) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y1: NvU16,
    #[doc = "!< x coordinate of color primary 2 (e.g. Blue) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x2: NvU16,
    #[doc = "!< y coordinate of color primary 2 (e.g. Blue) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y2: NvU16,
    #[doc = "!< x coordinate of white point of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_x: NvU16,
    #[doc = "!< y coordinate of white point of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_y: NvU16,
    #[doc = "!< Maximum display luminance = desired max luminance of HDR content ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub desired_content_max_luminance: NvU16,
    #[doc = "!< Minimum display luminance = desired min luminance of HDR content ([0x0001-0xFFFF] = [1.0 - 6.55350] cd/m^2)"]
    pub desired_content_min_luminance: NvU16,
    #[doc = "!< Desired maximum Frame-Average Light Level (MaxFALL) of HDR content ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub desired_content_max_frame_average_luminance: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>(),
        22usize,
        concat!(
            "Size of: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y0) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y1) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayWhitePoint_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
            "::",
            stringify!(displayWhitePoint_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayWhitePoint_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
            "::",
            stringify!(displayWhitePoint_y)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_max_luminance) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
            "::",
            stringify!(desired_content_max_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_min_luminance) as usize - ptr as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
            "::",
            stringify!(desired_content_min_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_max_frame_average_luminance) as usize
                - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_1),
            "::",
            stringify!(desired_content_max_frame_average_luminance)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V2__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Represents min luminance level of Sink"]
    pub target_min_luminance: NvU16,
    #[doc = "!< Represents max luminance level of sink"]
    pub target_max_luminance: NvU16,
    #[doc = "!< Red primary chromaticity coordinate x"]
    pub cc_red_x: NvU16,
    #[doc = "!< Red primary chromaticity coordinate y"]
    pub cc_red_y: NvU16,
    #[doc = "!< Green primary chromaticity coordinate x"]
    pub cc_green_x: NvU16,
    #[doc = "!< Green primary chromaticity coordinate Y"]
    pub cc_green_y: NvU16,
    #[doc = "!< Blue primary chromaticity coordinate x"]
    pub cc_blue_x: NvU16,
    #[doc = "!< Blue primary chromaticity coordinate y"]
    pub cc_blue_y: NvU16,
    #[doc = "!< White primary chromaticity coordinate x"]
    pub cc_white_x: NvU16,
    #[doc = "!< White primary chromaticity coordinate y"]
    pub cc_white_y: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V2__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_min_luminance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
            "::",
            stringify!(target_min_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_max_luminance) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
            "::",
            stringify!(target_max_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_red_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
            "::",
            stringify!(cc_red_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_red_y) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
            "::",
            stringify!(cc_red_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_green_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
            "::",
            stringify!(cc_green_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_green_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
            "::",
            stringify!(cc_green_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_blue_x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
            "::",
            stringify!(cc_blue_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_blue_y) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
            "::",
            stringify!(cc_blue_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_white_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
            "::",
            stringify!(cc_white_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_white_y) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2__bindgen_ty_2),
            "::",
            stringify!(cc_white_y)
        )
    );
}
impl _NV_HDR_CAPABILITIES_V2__bindgen_ty_2 {
    #[inline]
    pub fn VSVDB_version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_VSVDB_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dm_version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dm_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_2160p60hz(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_2160p60hz(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_YUV422_12bit(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_YUV422_12bit(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_global_dimming(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_global_dimming(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn colorimetry(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_colorimetry(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_backlight_control(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_supports_backlight_control(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn backlt_min_luma(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_backlt_min_luma(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn interface_supported_by_sink(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_interface_supported_by_sink(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_10b_12b_444(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_supports_10b_12b_444(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VSVDB_version: NvU32,
        dm_version: NvU32,
        supports_2160p60hz: NvU32,
        supports_YUV422_12bit: NvU32,
        supports_global_dimming: NvU32,
        colorimetry: NvU32,
        supports_backlight_control: NvU32,
        backlt_min_luma: NvU32,
        interface_supported_by_sink: NvU32,
        supports_10b_12b_444: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let VSVDB_version: u32 = unsafe { ::std::mem::transmute(VSVDB_version) };
            VSVDB_version as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let dm_version: u32 = unsafe { ::std::mem::transmute(dm_version) };
            dm_version as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let supports_2160p60hz: u32 = unsafe { ::std::mem::transmute(supports_2160p60hz) };
            supports_2160p60hz as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let supports_YUV422_12bit: u32 =
                unsafe { ::std::mem::transmute(supports_YUV422_12bit) };
            supports_YUV422_12bit as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let supports_global_dimming: u32 =
                unsafe { ::std::mem::transmute(supports_global_dimming) };
            supports_global_dimming as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let colorimetry: u32 = unsafe { ::std::mem::transmute(colorimetry) };
            colorimetry as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let supports_backlight_control: u32 =
                unsafe { ::std::mem::transmute(supports_backlight_control) };
            supports_backlight_control as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let backlt_min_luma: u32 = unsafe { ::std::mem::transmute(backlt_min_luma) };
            backlt_min_luma as u64
        });
        __bindgen_bitfield_unit.set(19usize, 2u8, {
            let interface_supported_by_sink: u32 =
                unsafe { ::std::mem::transmute(interface_supported_by_sink) };
            interface_supported_by_sink as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let supports_10b_12b_444: u32 = unsafe { ::std::mem::transmute(supports_10b_12b_444) };
            supports_10b_12b_444 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_CAPABILITIES_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V2>(),
        60usize,
        concat!("Size of: ", stringify!(_NV_HDR_CAPABILITIES_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDR_CAPABILITIES_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).static_metadata_descriptor_id) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2),
            "::",
            stringify!(static_metadata_descriptor_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2),
            "::",
            stringify!(display_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dv_static_metadata) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V2),
            "::",
            stringify!(dv_static_metadata)
        )
    );
}
impl _NV_HDR_CAPABILITIES_V2 {
    #[inline]
    pub fn isST2084EotfSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isST2084EotfSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalHdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalHdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isEdrSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEdrSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverExpandDefaultHdrParameters(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverExpandDefaultHdrParameters(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalSdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalSdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isDolbyVisionSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDolbyVisionSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isST2084EotfSupported: NvU32,
        isTraditionalHdrGammaSupported: NvU32,
        isEdrSupported: NvU32,
        driverExpandDefaultHdrParameters: NvU32,
        isTraditionalSdrGammaSupported: NvU32,
        isDolbyVisionSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isST2084EotfSupported: u32 =
                unsafe { ::std::mem::transmute(isST2084EotfSupported) };
            isST2084EotfSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isTraditionalHdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalHdrGammaSupported) };
            isTraditionalHdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isEdrSupported: u32 = unsafe { ::std::mem::transmute(isEdrSupported) };
            isEdrSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverExpandDefaultHdrParameters: u32 =
                unsafe { ::std::mem::transmute(driverExpandDefaultHdrParameters) };
            driverExpandDefaultHdrParameters as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isTraditionalSdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalSdrGammaSupported) };
            isTraditionalSdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isDolbyVisionSupported: u32 =
                unsafe { ::std::mem::transmute(isDolbyVisionSupported) };
            isDolbyVisionSupported as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_HDR_CAPABILITIES_V2 = _NV_HDR_CAPABILITIES_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V3 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Static Metadata Descriptor Id (0 for static metadata type 1)"]
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub display_data: _NV_HDR_CAPABILITIES_V3__bindgen_ty_1,
    pub dv_static_metadata: _NV_HDR_CAPABILITIES_V3__bindgen_ty_2,
    pub hdr10plus_vsvdb: _NV_HDR_CAPABILITIES_V3__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V3__bindgen_ty_1 {
    #[doc = "!< x coordinate of color primary 0 (e.g. Red) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x0: NvU16,
    #[doc = "!< y coordinate of color primary 0 (e.g. Red) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y0: NvU16,
    #[doc = "!< x coordinate of color primary 1 (e.g. Green) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x1: NvU16,
    #[doc = "!< y coordinate of color primary 1 (e.g. Green) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y1: NvU16,
    #[doc = "!< x coordinate of color primary 2 (e.g. Blue) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x2: NvU16,
    #[doc = "!< y coordinate of color primary 2 (e.g. Blue) of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y2: NvU16,
    #[doc = "!< x coordinate of white point of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_x: NvU16,
    #[doc = "!< y coordinate of white point of the display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_y: NvU16,
    #[doc = "!< Maximum display luminance = desired max luminance of HDR content ([0x0000-0xFFFF] = [0.0 - 65535.0] cd/m^2, in units of 1 cd/m^2)"]
    pub desired_content_max_luminance: NvU16,
    #[doc = "!< Minimum display luminance = desired min luminance of HDR content ([0x0000-0xFFFF] = [0.0 - 6.55350] cd/m^2, in units of 0.0001 cd/m^2)"]
    pub desired_content_min_luminance: NvU16,
    #[doc = "!< Desired maximum Frame-Average Light Level (MaxFALL) of HDR content ([0x0000-0xFFFF] = [0.0 - 65535.0] cd/m^2, in units of 1 cd/m^2)"]
    pub desired_content_max_frame_average_luminance: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V3__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_CAPABILITIES_V3__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V3__bindgen_ty_1>(),
        22usize,
        concat!(
            "Size of: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V3__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y0) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y1) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayWhitePoint_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1),
            "::",
            stringify!(displayWhitePoint_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayWhitePoint_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1),
            "::",
            stringify!(displayWhitePoint_y)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_max_luminance) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1),
            "::",
            stringify!(desired_content_max_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_min_luminance) as usize - ptr as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1),
            "::",
            stringify!(desired_content_min_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).desired_content_max_frame_average_luminance) as usize
                - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_1),
            "::",
            stringify!(desired_content_max_frame_average_luminance)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V3__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Represents min luminance level of Sink"]
    pub target_min_luminance: NvU16,
    #[doc = "!< Represents max luminance level of sink"]
    pub target_max_luminance: NvU16,
    #[doc = "!< Red primary chromaticity coordinate x"]
    pub cc_red_x: NvU16,
    #[doc = "!< Red primary chromaticity coordinate y"]
    pub cc_red_y: NvU16,
    #[doc = "!< Green primary chromaticity coordinate x"]
    pub cc_green_x: NvU16,
    #[doc = "!< Green primary chromaticity coordinate Y"]
    pub cc_green_y: NvU16,
    #[doc = "!< Blue primary chromaticity coordinate x"]
    pub cc_blue_x: NvU16,
    #[doc = "!< Blue primary chromaticity coordinate y"]
    pub cc_blue_y: NvU16,
    #[doc = "!< White primary chromaticity coordinate x"]
    pub cc_white_x: NvU16,
    #[doc = "!< White primary chromaticity coordinate y"]
    pub cc_white_y: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V3__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_CAPABILITIES_V3__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V3__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V3__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_min_luminance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_2),
            "::",
            stringify!(target_min_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_max_luminance) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_2),
            "::",
            stringify!(target_max_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_red_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_2),
            "::",
            stringify!(cc_red_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_red_y) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_2),
            "::",
            stringify!(cc_red_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_green_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_2),
            "::",
            stringify!(cc_green_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_green_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_2),
            "::",
            stringify!(cc_green_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_blue_x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_2),
            "::",
            stringify!(cc_blue_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_blue_y) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_2),
            "::",
            stringify!(cc_blue_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_white_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_2),
            "::",
            stringify!(cc_white_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cc_white_y) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_2),
            "::",
            stringify!(cc_white_y)
        )
    );
}
impl _NV_HDR_CAPABILITIES_V3__bindgen_ty_2 {
    #[inline]
    pub fn VSVDB_version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_VSVDB_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dm_version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dm_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_2160p60hz(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_2160p60hz(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_YUV422_12bit(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_YUV422_12bit(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_global_dimming(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_global_dimming(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn colorimetry(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_colorimetry(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_backlight_control(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_supports_backlight_control(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn backlt_min_luma(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_backlt_min_luma(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn interface_supported_by_sink(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_interface_supported_by_sink(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_10b_12b_444(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_supports_10b_12b_444(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn parity(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VSVDB_version: NvU32,
        dm_version: NvU32,
        supports_2160p60hz: NvU32,
        supports_YUV422_12bit: NvU32,
        supports_global_dimming: NvU32,
        colorimetry: NvU32,
        supports_backlight_control: NvU32,
        backlt_min_luma: NvU32,
        interface_supported_by_sink: NvU32,
        supports_10b_12b_444: NvU32,
        parity: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let VSVDB_version: u32 = unsafe { ::std::mem::transmute(VSVDB_version) };
            VSVDB_version as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let dm_version: u32 = unsafe { ::std::mem::transmute(dm_version) };
            dm_version as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let supports_2160p60hz: u32 = unsafe { ::std::mem::transmute(supports_2160p60hz) };
            supports_2160p60hz as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let supports_YUV422_12bit: u32 =
                unsafe { ::std::mem::transmute(supports_YUV422_12bit) };
            supports_YUV422_12bit as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let supports_global_dimming: u32 =
                unsafe { ::std::mem::transmute(supports_global_dimming) };
            supports_global_dimming as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let colorimetry: u32 = unsafe { ::std::mem::transmute(colorimetry) };
            colorimetry as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let supports_backlight_control: u32 =
                unsafe { ::std::mem::transmute(supports_backlight_control) };
            supports_backlight_control as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let backlt_min_luma: u32 = unsafe { ::std::mem::transmute(backlt_min_luma) };
            backlt_min_luma as u64
        });
        __bindgen_bitfield_unit.set(19usize, 2u8, {
            let interface_supported_by_sink: u32 =
                unsafe { ::std::mem::transmute(interface_supported_by_sink) };
            interface_supported_by_sink as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let supports_10b_12b_444: u32 = unsafe { ::std::mem::transmute(supports_10b_12b_444) };
            supports_10b_12b_444 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let parity: u32 = unsafe { ::std::mem::transmute(parity) };
            parity as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V3__bindgen_ty_3 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V3__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V3__bindgen_ty_3>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V3__bindgen_ty_3>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_CAPABILITIES_V3__bindgen_ty_3)
        )
    );
}
impl _NV_HDR_CAPABILITIES_V3__bindgen_ty_3 {
    #[inline]
    pub fn application_version(&self) -> NvU16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_application_version(&mut self, val: NvU16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn full_frame_peak_luminance_index(&self) -> NvU16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_full_frame_peak_luminance_index(&mut self, val: NvU16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn peak_luminance_index(&self) -> NvU16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_peak_luminance_index(&mut self, val: NvU16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        application_version: NvU16,
        full_frame_peak_luminance_index: NvU16,
        peak_luminance_index: NvU16,
        reserved: NvU16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let application_version: u16 = unsafe { ::std::mem::transmute(application_version) };
            application_version as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let full_frame_peak_luminance_index: u16 =
                unsafe { ::std::mem::transmute(full_frame_peak_luminance_index) };
            full_frame_peak_luminance_index as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let peak_luminance_index: u16 = unsafe { ::std::mem::transmute(peak_luminance_index) };
            peak_luminance_index as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__NV_HDR_CAPABILITIES_V3() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_CAPABILITIES_V3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_CAPABILITIES_V3>(),
        64usize,
        concat!("Size of: ", stringify!(_NV_HDR_CAPABILITIES_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_CAPABILITIES_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDR_CAPABILITIES_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).static_metadata_descriptor_id) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3),
            "::",
            stringify!(static_metadata_descriptor_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3),
            "::",
            stringify!(display_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dv_static_metadata) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3),
            "::",
            stringify!(dv_static_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr10plus_vsvdb) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_CAPABILITIES_V3),
            "::",
            stringify!(hdr10plus_vsvdb)
        )
    );
}
impl _NV_HDR_CAPABILITIES_V3 {
    #[inline]
    pub fn isST2084EotfSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isST2084EotfSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalHdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalHdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isEdrSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEdrSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverExpandDefaultHdrParameters(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverExpandDefaultHdrParameters(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalSdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalSdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isDolbyVisionSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDolbyVisionSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isHdr10PlusSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isHdr10PlusSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isHdr10PlusGamingSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isHdr10PlusGamingSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isST2084EotfSupported: NvU32,
        isTraditionalHdrGammaSupported: NvU32,
        isEdrSupported: NvU32,
        driverExpandDefaultHdrParameters: NvU32,
        isTraditionalSdrGammaSupported: NvU32,
        isDolbyVisionSupported: NvU32,
        isHdr10PlusSupported: NvU32,
        isHdr10PlusGamingSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isST2084EotfSupported: u32 =
                unsafe { ::std::mem::transmute(isST2084EotfSupported) };
            isST2084EotfSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isTraditionalHdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalHdrGammaSupported) };
            isTraditionalHdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isEdrSupported: u32 = unsafe { ::std::mem::transmute(isEdrSupported) };
            isEdrSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverExpandDefaultHdrParameters: u32 =
                unsafe { ::std::mem::transmute(driverExpandDefaultHdrParameters) };
            driverExpandDefaultHdrParameters as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isTraditionalSdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalSdrGammaSupported) };
            isTraditionalSdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isDolbyVisionSupported: u32 =
                unsafe { ::std::mem::transmute(isDolbyVisionSupported) };
            isDolbyVisionSupported as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isHdr10PlusSupported: u32 = unsafe { ::std::mem::transmute(isHdr10PlusSupported) };
            isHdr10PlusSupported as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let isHdr10PlusGamingSupported: u32 =
                unsafe { ::std::mem::transmute(isHdr10PlusGamingSupported) };
            isHdr10PlusGamingSupported as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_HDR_CAPABILITIES_V3 = _NV_HDR_CAPABILITIES_V3;
pub type NV_HDR_CAPABILITIES = NV_HDR_CAPABILITIES_V3;
extern "C" {
    pub fn NvAPI_Disp_GetHdrCapabilities(
        displayId: NvU32,
        pHdrCapabilities: *mut NV_HDR_CAPABILITIES,
    ) -> NvAPI_Status;
}
#[doc = "!< Get current HDR output configuration"]
pub const NV_HDR_CMD_NV_HDR_CMD_GET: NV_HDR_CMD = 0;
#[doc = "!< Set HDR output configuration"]
pub const NV_HDR_CMD_NV_HDR_CMD_SET: NV_HDR_CMD = 1;
#[doc = "! @}"]
pub type NV_HDR_CMD = ::std::os::raw::c_int;
#[doc = "!< Turn off HDR"]
pub const NV_HDR_MODE_NV_HDR_MODE_OFF: NV_HDR_MODE = 0;
#[doc = "!< Source: CCCS [a.k.a FP16 scRGB, linear, sRGB primaries, [-65504,0, 65504] range, RGB(1,1,1) = 80nits]  Output : UHDA HDR [a.k.a HDR10, RGB/YCC 10/12bpc ST2084(PQ) EOTF RGB(1,1,1) = 10000 nits, Rec2020 color primaries, ST2086 static HDR metadata]. This is the only supported production HDR mode."]
pub const NV_HDR_MODE_NV_HDR_MODE_UHDA: NV_HDR_MODE = 2;
#[doc = "!< Experimental mode only, not for production! Source: HDR10 RGB 10bpc Output: HDR10 RGB 10 bpc - signal UHDA HDR mode (PQ + Rec2020) to the sink but send source pixel values unmodified (no PQ or Rec2020 conversions) - assumes source is already in HDR10 format."]
pub const NV_HDR_MODE_NV_HDR_MODE_UHDA_PASSTHROUGH: NV_HDR_MODE = 5;
#[doc = "!< Experimental mode only, not for production! Source: RGB8 Dolby Vision encoded (12 bpc YCbCr422 packed into RGB8) Output: Dolby Vision encoded : Application is to encoded frames in DV format and embed DV dynamic metadata as described in Dolby Vision specification."]
pub const NV_HDR_MODE_NV_HDR_MODE_DOLBY_VISION: NV_HDR_MODE = 7;
#[doc = "!< Do not use! Internal test mode only, to be removed. Source: CCCS (a.k.a FP16 scRGB) Output : EDR (Extended Dynamic Range) - HDR content is tonemapped and gamut mapped to output on regular SDR display set to max luminance ( ~300 nits )."]
pub const NV_HDR_MODE_NV_HDR_MODE_EDR: NV_HDR_MODE = 3;
#[doc = "!< Do not use! Internal test mode only, to be removed. Source: any Output: SDR (Standard Dynamic Range), we continuously send SDR EOTF InfoFrame signaling, HDMI compliance testing."]
pub const NV_HDR_MODE_NV_HDR_MODE_SDR: NV_HDR_MODE = 4;
#[doc = "!< Do not use! Internal test mode only, to be removed. Source: CCCS (a.k.a FP16 scRGB) Output : notebook HDR"]
pub const NV_HDR_MODE_NV_HDR_MODE_UHDA_NB: NV_HDR_MODE = 6;
#[doc = "!< Do not use! Obsolete, to be removed. NV_HDR_MODE_UHDBD == NV_HDR_MODE_UHDA, reflects obsolete pre-UHDA naming convention."]
pub const NV_HDR_MODE_NV_HDR_MODE_UHDBD: NV_HDR_MODE = 2;
pub type NV_HDR_MODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_COLOR_DATA_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Command get/set"]
    pub cmd: NV_HDR_CMD,
    #[doc = "!< HDR mode"]
    pub hdrMode: NV_HDR_MODE,
    #[doc = "!< Static Metadata Descriptor Id (0 for static metadata type 1)"]
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub mastering_display_data: _NV_HDR_COLOR_DATA_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_COLOR_DATA_V1__bindgen_ty_1 {
    #[doc = "!< x coordinate of color primary 0 (e.g. Red) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x0: NvU16,
    #[doc = "!< y coordinate of color primary 0 (e.g. Red) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y0: NvU16,
    #[doc = "!< x coordinate of color primary 1 (e.g. Green) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x1: NvU16,
    #[doc = "!< y coordinate of color primary 1 (e.g. Green) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y1: NvU16,
    #[doc = "!< x coordinate of color primary 2 (e.g. Blue) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x2: NvU16,
    #[doc = "!< y coordinate of color primary 2 (e.g. Blue) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y2: NvU16,
    #[doc = "!< x coordinate of white point of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_x: NvU16,
    #[doc = "!< y coordinate of white point of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_y: NvU16,
    #[doc = "!< Maximum display mastering luminance ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub max_display_mastering_luminance: NvU16,
    #[doc = "!< Minimum display mastering luminance ([0x0001-0xFFFF] = [1.0 - 6.55350] cd/m^2)"]
    pub min_display_mastering_luminance: NvU16,
    #[doc = "!< Maximum Content Light level (MaxCLL) ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub max_content_light_level: NvU16,
    #[doc = "!< Maximum Frame-Average Light Level (MaxFALL) ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub max_frame_average_light_level: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_COLOR_DATA_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_COLOR_DATA_V1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y0) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y1) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayWhitePoint_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(displayWhitePoint_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayWhitePoint_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(displayWhitePoint_y)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_display_mastering_luminance) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(max_display_mastering_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).min_display_mastering_luminance) as usize - ptr as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(min_display_mastering_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_content_light_level) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(max_content_light_level)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_frame_average_light_level) as usize - ptr as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1__bindgen_ty_1),
            "::",
            stringify!(max_frame_average_light_level)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_HDR_COLOR_DATA_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_COLOR_DATA_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_COLOR_DATA_V1>(),
        40usize,
        concat!("Size of: ", stringify!(_NV_HDR_COLOR_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_COLOR_DATA_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDR_COLOR_DATA_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdrMode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1),
            "::",
            stringify!(hdrMode)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).static_metadata_descriptor_id) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1),
            "::",
            stringify!(static_metadata_descriptor_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mastering_display_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V1),
            "::",
            stringify!(mastering_display_data)
        )
    );
}
pub type NV_HDR_COLOR_DATA_V1 = _NV_HDR_COLOR_DATA_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_COLOR_DATA_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Command get/set"]
    pub cmd: NV_HDR_CMD,
    #[doc = "!< HDR mode"]
    pub hdrMode: NV_HDR_MODE,
    #[doc = "!< Static Metadata Descriptor Id (0 for static metadata type 1)"]
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub mastering_display_data: _NV_HDR_COLOR_DATA_V2__bindgen_ty_1,
    #[doc = "!< Optional, One of NV_COLOR_FORMAT enum values, if set it will apply requested color format for HDR session"]
    pub hdrColorFormat: NV_COLOR_FORMAT,
    #[doc = "!< Optional, One of NV_DYNAMIC_RANGE enum values, if set it will apply requested dynamic range for HDR session"]
    pub hdrDynamicRange: NV_DYNAMIC_RANGE,
    #[doc = "!< Optional, One of NV_BPC enum values, if set it will apply requested color depth\n!< Dolby Vision mode: DV supports specific combinations of colorformat, dynamic range and bpc. Please refer Dolby Vision specification.\n!<                    If invalid or no combination is passed driver will force default combination of RGB format + full range + 8bpc.\n!< HDR mode: These fields are ignored in hdr mode"]
    pub hdrBpc: NV_BPC,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_COLOR_DATA_V2__bindgen_ty_1 {
    #[doc = "!< x coordinate of color primary 0 (e.g. Red) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x0: NvU16,
    #[doc = "!< y coordinate of color primary 0 (e.g. Red) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y0: NvU16,
    #[doc = "!< x coordinate of color primary 1 (e.g. Green) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x1: NvU16,
    #[doc = "!< y coordinate of color primary 1 (e.g. Green) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y1: NvU16,
    #[doc = "!< x coordinate of color primary 2 (e.g. Blue) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x2: NvU16,
    #[doc = "!< y coordinate of color primary 2 (e.g. Blue) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y2: NvU16,
    #[doc = "!< x coordinate of white point of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_x: NvU16,
    #[doc = "!< y coordinate of white point of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_y: NvU16,
    #[doc = "!< Maximum display mastering luminance ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub max_display_mastering_luminance: NvU16,
    #[doc = "!< Minimum display mastering luminance ([0x0001-0xFFFF] = [1.0 - 6.55350] cd/m^2)"]
    pub min_display_mastering_luminance: NvU16,
    #[doc = "!< Maximum Content Light level (MaxCLL) ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub max_content_light_level: NvU16,
    #[doc = "!< Maximum Frame-Average Light Level (MaxFALL) ([0x0001-0xFFFF] = [1.0 - 65535.0] cd/m^2)"]
    pub max_frame_average_light_level: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_COLOR_DATA_V2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_COLOR_DATA_V2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y0) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y1) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_x2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(displayPrimary_y2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayWhitePoint_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(displayWhitePoint_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayWhitePoint_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(displayWhitePoint_y)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_display_mastering_luminance) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(max_display_mastering_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).min_display_mastering_luminance) as usize - ptr as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(min_display_mastering_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_content_light_level) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(max_content_light_level)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_frame_average_light_level) as usize - ptr as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2__bindgen_ty_1),
            "::",
            stringify!(max_frame_average_light_level)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_HDR_COLOR_DATA_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_COLOR_DATA_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_COLOR_DATA_V2>(),
        52usize,
        concat!("Size of: ", stringify!(_NV_HDR_COLOR_DATA_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_COLOR_DATA_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDR_COLOR_DATA_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdrMode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2),
            "::",
            stringify!(hdrMode)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).static_metadata_descriptor_id) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2),
            "::",
            stringify!(static_metadata_descriptor_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mastering_display_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2),
            "::",
            stringify!(mastering_display_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdrColorFormat) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2),
            "::",
            stringify!(hdrColorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdrDynamicRange) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2),
            "::",
            stringify!(hdrDynamicRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdrBpc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_COLOR_DATA_V2),
            "::",
            stringify!(hdrBpc)
        )
    );
}
pub type NV_HDR_COLOR_DATA_V2 = _NV_HDR_COLOR_DATA_V2;
pub type NV_HDR_COLOR_DATA = NV_HDR_COLOR_DATA_V2;
extern "C" {
    pub fn NvAPI_Disp_HdrColorControl(
        displayId: NvU32,
        pHdrColorData: *mut NV_HDR_COLOR_DATA,
    ) -> NvAPI_Status;
}
#[doc = "!< sRGB IEC 61966-2-1:1999 == DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709"]
pub const _NV_COLORSPACE_TYPE_NV_COLORSPACE_sRGB: _NV_COLORSPACE_TYPE = 0;
#[doc = "!< FP16 linear with sRGB color primaries == DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709"]
pub const _NV_COLORSPACE_TYPE_NV_COLORSPACE_xRGB: _NV_COLORSPACE_TYPE = 1;
#[doc = "!< ITU-R Rec BT.2100 (HDR10) == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020"]
pub const _NV_COLORSPACE_TYPE_NV_COLORSPACE_REC2100: _NV_COLORSPACE_TYPE = 12;
pub type _NV_COLORSPACE_TYPE = ::std::os::raw::c_int;
pub use self::_NV_COLORSPACE_TYPE as NV_COLORSPACE_TYPE;
extern "C" {
    pub fn NvAPI_Disp_SetSourceColorSpace(
        displayId: NvU32,
        colorSpaceType: NV_COLORSPACE_TYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    pub fn NvAPI_Disp_GetSourceColorSpace(
        displayId: NvU32,
        pColorSpaceType: *mut NV_COLORSPACE_TYPE,
        sourcePID: NvU64,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_HDR_METADATA_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< x coordinate of color primary 0 (e.g. Red) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x0: NvU16,
    #[doc = "!< y coordinate of color primary 0 (e.g. Red) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y0: NvU16,
    #[doc = "!< x coordinate of color primary 1 (e.g. Green) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x1: NvU16,
    #[doc = "!< y coordinate of color primary 1 (e.g. Green) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y1: NvU16,
    #[doc = "!< x coordinate of color primary 2 (e.g. Blue) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_x2: NvU16,
    #[doc = "!< y coordinate of color primary 2 (e.g. Blue) of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayPrimary_y2: NvU16,
    #[doc = "!< x coordinate of white point of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_x: NvU16,
    #[doc = "!< y coordinate of white point of mastering display ([0x0000-0xC350] = [0.0 - 1.0])"]
    pub displayWhitePoint_y: NvU16,
    #[doc = "!< Maximum display mastering luminance ([0x0000-0xFFFF] = [0.0 - 65535.0] cd/m^2, in units of 1 cd/m^2)"]
    pub max_display_mastering_luminance: NvU16,
    #[doc = "!< Minimum display mastering luminance ([0x0000-0xFFFF] = [0.0 - 6.55350] cd/m^2, in units of 0.0001 cd/m^2)"]
    pub min_display_mastering_luminance: NvU16,
    #[doc = "!< Maximum Content Light level (MaxCLL) ([0x0000-0xFFFF] = [0.0 - 65535.0] cd/m^2, in units of 1 cd/m^2)"]
    pub max_content_light_level: NvU16,
    #[doc = "!< Maximum Frame-Average Light Level (MaxFALL) ([0x0000-0xFFFF] = [0.0 - 65535.0] cd/m^2, in units of 1 cd/m^2)"]
    pub max_frame_average_light_level: NvU16,
}
#[test]
fn bindgen_test_layout__NV_HDR_METADATA_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_HDR_METADATA_V1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_HDR_METADATA_V1>(),
        28usize,
        concat!("Size of: ", stringify!(_NV_HDR_METADATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_HDR_METADATA_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_HDR_METADATA_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(displayPrimary_x0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y0) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(displayPrimary_y0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(displayPrimary_x1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(displayPrimary_y1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_x2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(displayPrimary_x2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPrimary_y2) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(displayPrimary_y2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayWhitePoint_x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(displayWhitePoint_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayWhitePoint_y) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(displayWhitePoint_y)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_display_mastering_luminance) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(max_display_mastering_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).min_display_mastering_luminance) as usize - ptr as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(min_display_mastering_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_content_light_level) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(max_content_light_level)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_frame_average_light_level) as usize - ptr as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_HDR_METADATA_V1),
            "::",
            stringify!(max_frame_average_light_level)
        )
    );
}
pub type NV_HDR_METADATA_V1 = _NV_HDR_METADATA_V1;
pub type NV_HDR_METADATA = NV_HDR_METADATA_V1;
extern "C" {
    pub fn NvAPI_Disp_SetSourceHdrMetadata(
        displayId: NvU32,
        pMetadata: *mut NV_HDR_METADATA,
    ) -> NvAPI_Status;
}
extern "C" {
    pub fn NvAPI_Disp_GetSourceHdrMetadata(
        displayId: NvU32,
        pMetadata: *mut NV_HDR_METADATA,
        sourcePID: NvU64,
    ) -> NvAPI_Status;
}
pub const _NV_DISPLAY_OUTPUT_MODE_NV_DISPLAY_OUTPUT_MODE_SDR: _NV_DISPLAY_OUTPUT_MODE = 0;
pub const _NV_DISPLAY_OUTPUT_MODE_NV_DISPLAY_OUTPUT_MODE_HDR10: _NV_DISPLAY_OUTPUT_MODE = 1;
pub const _NV_DISPLAY_OUTPUT_MODE_NV_DISPLAY_OUTPUT_MODE_HDR10PLUS_GAMING: _NV_DISPLAY_OUTPUT_MODE =
    2;
pub type _NV_DISPLAY_OUTPUT_MODE = ::std::os::raw::c_int;
pub use self::_NV_DISPLAY_OUTPUT_MODE as NV_DISPLAY_OUTPUT_MODE;
extern "C" {
    pub fn NvAPI_Disp_SetOutputMode(
        displayId: NvU32,
        pDisplayMode: *mut NV_DISPLAY_OUTPUT_MODE,
    ) -> NvAPI_Status;
}
extern "C" {
    pub fn NvAPI_Disp_GetOutputMode(
        displayId: NvU32,
        pDisplayMode: *mut NV_DISPLAY_OUTPUT_MODE,
    ) -> NvAPI_Status;
}
pub const _NV_HDR_TONEMAPPING_METHOD_NV_HDR_TONEMAPPING_APP: _NV_HDR_TONEMAPPING_METHOD = 0;
pub const _NV_HDR_TONEMAPPING_METHOD_NV_HDR_TONEMAPPING_GPU: _NV_HDR_TONEMAPPING_METHOD = 1;
pub type _NV_HDR_TONEMAPPING_METHOD = ::std::os::raw::c_int;
pub use self::_NV_HDR_TONEMAPPING_METHOD as NV_HDR_TONEMAPPING_METHOD;
extern "C" {
    pub fn NvAPI_Disp_SetHdrToneMapping(
        displayId: NvU32,
        hdrTonemapping: NV_HDR_TONEMAPPING_METHOD,
    ) -> NvAPI_Status;
}
extern "C" {
    pub fn NvAPI_Disp_GetHdrToneMapping(
        displayId: NvU32,
        pHdrTonemapping: *mut NV_HDR_TONEMAPPING_METHOD,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol\n! Used in NvAPI_DISP_GetTiming()."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct NV_TIMING_FLAG {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1: NV_TIMING_FLAG__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[repr(C)]
#[repr(align(1))]
#[derive(Copy, Clone)]
pub union NV_TIMING_FLAG__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
#[test]
fn bindgen_test_layout_NV_TIMING_FLAG__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<NV_TIMING_FLAG__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(NV_TIMING_FLAG__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_TIMING_FLAG__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(NV_TIMING_FLAG__bindgen_ty_1))
    );
}
impl NV_TIMING_FLAG__bindgen_ty_1 {
    #[inline]
    pub fn tvFormat(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tvFormat(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ceaId(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ceaId(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn nvPsfId(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_nvPsfId(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tvFormat: NvU32,
        ceaId: NvU32,
        nvPsfId: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tvFormat: u32 = unsafe { ::std::mem::transmute(tvFormat) };
            tvFormat as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let ceaId: u32 = unsafe { ::std::mem::transmute(ceaId) };
            ceaId as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let nvPsfId: u32 = unsafe { ::std::mem::transmute(nvPsfId) };
            nvPsfId as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_TIMING_FLAG() {
    assert_eq!(
        ::std::mem::size_of::<NV_TIMING_FLAG>(),
        12usize,
        concat!("Size of: ", stringify!(NV_TIMING_FLAG))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_TIMING_FLAG>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_TIMING_FLAG))
    );
}
impl NV_TIMING_FLAG {
    #[inline]
    pub fn isInterlaced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_isInterlaced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isInterlaced: NvU32,
        reserved0: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let isInterlaced: u32 = unsafe { ::std::mem::transmute(isInterlaced) };
            isInterlaced as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn scaling(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_scaling(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(scaling: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let scaling: u32 = unsafe { ::std::mem::transmute(scaling) };
            scaling as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol\n! Used in NvAPI_DISP_GetTiming()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_TIMING_INPUT {
    #[doc = "!< (IN)     structure version"]
    pub version: NvU32,
    #[doc = "!< Visible horizontal size"]
    pub width: NvU32,
    #[doc = "!< Visible vertical size"]
    pub height: NvU32,
    #[doc = "!< Timing refresh rate"]
    pub rr: f32,
    #[doc = "!< Flag containing additional info for timing calculation."]
    pub flag: NV_TIMING_FLAG,
    #[doc = "!< Timing type(formula) to use for calculating the timing"]
    pub type_: NV_TIMING_OVERRIDE,
}
#[test]
fn bindgen_test_layout__NV_TIMING_INPUT() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_TIMING_INPUT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_TIMING_INPUT>(),
        32usize,
        concat!("Size of: ", stringify!(_NV_TIMING_INPUT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_TIMING_INPUT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_TIMING_INPUT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING_INPUT),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING_INPUT),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING_INPUT),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING_INPUT),
            "::",
            stringify!(rr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING_INPUT),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_TIMING_INPUT),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = "! \\ingroup dispcontrol\n! Used in NvAPI_DISP_GetTiming()."]
pub type NV_TIMING_INPUT = _NV_TIMING_INPUT;
extern "C" {
    #[doc = "! DESCRIPTION:  This function calculates the timing from the visible width/height/refresh-rate and timing type info.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n!\n! \\param [in]   displayId     Display ID of the display.\n! \\param [in]   timingInput   Inputs used for calculating the timing.\n! \\param [out]  pTiming       Pointer to the NV_TIMING structure.\n!\n! \\return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!                specific meaning for this API, they are listed below.\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DISP_GetTiming(
        displayId: NvU32,
        timingInput: *mut NV_TIMING_INPUT,
        pTiming: *mut NV_TIMING,
    ) -> NvAPI_Status;
}
pub const NV_MONITOR_CAPS_TYPE_NV_MONITOR_CAPS_TYPE_HDMI_VSDB: NV_MONITOR_CAPS_TYPE = 4096;
pub const NV_MONITOR_CAPS_TYPE_NV_MONITOR_CAPS_TYPE_HDMI_VCDB: NV_MONITOR_CAPS_TYPE = 4097;
pub const NV_MONITOR_CAPS_TYPE_NV_MONITOR_CAPS_TYPE_GENERIC: NV_MONITOR_CAPS_TYPE = 4098;
#[doc = "! HDMI-related and extended CAPs"]
pub type NV_MONITOR_CAPS_TYPE = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MONITOR_CAPS_VCDB {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout__NV_MONITOR_CAPS_VCDB() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MONITOR_CAPS_VCDB>(),
        1usize,
        concat!("Size of: ", stringify!(_NV_MONITOR_CAPS_VCDB))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MONITOR_CAPS_VCDB>(),
        1usize,
        concat!("Alignment of ", stringify!(_NV_MONITOR_CAPS_VCDB))
    );
}
impl _NV_MONITOR_CAPS_VCDB {
    #[inline]
    pub fn quantizationRangeYcc(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_quantizationRangeYcc(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quantizationRangeRgb(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_quantizationRangeRgb(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scanInfoPreferredVideoFormat(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_scanInfoPreferredVideoFormat(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn scanInfoITVideoFormats(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_scanInfoITVideoFormats(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn scanInfoCEVideoFormats(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_scanInfoCEVideoFormats(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        quantizationRangeYcc: NvU8,
        quantizationRangeRgb: NvU8,
        scanInfoPreferredVideoFormat: NvU8,
        scanInfoITVideoFormats: NvU8,
        scanInfoCEVideoFormats: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let quantizationRangeYcc: u8 = unsafe { ::std::mem::transmute(quantizationRangeYcc) };
            quantizationRangeYcc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let quantizationRangeRgb: u8 = unsafe { ::std::mem::transmute(quantizationRangeRgb) };
            quantizationRangeRgb as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let scanInfoPreferredVideoFormat: u8 =
                unsafe { ::std::mem::transmute(scanInfoPreferredVideoFormat) };
            scanInfoPreferredVideoFormat as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let scanInfoITVideoFormats: u8 =
                unsafe { ::std::mem::transmute(scanInfoITVideoFormats) };
            scanInfoITVideoFormats as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let scanInfoCEVideoFormats: u8 =
                unsafe { ::std::mem::transmute(scanInfoCEVideoFormats) };
            scanInfoCEVideoFormats as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MONITOR_CAPS_VCDB = _NV_MONITOR_CAPS_VCDB;
#[doc = "! See NvAPI_DISP_GetMonitorCapabilities()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MONITOR_CAPS_VSDB {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    #[doc = "!< Bye 4"]
    pub maxTmdsClock: NvU8,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "!< Byte 6"]
    pub videoLatency: NvU8,
    #[doc = "!< Byte 7"]
    pub audioLatency: NvU8,
    #[doc = "!< Byte 8"]
    pub interlacedVideoLatency: NvU8,
    #[doc = "!< Byte 9"]
    pub interlacedAudioLatency: NvU8,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "!< Keeping maximum length for 3 bits"]
    pub hdmi_vic: [NvU8; 7usize],
    #[doc = "!< Keeping maximum length for 5 bits"]
    pub hdmi_3d: [NvU8; 31usize],
}
#[test]
fn bindgen_test_layout__NV_MONITOR_CAPS_VSDB() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MONITOR_CAPS_VSDB> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MONITOR_CAPS_VSDB>(),
        49usize,
        concat!("Size of: ", stringify!(_NV_MONITOR_CAPS_VSDB))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MONITOR_CAPS_VSDB>(),
        1usize,
        concat!("Alignment of ", stringify!(_NV_MONITOR_CAPS_VSDB))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTmdsClock) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPS_VSDB),
            "::",
            stringify!(maxTmdsClock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).videoLatency) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPS_VSDB),
            "::",
            stringify!(videoLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioLatency) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPS_VSDB),
            "::",
            stringify!(audioLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlacedVideoLatency) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPS_VSDB),
            "::",
            stringify!(interlacedVideoLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlacedAudioLatency) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPS_VSDB),
            "::",
            stringify!(interlacedAudioLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdmi_vic) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPS_VSDB),
            "::",
            stringify!(hdmi_vic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdmi_3d) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPS_VSDB),
            "::",
            stringify!(hdmi_3d)
        )
    );
}
impl _NV_MONITOR_CAPS_VSDB {
    #[inline]
    pub fn sourcePhysicalAddressB(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sourcePhysicalAddressB(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sourcePhysicalAddressA(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sourcePhysicalAddressA(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sourcePhysicalAddressD(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sourcePhysicalAddressD(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sourcePhysicalAddressC(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sourcePhysicalAddressC(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDualDviOperation(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDualDviOperation(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDeepColorYCbCr444(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDeepColorYCbCr444(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDeepColor30bits(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDeepColor30bits(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDeepColor36bits(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDeepColor36bits(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDeepColor48bits(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDeepColor48bits(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportAI(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportAI(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sourcePhysicalAddressB: NvU8,
        sourcePhysicalAddressA: NvU8,
        sourcePhysicalAddressD: NvU8,
        sourcePhysicalAddressC: NvU8,
        supportDualDviOperation: NvU8,
        reserved6: NvU8,
        supportDeepColorYCbCr444: NvU8,
        supportDeepColor30bits: NvU8,
        supportDeepColor36bits: NvU8,
        supportDeepColor48bits: NvU8,
        supportAI: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sourcePhysicalAddressB: u8 =
                unsafe { ::std::mem::transmute(sourcePhysicalAddressB) };
            sourcePhysicalAddressB as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let sourcePhysicalAddressA: u8 =
                unsafe { ::std::mem::transmute(sourcePhysicalAddressA) };
            sourcePhysicalAddressA as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let sourcePhysicalAddressD: u8 =
                unsafe { ::std::mem::transmute(sourcePhysicalAddressD) };
            sourcePhysicalAddressD as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let sourcePhysicalAddressC: u8 =
                unsafe { ::std::mem::transmute(sourcePhysicalAddressC) };
            sourcePhysicalAddressC as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let supportDualDviOperation: u8 =
                unsafe { ::std::mem::transmute(supportDualDviOperation) };
            supportDualDviOperation as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let reserved6: u8 = unsafe { ::std::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let supportDeepColorYCbCr444: u8 =
                unsafe { ::std::mem::transmute(supportDeepColorYCbCr444) };
            supportDeepColorYCbCr444 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let supportDeepColor30bits: u8 =
                unsafe { ::std::mem::transmute(supportDeepColor30bits) };
            supportDeepColor30bits as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let supportDeepColor36bits: u8 =
                unsafe { ::std::mem::transmute(supportDeepColor36bits) };
            supportDeepColor36bits as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let supportDeepColor48bits: u8 =
                unsafe { ::std::mem::transmute(supportDeepColor48bits) };
            supportDeepColor48bits as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let supportAI: u8 = unsafe { ::std::mem::transmute(supportAI) };
            supportAI as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn cnc0SupportGraphicsTextContent(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnc0SupportGraphicsTextContent(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnc1SupportPhotoContent(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnc1SupportPhotoContent(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnc2SupportCinemaContent(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnc2SupportCinemaContent(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnc3SupportGameContent(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnc3SupportGameContent(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasVicEntries(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hasVicEntries(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasInterlacedLatencyField(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hasInterlacedLatencyField(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasLatencyField(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hasLatencyField(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        cnc0SupportGraphicsTextContent: NvU8,
        cnc1SupportPhotoContent: NvU8,
        cnc2SupportCinemaContent: NvU8,
        cnc3SupportGameContent: NvU8,
        reserved8: NvU8,
        hasVicEntries: NvU8,
        hasInterlacedLatencyField: NvU8,
        hasLatencyField: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cnc0SupportGraphicsTextContent: u8 =
                unsafe { ::std::mem::transmute(cnc0SupportGraphicsTextContent) };
            cnc0SupportGraphicsTextContent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cnc1SupportPhotoContent: u8 =
                unsafe { ::std::mem::transmute(cnc1SupportPhotoContent) };
            cnc1SupportPhotoContent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cnc2SupportCinemaContent: u8 =
                unsafe { ::std::mem::transmute(cnc2SupportCinemaContent) };
            cnc2SupportCinemaContent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cnc3SupportGameContent: u8 =
                unsafe { ::std::mem::transmute(cnc3SupportGameContent) };
            cnc3SupportGameContent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reserved8: u8 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hasVicEntries: u8 = unsafe { ::std::mem::transmute(hasVicEntries) };
            hasVicEntries as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hasInterlacedLatencyField: u8 =
                unsafe { ::std::mem::transmute(hasInterlacedLatencyField) };
            hasInterlacedLatencyField as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hasLatencyField: u8 = unsafe { ::std::mem::transmute(hasLatencyField) };
            hasLatencyField as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn reserved13(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn has3dEntries(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_has3dEntries(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hdmi3dLength(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(8usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_hdmi3dLength(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hdmiVicLength(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(13usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_hdmiVicLength(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        reserved13: NvU8,
        has3dEntries: NvU8,
        hdmi3dLength: NvU8,
        hdmiVicLength: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved13: u8 = unsafe { ::std::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has3dEntries: u8 = unsafe { ::std::mem::transmute(has3dEntries) };
            has3dEntries as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let hdmi3dLength: u8 = unsafe { ::std::mem::transmute(hdmi3dLength) };
            hdmi3dLength as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let hdmiVicLength: u8 = unsafe { ::std::mem::transmute(hdmiVicLength) };
            hdmiVicLength as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! See NvAPI_DISP_GetMonitorCapabilities()."]
pub type NV_MONITOR_CAPS_VSDB = _NV_MONITOR_CAPS_VSDB;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MONITOR_CAPS_GENERIC {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout__NV_MONITOR_CAPS_GENERIC() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MONITOR_CAPS_GENERIC>(),
        1usize,
        concat!("Size of: ", stringify!(_NV_MONITOR_CAPS_GENERIC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MONITOR_CAPS_GENERIC>(),
        1usize,
        concat!("Alignment of ", stringify!(_NV_MONITOR_CAPS_GENERIC))
    );
}
impl _NV_MONITOR_CAPS_GENERIC {
    #[inline]
    pub fn supportVRR(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportVRR(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportULMB(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportULMB(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTrueGsync(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isTrueGsync(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isRLACapable(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isRLACapable(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn currentlyCapableOfVRR(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_currentlyCapableOfVRR(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supportVRR: NvU8,
        supportULMB: NvU8,
        isTrueGsync: NvU8,
        isRLACapable: NvU8,
        currentlyCapableOfVRR: NvU8,
        reserved: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supportVRR: u8 = unsafe { ::std::mem::transmute(supportVRR) };
            supportVRR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let supportULMB: u8 = unsafe { ::std::mem::transmute(supportULMB) };
            supportULMB as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isTrueGsync: u8 = unsafe { ::std::mem::transmute(isTrueGsync) };
            isTrueGsync as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isRLACapable: u8 = unsafe { ::std::mem::transmute(isRLACapable) };
            isRLACapable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let currentlyCapableOfVRR: u8 = unsafe { ::std::mem::transmute(currentlyCapableOfVRR) };
            currentlyCapableOfVRR as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MONITOR_CAPS_GENERIC = _NV_MONITOR_CAPS_GENERIC;
#[doc = "! See NvAPI_DISP_GetMonitorCapabilities()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MONITOR_CAPABILITIES_V1 {
    pub version: NvU32,
    pub size: NvU16,
    pub infoType: NvU32,
    #[doc = "!< Out: VGA, TV, DVI, HDMI, DP"]
    pub connectorType: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub data: _NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1 {
    pub vsdb: NV_MONITOR_CAPS_VSDB,
    pub vcdb: NV_MONITOR_CAPS_VCDB,
    pub caps: NV_MONITOR_CAPS_GENERIC,
}
#[test]
fn bindgen_test_layout__NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1>(),
        49usize,
        concat!(
            "Size of: ",
            stringify!(_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsdb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(vsdb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcdb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(vcdb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1),
            "::",
            stringify!(caps)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_MONITOR_CAPABILITIES_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MONITOR_CAPABILITIES_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MONITOR_CAPABILITIES_V1>(),
        68usize,
        concat!("Size of: ", stringify!(_NV_MONITOR_CAPABILITIES_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MONITOR_CAPABILITIES_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MONITOR_CAPABILITIES_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPABILITIES_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPABILITIES_V1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).infoType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPABILITIES_V1),
            "::",
            stringify!(infoType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connectorType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPABILITIES_V1),
            "::",
            stringify!(connectorType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_CAPABILITIES_V1),
            "::",
            stringify!(data)
        )
    );
}
impl _NV_MONITOR_CAPABILITIES_V1 {
    #[inline]
    pub fn bIsValidInfo(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bIsValidInfo(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bIsValidInfo: NvU8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsValidInfo: u8 = unsafe { ::std::mem::transmute(bIsValidInfo) };
            bIsValidInfo as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! See NvAPI_DISP_GetMonitorCapabilities()."]
pub type NV_MONITOR_CAPABILITIES_V1 = _NV_MONITOR_CAPABILITIES_V1;
#[doc = "! See NvAPI_DISP_GetMonitorCapabilities()."]
pub type NV_MONITOR_CAPABILITIES = NV_MONITOR_CAPABILITIES_V1;
extern "C" {
    #[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! \\ingroup dispcontrol"]
    pub fn NvAPI_DISP_GetMonitorCapabilities(
        displayId: NvU32,
        pMonitorCapabilities: *mut NV_MONITOR_CAPABILITIES,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MONITOR_COLOR_DATA {
    pub version: NvU32,
    #[doc = "!< One of the supported color formats"]
    pub colorFormat: NV_DP_COLOR_FORMAT,
    #[doc = "!< One of the supported bit depths"]
    pub backendBitDepths: NV_DP_BPC,
}
#[test]
fn bindgen_test_layout__NV_MONITOR_COLOR_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MONITOR_COLOR_DATA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MONITOR_COLOR_DATA>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_MONITOR_COLOR_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MONITOR_COLOR_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MONITOR_COLOR_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_COLOR_DATA),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_COLOR_DATA),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backendBitDepths) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MONITOR_COLOR_DATA),
            "::",
            stringify!(backendBitDepths)
        )
    );
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_MONITOR_COLOR_CAPS_V1 = _NV_MONITOR_COLOR_DATA;
#[doc = "! \\ingroup dispcontrol"]
pub type NV_MONITOR_COLOR_CAPS = NV_MONITOR_COLOR_CAPS_V1;
extern "C" {
    #[doc = "! DESCRIPTION:    This API returns all the color formats and bit depth values supported by a given DP monitor.\n!\n! USAGE:         Sequence of calls which caller should make to get the information.\n!                1. First call NvAPI_DISP_GetMonitorColorCapabilities() with pMonitorColorCapabilities as NULL to get the count.\n!                2. Allocate memory for color caps(NV_MONITOR_COLOR_CAPS) array.\n!                3. Call NvAPI_DISP_GetMonitorColorCapabilities() again with the pointer to the memory allocated to get all the\n!                   color capabilities.\n!\n!                Note :\n!                1. pColorCapsCount should never be NULL, else the API will fail with NVAPI_INVALID_ARGUMENT.\n!                2. *pColorCapsCount returned from the API will always be the actual count in any/every call.\n!                3. Memory size to be allocated should be (*pColorCapsCount * sizeof(NV_MONITOR_COLOR_CAPS)).\n!                4. If the memory allocated is less than what is required to return all the timings, this API will return the\n!                   amount of information which can fit in user provided buffer and API will return NVAPI_INSUFFICIENT_BUFFER.\n!                5. If the caller specifies a greater value for *pColorCapsCount in second call to NvAPI_DISP_GetMonitorColorCapabilities()\n!                   than what was returned from first call, the API will return only the actual number of elements in the color\n!                   capabilities array and the extra buffer will remain unused.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]      displayId                  Monitor Identifier\n! \\param [in, out] pMonitorColorCapabilities  The monitor color capabilities information\n! \\param [in, out] pColorCapsCount            - During input, the number of elements allocated for the pMonitorColorCapabilities pointer\n!                                             - During output, the actual number of color data elements the monitor supports\n!\n! \\return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!            specific meaning for this API, they are listed below.\n!\n! \\retval         NVAPI_INSUFFICIENT_BUFFER   The input buffer size is not sufficient to hold the total contents. In this case\n!                                             *pColorCapsCount will hold the required amount of elements.\n! \\retval         NVAPI_INVALID_DISPLAY_ID    The input monitor is either not connected or is not a DP panel.\n!\n! \\ingroup dispcontrol\n!\n"]
    pub fn NvAPI_DISP_GetMonitorColorCapabilities(
        displayId: NvU32,
        pMonitorColorCapabilities: *mut NV_MONITOR_COLOR_CAPS,
        pColorCapsCount: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol\n! Used in NvAPI_DISP_EnumCustomDisplay() and NvAPI_DISP_TryCustomDisplay()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_CUSTOM_DISPLAY {
    pub version: NvU32,
    #[doc = "!< Source surface(source mode) width"]
    pub width: NvU32,
    #[doc = "!< Source surface(source mode) height"]
    pub height: NvU32,
    #[doc = "!< Source surface color depth.\"0\" means all 8/16/32bpp"]
    pub depth: NvU32,
    #[doc = "!< Color format (optional)"]
    pub colorFormat: NV_FORMAT,
    #[doc = "!< For multimon support, should be set to (0,0,1.0,1.0) for now."]
    pub srcPartition: NV_VIEWPORTF,
    #[doc = "!< Horizontal scaling ratio"]
    pub xRatio: f32,
    #[doc = "!< Vertical scaling ratio"]
    pub yRatio: f32,
    #[doc = "!< Timing used to program TMDS/DAC/LVDS/HDMI/TVEncoder, etc."]
    pub timing: NV_TIMING,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_NV_CUSTOM_DISPLAY() {
    const UNINIT: ::std::mem::MaybeUninit<NV_CUSTOM_DISPLAY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_CUSTOM_DISPLAY>(),
        144usize,
        concat!("Size of: ", stringify!(NV_CUSTOM_DISPLAY))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_CUSTOM_DISPLAY>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_CUSTOM_DISPLAY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CUSTOM_DISPLAY),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CUSTOM_DISPLAY),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CUSTOM_DISPLAY),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CUSTOM_DISPLAY),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CUSTOM_DISPLAY),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcPartition) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CUSTOM_DISPLAY),
            "::",
            stringify!(srcPartition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xRatio) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CUSTOM_DISPLAY),
            "::",
            stringify!(xRatio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yRatio) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CUSTOM_DISPLAY),
            "::",
            stringify!(yRatio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timing) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CUSTOM_DISPLAY),
            "::",
            stringify!(timing)
        )
    );
}
impl NV_CUSTOM_DISPLAY {
    #[inline]
    pub fn hwModeSetOnly(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hwModeSetOnly(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(hwModeSetOnly: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hwModeSetOnly: u32 = unsafe { ::std::mem::transmute(hwModeSetOnly) };
            hwModeSetOnly as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = "! DESCRIPTION:    This API enumerates the custom timing specified by the enum index.\n!                 The client should keep enumerating until it returns NVAPI_END_ENUMERATION.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n! \\param [in]     displayId   Dispaly ID of the display.\n! \\param [in]     index       Enum index\n! \\param [inout]  pCustDisp   Pointer to the NV_CUSTOM_DISPLAY structure\n!\n! \\return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!                specific meaning for this API, they are listed below.\n! \\retval        NVAPI_INVALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DISP_EnumCustomDisplay(
        displayId: NvU32,
        index: NvU32,
        pCustDisp: *mut NV_CUSTOM_DISPLAY,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This API is used to set up a custom display without saving the configuration on multiple displays.\n!\n! \\note\n!  All the members of srcPartition, present in NV_CUSTOM_DISPLAY structure, should have their range in (0.0,1.0).\n!  In clone mode the timings can applied to both the target monitors but only one target at a time. \\n\n!  For the secondary target the applied timings works under the following conditions:\n!  - If the secondary monitor EDID supports the selected timing, OR\n!  - If the selected custom timings can be scaled by the secondary monitor for the selected source resolution on the primary, OR\n!  - If the selected custom timings matches the existing source resolution on the primary.\n!  Setting up a custom display on non-active but connected monitors is supported only for Win7 and above.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n!\n! \\param [in]    pDisplayIds    Array of the target display Dispaly IDs - See \\ref handles.\n! \\param [in]    count          Total number of the incoming Display IDs and corresponding NV_CUSTOM_DISPLAY structure. This is for the multi-head support.\n! \\param [in]    pCustDisp      Pointer to the NV_CUSTOM_DISPLAY structure array.\n!\n! \\return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!                specific meaning for this API, they are listed below.\n! \\retval        NVAPI_INVALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DISP_TryCustomDisplay(
        pDisplayIds: *mut NvU32,
        count: NvU32,
        pCustDisp: *mut NV_CUSTOM_DISPLAY,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This function deletes the custom display configuration, specified from the registry for  all the displays whose display IDs are passed.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n!\n! \\param [in]     pDisplayIds     Array of Dispaly IDs on which custom display configuration is to be saved.\n! \\param [in]     count           Total number of the incoming Dispaly IDs. This is for the multi-head support.\n! \\param [in]     pCustDisp       Pointer to the NV_CUSTOM_DISPLAY structure\n!\n! \\return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!                specific meaning for this API, they are listed below.\n! \\retval        NVAPI_INVALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DISP_DeleteCustomDisplay(
        pDisplayIds: *mut NvU32,
        count: NvU32,
        pCustDisp: *mut NV_CUSTOM_DISPLAY,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This function saves the current hardware display configuration on the specified Display IDs as a custom display configuration.\n!                 This function should be called right after NvAPI_DISP_TryCustomDisplay() to save the custom display from the current\n!                 hardware context. This function will not do anything if the custom display configuration is not tested on the hardware.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n!\n! \\param [in]     pDisplayIds         Array of Dispaly IDs on which custom display configuration is to be saved.\n! \\param [in]     count               Total number of the incoming Dispaly IDs. This is for the multi-head support.\n! \\param [in]     isThisOutputIdOnly  If set, the saved custom display will only be applied on the monitor with the same outputId (see \\ref handles).\n! \\param [in]     isThisMonitorIdOnly If set, the saved custom display will only be applied on the monitor with the same EDID ID or\n!                                     the same TV connector in case of analog TV.\n!\n! \\return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!                specific meaning for this API, they are listed below.\n! \\retval        NVAPI_INVALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DISP_SaveCustomDisplay(
        pDisplayIds: *mut NvU32,
        count: NvU32,
        isThisOutputIdOnly: NvU32,
        isThisMonitorIdOnly: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This API is used to restore the display configuration, that was changed by calling NvAPI_DISP_TryCustomDisplay(). This function\n!                 must be called only after a custom display configuration is tested on the hardware, using NvAPI_DISP_TryCustomDisplay(),\n!                 otherwise no action is taken. On Vista, NvAPI_DISP_RevertCustomDisplayTrial should be called with an active display that\n!                 was affected during the NvAPI_DISP_TryCustomDisplay() call, per GPU.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n!\n! \\param [in]    pDisplayIds   Pointer to display Id, of an active display.\n! \\param [in]    count         Total number of incoming Display IDs. For future use only. Currently it is expected to be passed as 1.\n!\n! \\return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!                specific meaning for this API, they are listed below.\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DISP_RevertCustomDisplayTrial(
        pDisplayIds: *mut NvU32,
        count: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! This API lets caller retrieve the target display arrangement for selected source display handle.\n! \\note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW.\n!       Use NvAPI_SYS_GetDisplayTopologies() to query views across GPUs.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_GetDisplayConfig.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 85\n!\n!  \\param [in]     hNvDisplay             NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from\n!                                         NvAPI_EnumNVidiaDisplayHandle().\n!  \\param [out]    pTargets               User allocated storage to retrieve an array of  NV_VIEW_TARGET_INFO. Can be NULL to retrieve\n!                                         the targetCount.\n!  \\param [in,out] targetMaskCount        Count of target device mask specified in pTargetMask.\n!  \\param [out]    targetView             Target view selected from NV_TARGET_VIEW_MODE.\n!\n!  \\retval         NVAPI_OK               Completed request\n!  \\retval         NVAPI_ERROR            Miscellaneous error occurred\n!  \\retval         NVAPI_INVALID_ARGUMENT Invalid input parameter.\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_GetView(
        hNvDisplay: NvDisplayHandle,
        pTargets: *mut NV_VIEW_TARGET_INFO,
        pTargetMaskCount: *mut NvU32,
        pTargetView: *mut NV_TARGET_VIEW_MODE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This API lets caller retrieve the target display arrangement for selected source display handle.\n!                 \\note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW.\n!                       Use NvAPI_SYS_GetDisplayTopologies() to query views across GPUs.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_GetDisplayConfig.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 165\n!\n! \\param [in]     hNvDisplay       NVIDIA Display selection. #NVAPI_DEFAULT_HANDLE is not allowed, it has to be a handle enumerated with\n!                                  NvAPI_EnumNVidiaDisplayHandle().\n! \\param [in,out] pPathInfo        Count field should be set to NVAPI_MAX_DISPLAY_PATH. Can be NULL to retrieve just the pathCount.\n! \\param [in,out] pPathCount       Number of elements in array pPathInfo->path.\n! \\param [out]    pTargetViewMode  Display view selected from NV_TARGET_VIEW_MODE.\n!\n! \\retval         NVAPI_OK                      Completed request\n! \\retval         NVAPI_API_NOT_INTIALIZED      NVAPI not initialized\n! \\retval         NVAPI_ERROR                   Miscellaneous error occurred\n! \\retval         NVAPI_INVALID_ARGUMENT        Invalid input parameter.\n! \\retval         NVAPI_EXPECTED_DISPLAY_HANDLE hNvDisplay is not a valid display handle.\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_GetViewEx(
        hNvDisplay: NvDisplayHandle,
        pPathInfo: *mut NV_DISPLAY_PATH_INFO,
        pPathCount: *mut NvU32,
        pTargetViewMode: *mut NV_TARGET_VIEW_MODE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!  This API lets caller enumerate all the supported NVIDIA display views - nView and Dualview modes.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 85\n!\n!  \\param [in]     hNvDisplay             NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from\n!                                         NvAPI_EnumNVidiaDisplayHandle().\n!  \\param [out]    pTargetViews           Array of supported views. Can be NULL to retrieve the pViewCount first.\n!  \\param [in,out] pViewCount             Count of supported views.\n!\n!  \\retval         NVAPI_OK               Completed request\n!  \\retval         NVAPI_ERROR            Miscellaneous error occurred\n!  \\retval         NVAPI_INVALID_ARGUMENT Invalid input parameter.\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_GetSupportedViews(
        hNvDisplay: NvDisplayHandle,
        pTargetViews: *mut NV_TARGET_VIEW_MODE,
        pViewCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API retrieves the Display Id of a given display by\n!                  display name. The display must be active to retrieve the\n!                  displayId. In the case of clone mode or Surround gaming,\n!                  the primary or top-left display will be returned.\n!\n! \\param [in]     displayName  Name of display (Eg: \"\\\\DISPLAY1\" to\n!                              retrieve the displayId for.\n! \\param [out]    displayId    Display ID of the requested display.\n!\n! retval ::NVAPI_OK:                          Capabilties have been returned.\n! retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.\n! retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first\n! retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available\n! retval ::NVAPI_ERROR:                       Miscellaneous error occurred\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DISP_GetDisplayIdByDisplayName(
        displayName: *const ::std::os::raw::c_char,
        displayId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API lets caller retrieve the current global display\n!                  configuration.\n!       USAGE:     The caller might have to call this three times to fetch all the required configuration details as follows:\n!                  First  Pass: Caller should Call NvAPI_DISP_GetDisplayConfig() with pathInfo set to NULL to fetch pathInfoCount.\n!                  Second Pass: Allocate memory for pathInfo with respect to the number of pathInfoCount(from First Pass) to fetch\n!                               targetInfoCount. If sourceModeInfo is needed allocate memory or it can be initialized to NULL.\n!             Third  Pass(Optional, only required if target information is required): Allocate memory for targetInfo with respect\n!                               to number of targetInfoCount(from Second Pass).\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in,out]  pathInfoCount    Number of elements in pathInfo array, returns number of valid topologies, this cannot be null.\n! \\param [in,out]  pathInfo         Array of path information\n!\n! \\return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with\n!            specific meaning for this API, they are listed below.\n!\n! \\retval    NVAPI_INVALID_ARGUMENT  -   Invalid input parameter. Following can be the reason for this return value:\n!                                        -# pathInfoCount is NULL.\n!                                        -# *pathInfoCount is 0 and pathInfo is not NULL.\n!                                        -# *pathInfoCount is not 0 and pathInfo is NULL.\n! \\retval    NVAPI_DEVICE_BUSY       -   ModeSet has not yet completed. Please wait and call it again.\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DISP_GetDisplayConfig(
        pathInfoCount: *mut NvU32,
        pathInfo: *mut NV_DISPLAYCONFIG_PATH_INFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API lets caller apply a global display configuration\n!                  across multiple GPUs.\n!\n!                  If all sourceIds are zero, then NvAPI will pick up sourceId's based on the following criteria :\n!                  - If user provides sourceModeInfo then we are trying to assign 0th sourceId always to GDIPrimary.\n!                     This is needed since active windows always moves along with 0th sourceId.\n!                  - For rest of the paths, we are incrementally assigning the sourceId per adapter basis.\n!                  - If user doesn't provide sourceModeInfo then NVAPI just picks up some default sourceId's in incremental order.\n!                  Note : NVAPI will not intelligently choose the sourceIDs for any configs that does not need a modeset.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]      pathInfoCount   Number of supplied elements in pathInfo\n! \\param [in]      pathInfo        Array of path information\n! \\param [in]      flags           A bitwise OR of supported flags from NV_DISPLAYCONFIG_FLAGS.\n!\n! \\retval ::NVAPI_OK - completed request\n! \\retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized\n! \\retval ::NVAPI_ERROR - miscellaneous error occurred\n! \\retval ::NVAPI_INVALID_ARGUMENT - Invalid input parameter.\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DISP_SetDisplayConfig(
        pathInfoCount: NvU32,
        pathInfo: *mut NV_DISPLAYCONFIG_PATH_INFO,
        flags: NvU32,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GET_ADAPTIVE_SYNC_DATA_V1 {
    #[doc = "!< [in]    structure version"]
    pub version: NvU32,
    #[doc = "!< [out]   maximum frame interval in micro seconds as set previously using NvAPI_DISP_SetAdaptiveSyncData function.\n!<         If default values from EDID are used, this parameter returns 0."]
    pub maxFrameInterval: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< [out]   Number of times the last flip was shown on the screen"]
    pub lastFlipRefreshCount: NvU32,
    #[doc = "!< [out]   Timestamp for the lastest flip on the screen"]
    pub lastFlipTimeStamp: NvU64,
    #[doc = "!< reserved for future use."]
    pub reservedEx: [NvU32; 4usize],
}
#[test]
fn bindgen_test_layout__NV_GET_ADAPTIVE_SYNC_DATA_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GET_ADAPTIVE_SYNC_DATA_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GET_ADAPTIVE_SYNC_DATA_V1>(),
        40usize,
        concat!("Size of: ", stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GET_ADAPTIVE_SYNC_DATA_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxFrameInterval) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1),
            "::",
            stringify!(maxFrameInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastFlipRefreshCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1),
            "::",
            stringify!(lastFlipRefreshCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastFlipTimeStamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1),
            "::",
            stringify!(lastFlipTimeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedEx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_ADAPTIVE_SYNC_DATA_V1),
            "::",
            stringify!(reservedEx)
        )
    );
}
impl _NV_GET_ADAPTIVE_SYNC_DATA_V1 {
    #[inline]
    pub fn bDisableAdaptiveSync(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisableAdaptiveSync(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bDisableFrameSplitting(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisableFrameSplitting(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bDisableAdaptiveSync: NvU32,
        bDisableFrameSplitting: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bDisableAdaptiveSync: u32 = unsafe { ::std::mem::transmute(bDisableAdaptiveSync) };
            bDisableAdaptiveSync as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bDisableFrameSplitting: u32 =
                unsafe { ::std::mem::transmute(bDisableFrameSplitting) };
            bDisableFrameSplitting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GET_ADAPTIVE_SYNC_DATA_V1 = _NV_GET_ADAPTIVE_SYNC_DATA_V1;
pub type NV_GET_ADAPTIVE_SYNC_DATA = NV_GET_ADAPTIVE_SYNC_DATA_V1;
extern "C" {
    #[doc = "! \\fn NvAPI_DISP_GetAdaptiveSyncData(__in NvU32 displayId, __inout NV_GET_ADAPTIVE_SYNC_DATA *pAdaptiveSyncData)\n! \\code\n! DESCRIPTION:    This function is used to get data for the Adaptive Sync Display.\n!\n! SUPPORTED OS:  Windows 10 and higher\n!\n! \\since Release: 415\n!\n! \\param [in]       displayId            - display id of the display\n! \\param [inout]    pAdaptiveSyncData    - A pointer to NV_GET_ADAPTIVE_SYNC_DATA, containing the information about the values of parameters that are to be retrieved on given display.\n!\n! \\return  This API can return any of the error codes enumerated in\n!          #NvAPI_Status. If there are return error codes with specific\n!          meaning for this API, they are listed below.\n!\n! \\endcode\n\n! \\ingroup dispcontrol"]
    pub fn NvAPI_DISP_GetAdaptiveSyncData(
        displayId: NvU32,
        pAdaptiveSyncData: *mut NV_GET_ADAPTIVE_SYNC_DATA,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_SET_ADAPTIVE_SYNC_DATA_V1 {
    #[doc = "!< [in]    structure version"]
    pub version: NvU32,
    #[doc = "!< [in]    maximum frame interval in micro seconds.\n!<         If maxFrameInterval is send as 0, default values from EDID will be used."]
    pub maxFrameInterval: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< reserved for future use."]
    pub reservedEx: [NvU32; 7usize],
}
#[test]
fn bindgen_test_layout__NV_SET_ADAPTIVE_SYNC_DATA_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_SET_ADAPTIVE_SYNC_DATA_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_SET_ADAPTIVE_SYNC_DATA_V1>(),
        40usize,
        concat!("Size of: ", stringify!(_NV_SET_ADAPTIVE_SYNC_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SET_ADAPTIVE_SYNC_DATA_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_SET_ADAPTIVE_SYNC_DATA_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_ADAPTIVE_SYNC_DATA_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxFrameInterval) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_ADAPTIVE_SYNC_DATA_V1),
            "::",
            stringify!(maxFrameInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedEx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_ADAPTIVE_SYNC_DATA_V1),
            "::",
            stringify!(reservedEx)
        )
    );
}
impl _NV_SET_ADAPTIVE_SYNC_DATA_V1 {
    #[inline]
    pub fn bDisableAdaptiveSync(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisableAdaptiveSync(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bDisableFrameSplitting(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisableFrameSplitting(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bDisableAdaptiveSync: NvU32,
        bDisableFrameSplitting: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bDisableAdaptiveSync: u32 = unsafe { ::std::mem::transmute(bDisableAdaptiveSync) };
            bDisableAdaptiveSync as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bDisableFrameSplitting: u32 =
                unsafe { ::std::mem::transmute(bDisableFrameSplitting) };
            bDisableFrameSplitting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_SET_ADAPTIVE_SYNC_DATA_V1 = _NV_SET_ADAPTIVE_SYNC_DATA_V1;
pub type NV_SET_ADAPTIVE_SYNC_DATA = NV_SET_ADAPTIVE_SYNC_DATA_V1;
extern "C" {
    #[doc = "! \\fn NvAPI_DISP_SetAdaptiveSyncData(__in NvU32 displayId, __in NV_SET_ADAPTIVE_SYNC_DATA *pAdaptiveSyncData)\n! \\code\n! DESCRIPTION:    This function is used to set data for Adaptive Sync Display.\n!\n! SUPPORTED OS:  Windows 10 and higher\n!\n! \\since Release: 415\n!\n! \\param [in]       displayId            - display id of the display\n! \\param [in]       pAdaptiveSyncData    - A pointer to NV_SET_ADAPTIVE_SYNC_DATA, containing the information about the values of parameters that are to be set on given display.\n!\n! \\return  This API can return any of the error codes enumerated in\n!          #NvAPI_Status. If there are return error codes with specific\n!          meaning for this API, they are listed below.\n!\n! \\endcode\n\n! \\ingroup dispcontrol"]
    pub fn NvAPI_DISP_SetAdaptiveSyncData(
        displayId: NvU32,
        pAdaptiveSyncData: *mut NV_SET_ADAPTIVE_SYNC_DATA,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1 {
    #[doc = "!< [in]    structure version"]
    pub version: NvU32,
    #[doc = "!< [out]   frame interval in micro seconds if Virtual RR is currently applied"]
    pub frameIntervalUs: NvU32,
    #[doc = "!< reserved for future use."]
    pub reservedEx: [NvU32; 8usize],
}
#[test]
fn bindgen_test_layout__NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameIntervalUs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1),
            "::",
            stringify!(frameIntervalUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedEx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1),
            "::",
            stringify!(reservedEx)
        )
    );
}
pub type NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1 = _NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1;
pub type NV_GET_VIRTUAL_REFRESH_RATE_DATA = NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1;
extern "C" {
    #[doc = "! \\fn NvAPI_DISP_GetVirtualRefreshRateData(__in NvU32 displayId, __inout NV_GET_VIRTUAL_REFRESH_RATE_DATA *pVirtualRefreshRateData)\n! \\code\n! DESCRIPTION:    This function is used to get Virtual Refresh Rate data for a VRR Capable Display.\n!\n! SUPPORTED OS:  Windows 10 and higher\n!\n! \\since Release: 510\n!\n! \\param [in]       displayId                  - display id of the display\n! \\param [inout]    pVirtualRefreshRateData    - A pointer to NV_GET_VIRTUAL_REFRESH_RATE_DATA, containing the information about the values of parameters that are to be retrieved on given display.\n!\n! \\return  This API can return any of the error codes enumerated in\n!          #NvAPI_Status. If there are return error codes with specific\n!          meaning for this API, they are listed below.\n!\n! \\endcode\n\n! \\ingroup dispcontrol"]
    pub fn NvAPI_DISP_GetVirtualRefreshRateData(
        displayId: NvU32,
        pVirtualRefreshRateData: *mut NV_GET_VIRTUAL_REFRESH_RATE_DATA,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1 {
    #[doc = "!< [in]   structure version"]
    pub version: NvU32,
    #[doc = "!< [in]   frame interval in micro seconds if Virtual RR is currently applied"]
    pub frameIntervalUs: NvU32,
    #[doc = "!< reserved for future use."]
    pub reservedEx: [NvU32; 8usize],
}
#[test]
fn bindgen_test_layout__NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameIntervalUs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1),
            "::",
            stringify!(frameIntervalUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedEx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1),
            "::",
            stringify!(reservedEx)
        )
    );
}
pub type NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1 = _NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1;
pub type NV_SET_VIRTUAL_REFRESH_RATE_DATA = NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1;
extern "C" {
    #[doc = "! \\fn NvAPI_DISP_SetVirtualRefreshRateData(__in NvU32 displayId, __in NV_SET_VIRTUAL_REFRESH_RATE_DATA *pVirtualRefreshRateData)\n! \\code\n! DESCRIPTION:    This function is used to set Virtual Refresh Rate data for a VRR Capable Display.\n!\n! SUPPORTED OS:  Windows 10 and higher\n!\n! \\since Release: 510\n!\n! \\param [in]       displayId                  - display id of the display\n! \\param [inout]    pVirtualRefreshRateData    - A pointer to NV_SET_VIRTUAL_REFRESH_RATE_DATA, containing the information about the values of parameters that are to be retrieved on given display.\n!\n! \\return  This API can return any of the error codes enumerated in\n!          #NvAPI_Status. If there are return error codes with specific\n!          meaning for this API, they are listed below.\n!\n! \\endcode\n\n! \\ingroup dispcontrol"]
    pub fn NvAPI_DISP_SetVirtualRefreshRateData(
        displayId: NvU32,
        pVirtualRefreshRateData: *mut NV_SET_VIRTUAL_REFRESH_RATE_DATA,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_SET_PREFERRED_STEREO_DISPLAY_V1 {
    #[doc = "!< [in] Structure version"]
    pub version: NvU32,
    #[doc = "!< [in] Monitor Identifier to be set"]
    pub displayId: NvU32,
    #[doc = "!< Reserved for future use without adding versioning"]
    pub reserved: NvU32,
}
#[test]
fn bindgen_test_layout_NV_SET_PREFERRED_STEREO_DISPLAY_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_SET_PREFERRED_STEREO_DISPLAY_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_SET_PREFERRED_STEREO_DISPLAY_V1>(),
        12usize,
        concat!("Size of: ", stringify!(NV_SET_PREFERRED_STEREO_DISPLAY_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_SET_PREFERRED_STEREO_DISPLAY_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_SET_PREFERRED_STEREO_DISPLAY_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SET_PREFERRED_STEREO_DISPLAY_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SET_PREFERRED_STEREO_DISPLAY_V1),
            "::",
            stringify!(displayId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_SET_PREFERRED_STEREO_DISPLAY_V1),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_SET_PREFERRED_STEREO_DISPLAY = NV_SET_PREFERRED_STEREO_DISPLAY_V1;
extern "C" {
    #[doc = "! DESCRIPTION: Specifies a display output that drives the 3pin DIN output signal\n!              in a workstation stereo system environment.\n!              If display output is specified as a displayId of 0, the preferred\n!              stereo display target is reset to the driver default selection.\n!\n! SUPPORTED OS:  Windows 10 and higher\n!\n! \\since Release: 470\n!\n! \\param [in]      pPreferredStereoDisplay        Pointer to a NV_SET_PREFERRED_STEREO_DISPLAY structure\n!\n! \\retval ::NVAPI_OK  completed request\n! \\retval ::NVAPI_ERROR  miscellaneous error occurred\n! \\retval ::NVAPI_INVALID_ARGUMENT  Invalid input parameter.\n! \\retval ::NVAPI_INVALID_USER_PRIVILEGE       - The application will require Administrator privileges to access this API.\n!                                                The application can be elevated to a higher permission level by selecting \"Run as Administrator\".\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DISP_SetPreferredStereoDisplay(
        pPreferredStereoDisplay: *mut NV_SET_PREFERRED_STEREO_DISPLAY,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_GET_PREFERRED_STEREO_DISPLAY_V1 {
    #[doc = "!< [in] Structure version"]
    pub version: NvU32,
    #[doc = "!< [out] The queried stereo display"]
    pub displayId: NvU32,
    #[doc = "!< Reserved for future use without adding versioning"]
    pub reserved: NvU32,
}
#[test]
fn bindgen_test_layout_NV_GET_PREFERRED_STEREO_DISPLAY_V1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_GET_PREFERRED_STEREO_DISPLAY_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_GET_PREFERRED_STEREO_DISPLAY_V1>(),
        12usize,
        concat!("Size of: ", stringify!(NV_GET_PREFERRED_STEREO_DISPLAY_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_GET_PREFERRED_STEREO_DISPLAY_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_GET_PREFERRED_STEREO_DISPLAY_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_PREFERRED_STEREO_DISPLAY_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_PREFERRED_STEREO_DISPLAY_V1),
            "::",
            stringify!(displayId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_GET_PREFERRED_STEREO_DISPLAY_V1),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_GET_PREFERRED_STEREO_DISPLAY = NV_GET_PREFERRED_STEREO_DISPLAY_V1;
extern "C" {
    #[doc = "! DESCRIPTION: Queries the displayId of the display output driving the 3pin\n!              DIN stereo signal, if any.\n! SUPPORTED OS:  Windows 10 and higher\n!\n! \\since Release: 470\n!\n! \\param [inout]     pPreferredStereoDisplay        Pointer to a NV_GET_PREFERRED_STEREO_DISPLAY structure\n!\n! \\retval ::NVAPI_OK  completed request\n! \\retval ::NVAPI_ERROR  miscellaneous error occurred\n! \\retval ::NVAPI_INVALID_ARGUMENT  Invalid input parameter.\n! \\retval ::NVAPI_INVALID_POINTER   An invalid pointer was passed as an argument (probably NULL).\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_DISP_GetPreferredStereoDisplay(
        pPreferredStereoDisplay: *mut NV_GET_PREFERRED_STEREO_DISPLAY,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup dispcontrol"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GET_VRR_INFO_V1 {
    #[doc = "!< [in]  Structure version"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!<       Reserved for future use"]
    pub reservedEx: [NvU32; 4usize],
}
#[test]
fn bindgen_test_layout__NV_GET_VRR_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GET_VRR_INFO_V1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GET_VRR_INFO_V1>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_GET_VRR_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GET_VRR_INFO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GET_VRR_INFO_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_VRR_INFO_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedEx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_VRR_INFO_V1),
            "::",
            stringify!(reservedEx)
        )
    );
}
impl _NV_GET_VRR_INFO_V1 {
    #[inline]
    pub fn bIsVRREnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsVRREnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsVRREnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsVRREnabled: u32 = unsafe { ::std::mem::transmute(bIsVRREnabled) };
            bIsVRREnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\ingroup dispcontrol"]
pub type NV_GET_VRR_INFO_V1 = _NV_GET_VRR_INFO_V1;
#[doc = "! \\ingroup dispcontrol"]
pub type NV_GET_VRR_INFO = NV_GET_VRR_INFO_V1;
extern "C" {
    #[doc = "! DESCRIPTION: This API returns Variable Refresh Rate(VRR) information for the given display ID.\n!\n! SUPPORTED OS:  Windows 10 and higher\n!\n!\n! \\since Release: 525\n!\n! \\param [inout] pVrrInfo       Pointer to the NV_GET_VRR_INFO structure.\n!\n! \\return     This API can return any of the error codes enumerated in #NvAPI_Status.\n!\n! \\ingroup dispcontrol\n"]
    pub fn NvAPI_Disp_GetVRRInfo(displayId: NvU32, pVrrInfo: *mut NV_GET_VRR_INFO) -> NvAPI_Status;
}
#[doc = "! This structure defines the topology details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_TOPO_DETAILS {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Logical GPU for this topology"]
    pub hLogicalGPU: NvLogicalGpuHandle,
    #[doc = "!< 0 means topology is valid with the current hardware."]
    pub validityMask: NvU32,
    #[doc = "!< Number of displays in a row"]
    pub rowCount: NvU32,
    #[doc = "!< Number of displays in a column"]
    pub colCount: NvU32,
    pub gpuLayout: [[NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1; 8usize]; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1 {
    #[doc = "!< Physical GPU to be used in the topology (0 if GPU missing)"]
    pub hPhysicalGPU: NvPhysicalGpuHandle,
    #[doc = "!< Connected display target (0 if no display connected)"]
    pub displayOutputId: NvU32,
    #[doc = "!< Pixels of overlap on left of target: (+overlap, -gap)"]
    pub overlapX: NvS32,
    #[doc = "!< Pixels of overlap on top of target: (+overlap, -gap)"]
    pub overlapY: NvS32,
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hPhysicalGPU) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1),
            "::",
            stringify!(hPhysicalGPU)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayOutputId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1),
            "::",
            stringify!(displayOutputId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlapX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1),
            "::",
            stringify!(overlapX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlapY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1),
            "::",
            stringify!(overlapY)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_TOPO_DETAILS() {
    const UNINIT: ::std::mem::MaybeUninit<NV_MOSAIC_TOPO_DETAILS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_TOPO_DETAILS>(),
        1568usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_TOPO_DETAILS))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_TOPO_DETAILS>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_TOPO_DETAILS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_DETAILS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hLogicalGPU) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_DETAILS),
            "::",
            stringify!(hLogicalGPU)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validityMask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_DETAILS),
            "::",
            stringify!(validityMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rowCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_DETAILS),
            "::",
            stringify!(rowCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_DETAILS),
            "::",
            stringify!(colCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuLayout) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_DETAILS),
            "::",
            stringify!(gpuLayout)
        )
    );
}
#[doc = "!< All mosaic topologies"]
pub const NV_MOSAIC_TOPO_TYPE_NV_MOSAIC_TOPO_TYPE_ALL: NV_MOSAIC_TOPO_TYPE = 0;
#[doc = "!< Basic Mosaic topologies"]
pub const NV_MOSAIC_TOPO_TYPE_NV_MOSAIC_TOPO_TYPE_BASIC: NV_MOSAIC_TOPO_TYPE = 1;
#[doc = "!< Passive Stereo topologies"]
pub const NV_MOSAIC_TOPO_TYPE_NV_MOSAIC_TOPO_TYPE_PASSIVE_STEREO: NV_MOSAIC_TOPO_TYPE = 2;
#[doc = "!< Not supported at this time"]
pub const NV_MOSAIC_TOPO_TYPE_NV_MOSAIC_TOPO_TYPE_SCALED_CLONE: NV_MOSAIC_TOPO_TYPE = 3;
#[doc = "!< Not supported at this time"]
pub const NV_MOSAIC_TOPO_TYPE_NV_MOSAIC_TOPO_TYPE_PASSIVE_STEREO_SCALED_CLONE: NV_MOSAIC_TOPO_TYPE =
    4;
#[doc = "!< Always leave this at end of the enum"]
pub const NV_MOSAIC_TOPO_TYPE_NV_MOSAIC_TOPO_TYPE_MAX: NV_MOSAIC_TOPO_TYPE = 5;
#[doc = "! These values refer to the different types of Mosaic topologies that are possible.  When\n! getting the supported Mosaic topologies, you can specify one of these types to narrow down\n! the returned list to only those that match the given type."]
pub type NV_MOSAIC_TOPO_TYPE = ::std::os::raw::c_int;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_NONE: NV_MOSAIC_TOPO = 0;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_BEGIN_BASIC: NV_MOSAIC_TOPO = 1;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x2_BASIC: NV_MOSAIC_TOPO = 1;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_2x1_BASIC: NV_MOSAIC_TOPO = 2;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x3_BASIC: NV_MOSAIC_TOPO = 3;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_3x1_BASIC: NV_MOSAIC_TOPO = 4;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x4_BASIC: NV_MOSAIC_TOPO = 5;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_4x1_BASIC: NV_MOSAIC_TOPO = 6;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_2x2_BASIC: NV_MOSAIC_TOPO = 7;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_2x3_BASIC: NV_MOSAIC_TOPO = 8;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_2x4_BASIC: NV_MOSAIC_TOPO = 9;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_3x2_BASIC: NV_MOSAIC_TOPO = 10;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_4x2_BASIC: NV_MOSAIC_TOPO = 11;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x5_BASIC: NV_MOSAIC_TOPO = 12;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x6_BASIC: NV_MOSAIC_TOPO = 13;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_7x1_BASIC: NV_MOSAIC_TOPO = 14;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_END_BASIC: NV_MOSAIC_TOPO = 23;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO: NV_MOSAIC_TOPO = 24;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x2_PASSIVE_STEREO: NV_MOSAIC_TOPO = 24;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_2x1_PASSIVE_STEREO: NV_MOSAIC_TOPO = 25;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x3_PASSIVE_STEREO: NV_MOSAIC_TOPO = 26;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_3x1_PASSIVE_STEREO: NV_MOSAIC_TOPO = 27;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_1x4_PASSIVE_STEREO: NV_MOSAIC_TOPO = 28;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_4x1_PASSIVE_STEREO: NV_MOSAIC_TOPO = 29;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_2x2_PASSIVE_STEREO: NV_MOSAIC_TOPO = 30;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_END_PASSIVE_STEREO: NV_MOSAIC_TOPO = 34;
pub const NV_MOSAIC_TOPO_NV_MOSAIC_TOPO_MAX: NV_MOSAIC_TOPO = 35;
#[doc = "! This is a complete list of supported Mosaic topologies.\n!\n! Using a \"Basic\" topology combines multiple monitors to create a single desktop.\n!\n! Using a \"Passive\" topology combines multiples monitors to create a passive stereo desktop.\n! In passive stereo, two identical topologies combine - one topology is used for the right eye and the other identical //! topology (targeting different displays) is used for the left eye.  \\n\n! NOTE: common\\inc\\nvEscDef.h shadows a couple PASSIVE_STEREO enums.  If this\n!       enum list changes and effects the value of NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO\n!       please update the corresponding value in nvEscDef.h"]
pub type NV_MOSAIC_TOPO = ::std::os::raw::c_int;
#[doc = "! This is a \"topology brief\" structure.  It tells you what you need to know about\n! a topology at a high level. A list of these is returned when you query for the\n! supported Mosaic information.\n!\n! If you need more detailed information about the topology, call\n! NvAPI_Mosaic_GetTopoGroup() with the topology value from this structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_TOPO_BRIEF {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< The topology"]
    pub topo: NV_MOSAIC_TOPO,
    #[doc = "!< 1 if topo is enabled, else 0"]
    pub enabled: NvU32,
    #[doc = "!< 1 if topo *can* be enabled, else 0"]
    pub isPossible: NvU32,
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_TOPO_BRIEF() {
    const UNINIT: ::std::mem::MaybeUninit<NV_MOSAIC_TOPO_BRIEF> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_TOPO_BRIEF>(),
        16usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_TOPO_BRIEF))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_TOPO_BRIEF>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_TOPO_BRIEF))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_BRIEF),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_BRIEF),
            "::",
            stringify!(topo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_BRIEF),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isPossible) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_BRIEF),
            "::",
            stringify!(isPossible)
        )
    );
}
#[doc = "! Basic per-display settings that are used in setting/getting the Mosaic mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_DISPLAY_SETTING_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Per-display width"]
    pub width: NvU32,
    #[doc = "!< Per-display height"]
    pub height: NvU32,
    #[doc = "!< Bits per pixel"]
    pub bpp: NvU32,
    #[doc = "!< Display frequency"]
    pub freq: NvU32,
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_DISPLAY_SETTING_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MOSAIC_DISPLAY_SETTING_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_DISPLAY_SETTING_V1>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_DISPLAY_SETTING_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpp) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_DISPLAY_SETTING_V1),
            "::",
            stringify!(freq)
        )
    );
}
#[doc = "! Basic per-display settings that are used in setting/getting the Mosaic mode"]
pub type NV_MOSAIC_DISPLAY_SETTING_V1 = _NV_MOSAIC_DISPLAY_SETTING_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_DISPLAY_SETTING_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Per-display width"]
    pub width: NvU32,
    #[doc = "!< Per-display height"]
    pub height: NvU32,
    #[doc = "!< Bits per pixel"]
    pub bpp: NvU32,
    #[doc = "!< Display frequency"]
    pub freq: NvU32,
    #[doc = "!< Display frequency in x1k"]
    pub rrx1k: NvU32,
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_DISPLAY_SETTING_V2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_MOSAIC_DISPLAY_SETTING_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_DISPLAY_SETTING_V2>(),
        24usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_DISPLAY_SETTING_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_DISPLAY_SETTING_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_DISPLAY_SETTING_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_SETTING_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_SETTING_V2),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_SETTING_V2),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpp) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_SETTING_V2),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_SETTING_V2),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrx1k) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_SETTING_V2),
            "::",
            stringify!(rrx1k)
        )
    );
}
pub type NV_MOSAIC_DISPLAY_SETTING = NV_MOSAIC_DISPLAY_SETTING_V2;
#[doc = "! This structure is used to contain a list of supported Mosaic topologies\n! along with the display settings that can be used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_SUPPORTED_TOPO_INFO_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Number of topologies in below array"]
    pub topoBriefsCount: NvU32,
    #[doc = "!< List of supported topologies with only brief details"]
    pub topoBriefs: [NV_MOSAIC_TOPO_BRIEF; 35usize],
    #[doc = "!< Number of display settings in below array"]
    pub displaySettingsCount: NvU32,
    #[doc = "!< List of per display settings possible"]
    pub displaySettings: [NV_MOSAIC_DISPLAY_SETTING_V1; 40usize],
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_SUPPORTED_TOPO_INFO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1>(),
        1372usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topoBriefsCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1),
            "::",
            stringify!(topoBriefsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topoBriefs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1),
            "::",
            stringify!(topoBriefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displaySettingsCount) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1),
            "::",
            stringify!(displaySettingsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displaySettings) as usize - ptr as usize },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V1),
            "::",
            stringify!(displaySettings)
        )
    );
}
#[doc = "! This structure is used to contain a list of supported Mosaic topologies\n! along with the display settings that can be used."]
pub type NV_MOSAIC_SUPPORTED_TOPO_INFO_V1 = _NV_MOSAIC_SUPPORTED_TOPO_INFO_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_SUPPORTED_TOPO_INFO_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Number of topologies in below array"]
    pub topoBriefsCount: NvU32,
    #[doc = "!< List of supported topologies with only brief details"]
    pub topoBriefs: [NV_MOSAIC_TOPO_BRIEF; 35usize],
    #[doc = "!< Number of display settings in below array"]
    pub displaySettingsCount: NvU32,
    #[doc = "!< List of per display settings possible"]
    pub displaySettings: [NV_MOSAIC_DISPLAY_SETTING_V2; 40usize],
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_SUPPORTED_TOPO_INFO_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2>(),
        1532usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topoBriefsCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2),
            "::",
            stringify!(topoBriefsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topoBriefs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2),
            "::",
            stringify!(topoBriefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displaySettingsCount) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2),
            "::",
            stringify!(displaySettingsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displaySettings) as usize - ptr as usize },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_SUPPORTED_TOPO_INFO_V2),
            "::",
            stringify!(displaySettings)
        )
    );
}
pub type NV_MOSAIC_SUPPORTED_TOPO_INFO_V2 = _NV_MOSAIC_SUPPORTED_TOPO_INFO_V2;
pub type NV_MOSAIC_SUPPORTED_TOPO_INFO = NV_MOSAIC_SUPPORTED_TOPO_INFO_V2;
#[doc = "! This structure defines a group of topologies that work together to create one\n! overall layout.  All of the supported topologies are represented with this\n! structure.\n!\n! For example, a 'Passive Stereo' topology would be represented with this\n! structure, and would have separate topology details for the left and right eyes.\n! The count would be 2.  A 'Basic' topology is also represented by this structure,\n! with a count of 1.\n!\n! The structure is primarily used internally, but is exposed to applications in a\n! read-only fashion because there are some details in it that might be useful\n! (like the number of rows/cols, or connected display information).  A user can\n! get the filled-in structure by calling NvAPI_Mosaic_GetTopoGroup().\n!\n! You can then look at the detailed values within the structure.  There are no\n! entrypoints which take this structure as input (effectively making it read-only)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_TOPO_GROUP {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< The brief details of this topo"]
    pub brief: NV_MOSAIC_TOPO_BRIEF,
    #[doc = "!< Number of topos in array below"]
    pub count: NvU32,
    pub topos: [NV_MOSAIC_TOPO_DETAILS; 2usize],
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_TOPO_GROUP() {
    const UNINIT: ::std::mem::MaybeUninit<NV_MOSAIC_TOPO_GROUP> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_TOPO_GROUP>(),
        3160usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_TOPO_GROUP))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_TOPO_GROUP>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_TOPO_GROUP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_GROUP),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).brief) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_GROUP),
            "::",
            stringify!(brief)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_GROUP),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topos) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPO_GROUP),
            "::",
            stringify!(topos)
        )
    );
}
extern "C" {
    #[doc = "! \\retval ::NVAPI_ERROR:                      Miscellaneous error occurred.\n!\n! \\ingroup mosaicapi\n"]
    pub fn NvAPI_Mosaic_GetSupportedTopoInfo(
        pSupportedTopoInfo: *mut NV_MOSAIC_SUPPORTED_TOPO_INFO,
        type_: NV_MOSAIC_TOPO_TYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\retval ::NVAPI_ERROR:                      Miscellaneous error occurred.\n!\n! \\ingroup mosaicapi\n"]
    pub fn NvAPI_Mosaic_GetTopoGroup(
        pTopoBrief: *mut NV_MOSAIC_TOPO_BRIEF,
        pTopoGroup: *mut NV_MOSAIC_TOPO_GROUP,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API returns the X and Y overlap limits required if\n!                  the given Mosaic topology and display settings are to be used.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 185\n!\n! \\param [in]   pTopoBrief          The topology for getting limits\n!                                   This must be one of the topo briefs\n!                                   returned from NvAPI_Mosaic_GetSupportedTopoInfo().\n! \\param [in]   pDisplaySetting     The display settings for getting the limits.\n!                                   This must be one of the settings\n!                                   returned from NvAPI_Mosaic_GetSupportedTopoInfo().\n! \\param [out]  pMinOverlapX        X overlap minimum\n! \\param [out]  pMaxOverlapX        X overlap maximum\n! \\param [out]  pMinOverlapY        Y overlap minimum\n! \\param [out]  pMaxOverlapY        Y overlap maximum\n!\n! \\retval ::NVAPI_OK                          Details were retrieved successfully.\n! \\retval ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.\n! \\retval ::NVAPI_INVALID_ARGUMENT            One or more argumentss passed in are invalid.\n! \\retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first.\n! \\retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available.\n! \\retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not\n!                                             compatible with this entry point.\n! \\retval ::NVAPI_ERROR                       Miscellaneous error occurred.\n!\n! \\ingroup mosaicapi\n"]
    pub fn NvAPI_Mosaic_GetOverlapLimits(
        pTopoBrief: *mut NV_MOSAIC_TOPO_BRIEF,
        pDisplaySetting: *mut NV_MOSAIC_DISPLAY_SETTING,
        pMinOverlapX: *mut NvS32,
        pMaxOverlapX: *mut NvS32,
        pMinOverlapY: *mut NvS32,
        pMaxOverlapY: *mut NvS32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API sets the Mosaic topology and performs a mode switch\n!                  using the given display settings.\n!\n!                  If NVAPI_OK is returned, the current Mosaic topology was set\n!                  correctly.  Any other status returned means the\n!                  topology was not set, and remains what it was before this\n!                  function was called.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 185\n!\n! \\param [in]     pTopoBrief        The topology to set. This must be one of the topologies returned from\n!                                   NvAPI_Mosaic_GetSupportedTopoInfo(), and it must have an isPossible value of 1.\n! \\param [in]     pDisplaySetting   The per display settings to be used in the Mosaic mode. This must be one of the\n!                                   settings returned from NvAPI_Mosaic_GetSupportedTopoInfo().\n! \\param [in]     overlapX          The pixel overlap to use between horizontal displays (use positive a number for\n!                                   overlap, or a negative number to create a gap.) If the overlap is out of bounds\n!                                   for what is possible given the topo and display setting, the overlap will be clamped.\n! \\param [in]     overlapY          The pixel overlap to use between vertical displays (use positive a number for\n!                                   overlap, or a negative number to create a gap.) If the overlap is out of bounds for\n!                                   what is possible given the topo and display setting, the overlap will be clamped.\n! \\param [in]     enable            If 1, the topology being set will also be enabled, meaning that the mode set will\n!                                   occur.  \\n\n!                                   If 0, you don't want to be in Mosaic mode right now, but want to set the current\n!                                   Mosaic topology so you can enable it later with NvAPI_Mosaic_EnableCurrentTopo().\n!\n! \\retval  ::NVAPI_OK                          The Mosaic topology was set.\n! \\retval  ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.\n! \\retval  ::NVAPI_INVALID_ARGUMENT            One or more argumentss passed in are invalid.\n! \\retval  ::NVAPI_TOPO_NOT_POSSIBLE           The topology passed in is not currently possible.\n! \\retval  ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first.\n! \\retval  ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available.\n! \\retval  ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not\n!                                              compatible with this entrypoint.\n! \\retval  ::NVAPI_MODE_CHANGE_FAILED          There was an error changing the display mode.\n! \\retval  ::NVAPI_ERROR                       Miscellaneous error occurred.\n!\n! \\ingroup mosaicapi\n"]
    pub fn NvAPI_Mosaic_SetCurrentTopo(
        pTopoBrief: *mut NV_MOSAIC_TOPO_BRIEF,
        pDisplaySetting: *mut NV_MOSAIC_DISPLAY_SETTING,
        overlapX: NvS32,
        overlapY: NvS32,
        enable: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API returns information for the current Mosaic topology.\n!                  This includes topology, display settings, and overlap values.\n!\n!                  You can call NvAPI_Mosaic_GetTopoGroup() with the topology\n!                  if you require more information.\n!\n!                  If there isn't a current topology, then pTopoBrief->topo will\n!                  be NV_MOSAIC_TOPO_NONE.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 185\n!\n! \\param [out]     pTopoBrief       The current Mosaic topology\n! \\param [out]     pDisplaySetting  The current per-display settings\n! \\param [out]     pOverlapX        The pixel overlap between horizontal displays\n! \\param [out]     pOverlapY        The pixel overlap between vertical displays\n!\n! \\retval ::NVAPI_OK                          Success getting current info.\n! \\retval ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.\n! \\retval ::NVAPI_INVALID_ARGUMENT            One or more argumentss passed in are invalid.\n! \\retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first.\n! \\retval ::NVAPI_NO_IMPLEMENTATION           This entry point not available.\n! \\retval ::NVAPI_ERROR                       Miscellaneous error occurred.\n!\n! \\ingroup mosaicapi\n"]
    pub fn NvAPI_Mosaic_GetCurrentTopo(
        pTopoBrief: *mut NV_MOSAIC_TOPO_BRIEF,
        pDisplaySetting: *mut NV_MOSAIC_DISPLAY_SETTING,
        pOverlapX: *mut NvS32,
        pOverlapY: *mut NvS32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API enables or disables the current Mosaic topology\n!                  based on the setting of the incoming 'enable' parameter.\n!\n!                  An \"enable\" setting enables the current (previously set) Mosaic topology.\n!                  Note that when the current Mosaic topology is retrieved, it must have an isPossible value of 1 or\n!                  an error will occur.\n!\n!                  A \"disable\" setting disables the current Mosaic topology.\n!                  The topology information will persist, even across reboots.\n!                  To re-enable the Mosaic topology, call this function\n!                  again with the enable parameter set to 1.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 185\n!\n! \\param [in]   enable               1 to enable the current Mosaic topo, 0 to disable it.\n!\n! \\retval ::NVAPI_OK                 The Mosaic topo was enabled/disabled.\n! \\retval ::NVAPI_NOT_SUPPORTED      Mosaic is not supported with the existing hardware.\n! \\retval ::NVAPI_INVALID_ARGUMENT   One or more arguments passed in are invalid.\n! \\retval ::NVAPI_TOPO_NOT_POSSIBLE  The current topology is not currently possible.\n! \\retval ::NVAPI_MODE_CHANGE_FAILED There was an error changing the display mode.\n! \\retval ::NVAPI_ERROR:             Miscellaneous error occurred.\n!\n! \\ingroup mosaicapi\n"]
    pub fn NvAPI_Mosaic_EnableCurrentTopo(enable: NvU32) -> NvAPI_Status;
}
#[doc = "! \\ingroup mosaicapi\n! @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V1 {
    #[doc = "!< DisplayID of the display"]
    pub displayId: NvU32,
    #[doc = "!< (+overlap, -gap)"]
    pub overlapX: NvS32,
    #[doc = "!< (+overlap, -gap)"]
    pub overlapY: NvS32,
    #[doc = "!< Rotation of display"]
    pub rotation: NV_ROTATE,
    #[doc = "!< Reserved, must be 0"]
    pub cloneGroup: NvU32,
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_GRID_TOPO_DISPLAY_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MOSAIC_GRID_TOPO_DISPLAY_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V1>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1),
            "::",
            stringify!(displayId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlapX) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1),
            "::",
            stringify!(overlapX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlapY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1),
            "::",
            stringify!(overlapY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cloneGroup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V1),
            "::",
            stringify!(cloneGroup)
        )
    );
}
#[doc = "! \\ingroup mosaicapi\n! @{"]
pub type NV_MOSAIC_GRID_TOPO_DISPLAY_V1 = _NV_MOSAIC_GRID_TOPO_DISPLAY_V1;
#[doc = "!< No pixel shift will be applied to this display."]
pub const _NV_PIXEL_SHIFT_TYPE_NV_PIXEL_SHIFT_TYPE_NO_PIXEL_SHIFT: _NV_PIXEL_SHIFT_TYPE = 0;
#[doc = "!< This display will be used to scanout top left pixels in 2x2 PixelShift configuration"]
pub const _NV_PIXEL_SHIFT_TYPE_NV_PIXEL_SHIFT_TYPE_2x2_TOP_LEFT_PIXELS: _NV_PIXEL_SHIFT_TYPE = 1;
#[doc = "!< This display will be used to scanout bottom right pixels in 2x2 PixelShift configuration"]
pub const _NV_PIXEL_SHIFT_TYPE_NV_PIXEL_SHIFT_TYPE_2x2_BOTTOM_RIGHT_PIXELS: _NV_PIXEL_SHIFT_TYPE =
    2;
#[doc = "!< This display will be used to scanout top right pixels in 2x2 PixelShift configuration"]
pub const _NV_PIXEL_SHIFT_TYPE_NV_PIXEL_SHIFT_TYPE_2x2_TOP_RIGHT_PIXELS: _NV_PIXEL_SHIFT_TYPE = 4;
#[doc = "!< This display will be used to scanout bottom left pixels in 2x2 PixelShift configuration"]
pub const _NV_PIXEL_SHIFT_TYPE_NV_PIXEL_SHIFT_TYPE_2x2_BOTTOM_LEFT_PIXELS: _NV_PIXEL_SHIFT_TYPE = 8;
pub type _NV_PIXEL_SHIFT_TYPE = ::std::os::raw::c_int;
pub use self::_NV_PIXEL_SHIFT_TYPE as NV_PIXEL_SHIFT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< DisplayID of the display"]
    pub displayId: NvU32,
    #[doc = "!< (+overlap, -gap)"]
    pub overlapX: NvS32,
    #[doc = "!< (+overlap, -gap)"]
    pub overlapY: NvS32,
    #[doc = "!< Rotation of display"]
    pub rotation: NV_ROTATE,
    #[doc = "!< Reserved, must be 0"]
    pub cloneGroup: NvU32,
    #[doc = "!< Type of the pixel shift enabled display"]
    pub pixelShiftType: NV_PIXEL_SHIFT_TYPE,
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_GRID_TOPO_DISPLAY_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MOSAIC_GRID_TOPO_DISPLAY_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V2>(),
        28usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_GRID_TOPO_DISPLAY_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
            "::",
            stringify!(displayId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlapX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
            "::",
            stringify!(overlapX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlapY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
            "::",
            stringify!(overlapY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cloneGroup) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
            "::",
            stringify!(cloneGroup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelShiftType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_DISPLAY_V2),
            "::",
            stringify!(pixelShiftType)
        )
    );
}
pub type NV_MOSAIC_GRID_TOPO_DISPLAY_V2 = _NV_MOSAIC_GRID_TOPO_DISPLAY_V2;
#[doc = "! \\ingroup mosaicapi\n! @{"]
pub type NV_MOSAIC_GRID_TOPO_DISPLAY = NV_MOSAIC_GRID_TOPO_DISPLAY_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_GRID_TOPO_V1 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Number of rows"]
    pub rows: NvU32,
    #[doc = "!< Number of columns"]
    pub columns: NvU32,
    #[doc = "!< Number of display details"]
    pub displayCount: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Displays are done as [(row * columns) + column]"]
    pub displays: [NV_MOSAIC_GRID_TOPO_DISPLAY_V1; 64usize],
    #[doc = "!< Display settings"]
    pub displaySettings: NV_MOSAIC_DISPLAY_SETTING_V1,
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_GRID_TOPO_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MOSAIC_GRID_TOPO_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_GRID_TOPO_V1>(),
        1320usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_GRID_TOPO_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_GRID_TOPO_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MOSAIC_GRID_TOPO_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rows) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_V1),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).columns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_V1),
            "::",
            stringify!(columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_V1),
            "::",
            stringify!(displayCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displays) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_V1),
            "::",
            stringify!(displays)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displaySettings) as usize - ptr as usize },
        1300usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_V1),
            "::",
            stringify!(displaySettings)
        )
    );
}
impl _NV_MOSAIC_GRID_TOPO_V1 {
    #[inline]
    pub fn applyWithBezelCorrect(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_applyWithBezelCorrect(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn immersiveGaming(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_immersiveGaming(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn baseMosaic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_baseMosaic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverReloadAllowed(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverReloadAllowed(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acceleratePrimaryDisplay(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_acceleratePrimaryDisplay(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        applyWithBezelCorrect: NvU32,
        immersiveGaming: NvU32,
        baseMosaic: NvU32,
        driverReloadAllowed: NvU32,
        acceleratePrimaryDisplay: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let applyWithBezelCorrect: u32 =
                unsafe { ::std::mem::transmute(applyWithBezelCorrect) };
            applyWithBezelCorrect as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let immersiveGaming: u32 = unsafe { ::std::mem::transmute(immersiveGaming) };
            immersiveGaming as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let baseMosaic: u32 = unsafe { ::std::mem::transmute(baseMosaic) };
            baseMosaic as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverReloadAllowed: u32 = unsafe { ::std::mem::transmute(driverReloadAllowed) };
            driverReloadAllowed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let acceleratePrimaryDisplay: u32 =
                unsafe { ::std::mem::transmute(acceleratePrimaryDisplay) };
            acceleratePrimaryDisplay as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MOSAIC_GRID_TOPO_V1 = _NV_MOSAIC_GRID_TOPO_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MOSAIC_GRID_TOPO_V2 {
    #[doc = "!< Version of this structure"]
    pub version: NvU32,
    #[doc = "!< Number of rows"]
    pub rows: NvU32,
    #[doc = "!< Number of columns"]
    pub columns: NvU32,
    #[doc = "!< Number of display details"]
    pub displayCount: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Displays are done as [(row * columns) + column]"]
    pub displays: [NV_MOSAIC_GRID_TOPO_DISPLAY_V2; 64usize],
    #[doc = "!< Display settings"]
    pub displaySettings: NV_MOSAIC_DISPLAY_SETTING_V1,
}
#[test]
fn bindgen_test_layout__NV_MOSAIC_GRID_TOPO_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MOSAIC_GRID_TOPO_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MOSAIC_GRID_TOPO_V2>(),
        1832usize,
        concat!("Size of: ", stringify!(_NV_MOSAIC_GRID_TOPO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MOSAIC_GRID_TOPO_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MOSAIC_GRID_TOPO_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rows) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_V2),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).columns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_V2),
            "::",
            stringify!(columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_V2),
            "::",
            stringify!(displayCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displays) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_V2),
            "::",
            stringify!(displays)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displaySettings) as usize - ptr as usize },
        1812usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MOSAIC_GRID_TOPO_V2),
            "::",
            stringify!(displaySettings)
        )
    );
}
impl _NV_MOSAIC_GRID_TOPO_V2 {
    #[inline]
    pub fn applyWithBezelCorrect(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_applyWithBezelCorrect(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn immersiveGaming(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_immersiveGaming(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn baseMosaic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_baseMosaic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverReloadAllowed(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverReloadAllowed(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acceleratePrimaryDisplay(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_acceleratePrimaryDisplay(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelShift(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pixelShift(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        applyWithBezelCorrect: NvU32,
        immersiveGaming: NvU32,
        baseMosaic: NvU32,
        driverReloadAllowed: NvU32,
        acceleratePrimaryDisplay: NvU32,
        pixelShift: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let applyWithBezelCorrect: u32 =
                unsafe { ::std::mem::transmute(applyWithBezelCorrect) };
            applyWithBezelCorrect as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let immersiveGaming: u32 = unsafe { ::std::mem::transmute(immersiveGaming) };
            immersiveGaming as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let baseMosaic: u32 = unsafe { ::std::mem::transmute(baseMosaic) };
            baseMosaic as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverReloadAllowed: u32 = unsafe { ::std::mem::transmute(driverReloadAllowed) };
            driverReloadAllowed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let acceleratePrimaryDisplay: u32 =
                unsafe { ::std::mem::transmute(acceleratePrimaryDisplay) };
            acceleratePrimaryDisplay as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let pixelShift: u32 = unsafe { ::std::mem::transmute(pixelShift) };
            pixelShift as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MOSAIC_GRID_TOPO_V2 = _NV_MOSAIC_GRID_TOPO_V2;
pub type NV_MOSAIC_GRID_TOPO = NV_MOSAIC_GRID_TOPO_V2;
extern "C" {
    #[doc = "! DESCRIPTION:     Sets a new display topology, replacing any existing topologies\n!                  that use the same displays.\n!\n!                  This function will look for an SLI configuration that will\n!                  allow the display topology to work.\n!\n!                  To revert to a single display, specify that display as a 1x1\n!                  grid.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]      pGridTopologies    The topology details to set.\n! \\param [in]      gridCount          The number of elements in the pGridTopologies array.\n! \\param [in]      setTopoFlags       Zero or more of the NVAPI_MOSAIC_SETDISPLAYTOPO_FLAG_*\n!                                     flags.\n!\n!\n! \\retval ::NVAPI_OK                          Capabilities have been returned.\n! \\retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid.\n! \\retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first\n! \\retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available\n! \\retval ::NVAPI_NO_ACTIVE_SLI_TOPOLOGY      No matching GPU topologies could be found.\n! \\retval ::NVAPI_TOPO_NOT_POSSIBLE           One or more of the display grids are not valid.\n! \\retval ::NVAPI_ERROR                       Miscellaneous error occurred\n! \\ingroup mosaicapi\n"]
    pub fn NvAPI_Mosaic_SetDisplayGrids(
        pGridTopologies: *mut NV_MOSAIC_GRID_TOPO,
        gridCount: NvU32,
        setTopoFlags: NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! \\ingroup mosaicapi"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_DISPLAY_TOPO_STATUS {
    pub version: NvU32,
    #[doc = "!< (OUT) Any of the NV_MOSAIC_DISPLAYTOPO_ERROR_* flags."]
    pub errorFlags: NvU32,
    #[doc = "!< (OUT) Any of the NV_MOSAIC_DISPLAYTOPO_WARNING_* flags."]
    pub warningFlags: NvU32,
    #[doc = "!< (OUT) The number of valid entries in the displays array."]
    pub displayCount: NvU32,
    pub displays: [NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1 {
    #[doc = "!< (OUT) The DisplayID of this display."]
    pub displayId: NvU32,
    #[doc = "!< (OUT) Any of the NV_MOSAIC_DISPLAYCAPS_PROBLEM_* flags."]
    pub errorFlags: NvU32,
    #[doc = "!< (OUT) Any of the NV_MOSAIC_DISPLAYTOPO_WARNING_* flags."]
    pub warningFlags: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1),
            "::",
            stringify!(displayId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1),
            "::",
            stringify!(errorFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warningFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1),
            "::",
            stringify!(warningFlags)
        )
    );
}
impl NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn supportsRotation(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supportsRotation(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supportsRotation: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supportsRotation: u32 = unsafe { ::std::mem::transmute(supportsRotation) };
            supportsRotation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_DISPLAY_TOPO_STATUS() {
    const UNINIT: ::std::mem::MaybeUninit<NV_MOSAIC_DISPLAY_TOPO_STATUS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_DISPLAY_TOPO_STATUS>(),
        2064usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_DISPLAY_TOPO_STATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS),
            "::",
            stringify!(errorFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warningFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS),
            "::",
            stringify!(warningFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS),
            "::",
            stringify!(displayCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displays) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_DISPLAY_TOPO_STATUS),
            "::",
            stringify!(displays)
        )
    );
}
extern "C" {
    #[doc = "! DESCRIPTION:     Determines if a list of grid topologies is valid. It will choose an SLI\n!                  configuration in the same way that NvAPI_Mosaic_SetDisplayGrids() does.\n!\n!                  On return, each element in the pTopoStatus array will contain any errors or\n!                  warnings about each grid topology. If any error flags are set, then the topology\n!                  is not valid. If any warning flags are set, then the topology is valid, but\n!                  sub-optimal.\n!\n!                  If the ALLOW_INVALID flag is set, then it will continue to validate the grids\n!                  even if no SLI configuration will allow all of the grids. In this case, a grid\n!                  grid with no matching GPU topology will have the error\n!                  flags NO_GPU_TOPOLOGY or NOT_SUPPORTED set.\n!\n!                  If the ALLOW_INVALID flag is not set and no matching SLI configuration is\n!                  found, then it will skip the rest of the validation and return\n!                  NVAPI_NO_ACTIVE_SLI_TOPOLOGY.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]      setTopoFlags       Zero or more of the NVAPI_MOSAIC_SETDISPLAYTOPO_FLAG_*\n!                                     flags.\n! \\param [in]      pGridTopologies    The array of grid topologies to verify.\n! \\param [in,out]  pTopoStatus        The array of problems and warnings with each grid topology.\n! \\param [in]      gridCount          The number of elements in the pGridTopologies and\n!                                     pTopoStatus arrays.\n!\n!\n! \\retval ::NVAPI_OK:                          Capabilities have been returned.\n! \\retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.\n! \\retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first\n! \\retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available\n! \\retval ::NVAPI_NO_ACTIVE_SLI_TOPOLOGY:      No matching GPU topologies could be found.\n! \\retval ::NVAPI_ERROR:                       Miscellaneous error occurred\n!\n! \\ingroup mosaicapi\n"]
    pub fn NvAPI_Mosaic_ValidateDisplayGrids(
        setTopoFlags: NvU32,
        pGridTopologies: *mut NV_MOSAIC_GRID_TOPO,
        pTopoStatus: *mut NV_MOSAIC_DISPLAY_TOPO_STATUS,
        gridCount: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     Determines the set of available display modes for a given grid topology.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]      pGridTopology         The grid topology to use.\n! \\param [in,out]  pDisplaySettings      A pointer to an array of display settings to populate,\n!                                        or NULL to find out the total number of available modes.\n! \\param [in,out]  pDisplayCount         If pDisplaySettings is not NULL, then pDisplayCount\n!                                        should point to the number of elements in the\n!                                        pDisplaySettings array. On return, it will contain the\n!                                        number of modes that were actually returned. If\n!                                        pDisplaySettings is NULL, then pDisplayCount will receive\n!                                        the total number of modes that are available.\n!\n!\n! \\retval ::NVAPI_OK                          Capabilities have been returned.\n! \\retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid.\n! \\retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first\n! \\retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available\n! \\retval ::NVAPI_ERROR                       Miscellaneous error occurred\n!\n! \\ingroup mosaciapi\n"]
    pub fn NvAPI_Mosaic_EnumDisplayModes(
        pGridTopology: *mut NV_MOSAIC_GRID_TOPO,
        pDisplaySettings: *mut NV_MOSAIC_DISPLAY_SETTING,
        pDisplayCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     Enumerates the current active grid topologies. This includes Mosaic, IG, and\n!                  Panoramic topologies, as well as single displays.\n!\n!                  If pGridTopologies is NULL, then pGridCount will be set to the number of active\n!                  grid topologies.\n!\n!                  If pGridTopologies is not NULL, then pGridCount contains the maximum number of\n!                  grid topologies to return. On return, pGridCount will be set to the number of\n!                  grid topologies that were returned.\n!\n! \\param [out]     pGridTopologies   The list of active grid topologies.\n! \\param [in,out]  pGridCount        A pointer to the number of grid topologies returned.\n!\n! \\retval ::NVAPI_OK                          Capabilties have been returned.\n! \\retval ::NVAPI_END_ENUMERATION             There are no more topologies to return.\n! \\retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid.\n! \\retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first\n! \\retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available\n! \\retval ::NVAPI_ERROR                       Miscellaneous error occurred\n!\n! \\ingroup mosaicapi\n"]
    pub fn NvAPI_Mosaic_EnumDisplayGrids(
        pGridTopologies: *mut NV_MOSAIC_GRID_TOPO,
        pGridCount: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! Used in NvAPI_GetCurrentMosaicTopology() and NvAPI_SetCurrentMosaicTopology()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_TOPOLOGY {
    #[doc = "!< Version number of the mosaic topology"]
    pub version: NvU32,
    #[doc = "!< Horizontal display count"]
    pub rowCount: NvU32,
    #[doc = "!< Vertical display count"]
    pub colCount: NvU32,
    pub gpuLayout: [[NV_MOSAIC_TOPOLOGY__bindgen_ty_1; 8usize]; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_TOPOLOGY__bindgen_ty_1 {
    #[doc = "!< Physical GPU to be used in the topology"]
    pub hPhysicalGPU: NvPhysicalGpuHandle,
    #[doc = "!< Connected display target"]
    pub displayOutputId: NvU32,
    #[doc = "!< Pixels of overlap on the left of target: (+overlap, -gap)"]
    pub overlapX: NvS32,
    #[doc = "!< Pixels of overlap on the top of target: (+overlap, -gap)"]
    pub overlapY: NvS32,
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_TOPOLOGY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_MOSAIC_TOPOLOGY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_TOPOLOGY__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_TOPOLOGY__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_TOPOLOGY__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NV_MOSAIC_TOPOLOGY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hPhysicalGPU) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPOLOGY__bindgen_ty_1),
            "::",
            stringify!(hPhysicalGPU)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayOutputId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPOLOGY__bindgen_ty_1),
            "::",
            stringify!(displayOutputId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlapX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPOLOGY__bindgen_ty_1),
            "::",
            stringify!(overlapX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlapY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPOLOGY__bindgen_ty_1),
            "::",
            stringify!(overlapY)
        )
    );
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_TOPOLOGY() {
    const UNINIT: ::std::mem::MaybeUninit<NV_MOSAIC_TOPOLOGY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_TOPOLOGY>(),
        1552usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_TOPOLOGY))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_TOPOLOGY>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_TOPOLOGY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPOLOGY),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rowCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPOLOGY),
            "::",
            stringify!(rowCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPOLOGY),
            "::",
            stringify!(colCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuLayout) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_TOPOLOGY),
            "::",
            stringify!(gpuLayout)
        )
    );
}
#[doc = "! Used in NvAPI_GetSupportedMosaicTopologies()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_MOSAIC_SUPPORTED_TOPOLOGIES {
    pub version: NvU32,
    #[doc = "!< Count of valid topologies"]
    pub totalCount: NvU32,
    #[doc = "!< Maximum number of topologies"]
    pub topos: [NV_MOSAIC_TOPOLOGY; 16usize],
}
#[test]
fn bindgen_test_layout_NV_MOSAIC_SUPPORTED_TOPOLOGIES() {
    const UNINIT: ::std::mem::MaybeUninit<NV_MOSAIC_SUPPORTED_TOPOLOGIES> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_MOSAIC_SUPPORTED_TOPOLOGIES>(),
        24840usize,
        concat!("Size of: ", stringify!(NV_MOSAIC_SUPPORTED_TOPOLOGIES))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_MOSAIC_SUPPORTED_TOPOLOGIES>(),
        8usize,
        concat!("Alignment of ", stringify!(NV_MOSAIC_SUPPORTED_TOPOLOGIES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_SUPPORTED_TOPOLOGIES),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_SUPPORTED_TOPOLOGIES),
            "::",
            stringify!(totalCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_MOSAIC_SUPPORTED_TOPOLOGIES),
            "::",
            stringify!(topos)
        )
    );
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API returns all valid Mosaic topologies.\n!\n! SUPPORTED OS:  Windows XP\n!\n!\n! \\since Release: 177\n!\n! \\param [out] pMosaicTopos                   An array of valid Mosaic topologies.\n!\n! \\retval      NVAPI_OK                       Call succeeded; 1 or more topologies were returned\n! \\retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid\n! \\retval      NVAPI_MIXED_TARGET_TYPES       Mosaic topology is only possible with all targets of the same NV_GPU_OUTPUT_TYPE.\n! \\retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found\n! \\retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.\n! \\retval      NVAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed.\n!\n! \\ingroup     mosaicapi\n"]
    pub fn NvAPI_GetSupportedMosaicTopologies(
        pMosaicTopos: *mut NV_MOSAIC_SUPPORTED_TOPOLOGIES,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API gets the current Mosaic topology.\n!\n! SUPPORTED OS:  Windows XP\n!\n!\n! \\since Release: 177\n!\n! \\param [out] pMosaicTopo                    The current Mosaic topology\n! \\param [out] pEnabled                       TRUE if returned topology is currently enabled, else FALSE\n!\n! \\retval      NVAPI_OK                       Call succeeded\n! \\retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid\n! \\retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found\n! \\retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.\n! \\retval      NVAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed.\n!\n! \\ingroup     mosaicapi\n"]
    pub fn NvAPI_GetCurrentMosaicTopology(
        pMosaicTopo: *mut NV_MOSAIC_TOPOLOGY,
        pEnabled: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API sets the Mosaic topology, and enables it so that the\n!                  Mosaic display settings are enumerated upon request.\n!\n! SUPPORTED OS:  Windows XP\n!\n!\n! \\since Release: 177\n!\n! \\param [in]  pMosaicTopo                    A valid Mosaic topology\n!\n! \\retval      NVAPI_OK                       Call succeeded\n! \\retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid\n! \\retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found\n! \\retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.\n! \\retval      NVAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed.\n!\n! \\ingroup     mosaicapi\n"]
    pub fn NvAPI_SetCurrentMosaicTopology(pMosaicTopo: *mut NV_MOSAIC_TOPOLOGY) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:    This API enables or disables the current Mosaic topology.\n!                 When enabling, the last Mosaic topology will be set.\n!\n!                  - If enabled, enumeration of display settings will include valid Mosaic resolutions.\n!                  - If disabled, enumeration of display settings will not include Mosaic resolutions.\n!\n! SUPPORTED OS:  Windows XP\n!\n!\n! \\since Release: 177\n!\n! \\param [in]  enable                         TRUE to enable the Mosaic Topology, FALSE to disable it.\n!\n! \\retval      NVAPI_OK                       Call succeeded\n! \\retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid\n! \\retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found\n! \\retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.\n! \\retval      NVAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed.\n!\n! \\ingroup     mosaicapi\n"]
    pub fn NvAPI_EnableCurrentMosaicTopology(enable: NvU32) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns an array of Sync device handles. A Sync device handle represents a\n!                single Sync device on the system.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n! \\param [out] nvGSyncHandles-  The caller provides an array of handles, which must contain at least\n!                               NVAPI_MAX_GSYNC_DEVICES elements. The API will zero out the entire array and then fill in one\n!                               or more handles. If an error occurs, the array is invalid.\n! \\param [out] *gsyncCount-     The caller provides the storage space. NvAPI_GSync_EnumSyncDevices\n!                               sets *gsyncCount to indicate how many of the elements in the nvGSyncHandles[] array are valid.\n!                               If an error occurs, *gsyncCount will be set to zero.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API, they are listed below.\n! \\retval ::NVAPI_INVALID_ARGUMENT         nvGSyncHandles or gsyncCount is NULL.\n! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Sync Device.\n!\n! \\ingroup gsyncapi\n"]
    pub fn NvAPI_GSync_EnumSyncDevices(
        nvGSyncHandles: *mut NvGSyncDeviceHandle,
        gsyncCount: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! Used in NvAPI_GSync_QueryCapabilities()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_CAPABILITIES_V1 {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< Board ID"]
    pub boardId: NvU32,
    #[doc = "!< FPGA Revision"]
    pub revision: NvU32,
    #[doc = "!< Capabilities of the Sync board. Reserved for future use"]
    pub capFlags: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_CAPABILITIES_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GSYNC_CAPABILITIES_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_CAPABILITIES_V1>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_CAPABILITIES_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_CAPABILITIES_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_CAPABILITIES_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boardId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V1),
            "::",
            stringify!(boardId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V1),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capFlags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V1),
            "::",
            stringify!(capFlags)
        )
    );
}
#[doc = "! Used in NvAPI_GSync_QueryCapabilities()."]
pub type NV_GSYNC_CAPABILITIES_V1 = _NV_GSYNC_CAPABILITIES_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_CAPABILITIES_V2 {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< Board ID"]
    pub boardId: NvU32,
    #[doc = "!< FPGA major revision"]
    pub revision: NvU32,
    #[doc = "!< Capabilities of the Sync board. Reserved for future use"]
    pub capFlags: NvU32,
    #[doc = "!< FPGA minor revision"]
    pub extendedRevision: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_CAPABILITIES_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GSYNC_CAPABILITIES_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_CAPABILITIES_V2>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_CAPABILITIES_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_CAPABILITIES_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_CAPABILITIES_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boardId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V2),
            "::",
            stringify!(boardId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V2),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capFlags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V2),
            "::",
            stringify!(capFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extendedRevision) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V2),
            "::",
            stringify!(extendedRevision)
        )
    );
}
pub type NV_GSYNC_CAPABILITIES_V2 = _NV_GSYNC_CAPABILITIES_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_CAPABILITIES_V3 {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< Board ID"]
    pub boardId: NvU32,
    #[doc = "!< FPGA major revision"]
    pub revision: NvU32,
    #[doc = "!< Capabilities of the Sync board. Reserved for future use"]
    pub capFlags: NvU32,
    #[doc = "!< FPGA minor revision"]
    pub extendedRevision: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< This parameter returns the maximum possible value that can be programmed\n!< for multiplying / dividing house sync. Only valid if bIsMulDivSupported is set to 1."]
    pub maxMulDivValue: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_CAPABILITIES_V3() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GSYNC_CAPABILITIES_V3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_CAPABILITIES_V3>(),
        28usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_CAPABILITIES_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_CAPABILITIES_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_CAPABILITIES_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boardId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V3),
            "::",
            stringify!(boardId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V3),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capFlags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V3),
            "::",
            stringify!(capFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extendedRevision) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V3),
            "::",
            stringify!(extendedRevision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxMulDivValue) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CAPABILITIES_V3),
            "::",
            stringify!(maxMulDivValue)
        )
    );
}
impl _NV_GSYNC_CAPABILITIES_V3 {
    #[inline]
    pub fn bIsMulDivSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsMulDivSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsMulDivSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsMulDivSupported: u32 = unsafe { ::std::mem::transmute(bIsMulDivSupported) };
            bIsMulDivSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_CAPABILITIES_V3 = _NV_GSYNC_CAPABILITIES_V3;
pub type NV_GSYNC_CAPABILITIES = NV_GSYNC_CAPABILITIES_V3;
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns the capabilities of the Sync device.\n!\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n! \\param [in]    hNvGSyncDevice-        The handle for a Sync device for which the capabilities will be queried.\n! \\param [inout] *pNvGSyncCapabilities- The caller provides the storage space. NvAPI_GSync_QueryCapabilities() sets\n!                                       *pNvGSyncCapabilities to the version and capabilities details of the Sync device\n!                                       If an error occurs, *pNvGSyncCapabilities will be set to NULL.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API, they are listed below.\n! \\retval ::NVAPI_INVALID_ARGUMENT         hNvGSyncDevice is NULL.\n! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Sync Device.\n!\n! \\ingroup gsyncapi\n"]
    pub fn NvAPI_GSync_QueryCapabilities(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        pNvGSyncCapabilities: *mut NV_GSYNC_CAPABILITIES,
    ) -> NvAPI_Status;
}
pub const _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NONE:
    _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR = 0;
pub const _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_PRIMARY:
    _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR = 1;
pub const _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_SECONDARY:
    _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR = 2;
pub const _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_TERTIARY:
    _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR = 3;
pub const _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_QUARTERNARY:
    _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR = 4;
#[doc = "! Connector values for a GPU. Used in NV_GSYNC_GPU."]
pub type _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR = ::std::os::raw::c_int;
#[doc = "! Connector values for a GPU. Used in NV_GSYNC_GPU."]
pub use self::_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR as NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR;
pub const _NVAPI_GSYNC_DISPLAY_SYNC_STATE_NVAPI_GSYNC_DISPLAY_SYNC_STATE_UNSYNCED:
    _NVAPI_GSYNC_DISPLAY_SYNC_STATE = 0;
pub const _NVAPI_GSYNC_DISPLAY_SYNC_STATE_NVAPI_GSYNC_DISPLAY_SYNC_STATE_SLAVE:
    _NVAPI_GSYNC_DISPLAY_SYNC_STATE = 1;
pub const _NVAPI_GSYNC_DISPLAY_SYNC_STATE_NVAPI_GSYNC_DISPLAY_SYNC_STATE_MASTER:
    _NVAPI_GSYNC_DISPLAY_SYNC_STATE = 2;
#[doc = "! Display sync states. Used in NV_GSYNC_DISPLAY."]
pub type _NVAPI_GSYNC_DISPLAY_SYNC_STATE = ::std::os::raw::c_int;
#[doc = "! Display sync states. Used in NV_GSYNC_DISPLAY."]
pub use self::_NVAPI_GSYNC_DISPLAY_SYNC_STATE as NVAPI_GSYNC_DISPLAY_SYNC_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_GPU {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< GPU handle"]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!< Indicates which connector on the device the GPU is connected to."]
    pub connector: NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR,
    #[doc = "!< GPU through which hPhysicalGpu is connected to the Sync device (if not directly connected)\n!<  - this is NULL otherwise"]
    pub hProxyPhysicalGpu: NvPhysicalGpuHandle,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_GPU() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GSYNC_GPU> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_GPU>(),
        40usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_GPU))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_GPU>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_GPU))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_GPU),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_GPU),
            "::",
            stringify!(hPhysicalGpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connector) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_GPU),
            "::",
            stringify!(connector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hProxyPhysicalGpu) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_GPU),
            "::",
            stringify!(hProxyPhysicalGpu)
        )
    );
}
impl _NV_GSYNC_GPU {
    #[inline]
    pub fn isSynced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSynced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isSynced: NvU32, reserved: NvU32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isSynced: u32 = unsafe { ::std::mem::transmute(isSynced) };
            isSynced as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_GPU = _NV_GSYNC_GPU;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_DISPLAY {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< display identifier for displays.The GPU to which it is connected, can be retireved from NvAPI_SYS_GetPhysicalGpuFromDisplayId"]
    pub displayId: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< Is this display slave/master\n!< (Retrieved with topology or set by caller for enable/disable sync)"]
    pub syncState: NVAPI_GSYNC_DISPLAY_SYNC_STATE,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_DISPLAY() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GSYNC_DISPLAY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_DISPLAY>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_DISPLAY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_DISPLAY>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_DISPLAY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_DISPLAY),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_DISPLAY),
            "::",
            stringify!(displayId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncState) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_DISPLAY),
            "::",
            stringify!(syncState)
        )
    );
}
impl _NV_GSYNC_DISPLAY {
    #[inline]
    pub fn isMasterable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMasterable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isMasterable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isMasterable: u32 = unsafe { ::std::mem::transmute(isMasterable) };
            isMasterable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_DISPLAY = _NV_GSYNC_DISPLAY;
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns the topology for the specified Sync device.\n!\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n! \\param [in]       hNvGSyncDevice-     The caller provides the handle for a Sync device for which the topology will be queried.\n! \\param [in, out]  gsyncGpuCount-      It returns number of GPUs connected to Sync device\n! \\param [in, out]  gsyncGPUs-          It returns info about GPUs connected to Sync device\n! \\param [in, out]  gsyncDisplayCount-  It returns number of active displays that belongs to Sync device\n! \\param [in, out]  gsyncDisplays-      It returns info about all active displays that belongs to Sync device\n!\n! HOW TO USE: 1) make a call to get the number of GPUs connected OR displays synced through Sync device\n!                by passing the gsyncGPUs OR gsyncDisplays as NULL respectively. Both gsyncGpuCount and gsyncDisplayCount can be retrieved in same call by passing\n!                both gsyncGPUs and gsyncDisplays as NULL\n!                On call success:\n!             2) Allocate memory based on gsyncGpuCount(for gsyncGPUs) and/or gsyncDisplayCount(for gsyncDisplays) then make a call to populate gsyncGPUs and/or gsyncDisplays respectively.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API, they are listed below.\n! \\retval ::NVAPI_INVALID_ARGUMENT               hNvGSyncDevice is NULL.\n! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND        The queried Graphics system does not have any Sync Device.\n! \\retval ::NVAPI_INSUFFICIENT_BUFFER            When the actual number of GPUs/displays in the topology exceed the number of elements allocated for SyncGPUs/SyncDisplays respectively.\n!\n! \\ingroup gsyncapi\n"]
    pub fn NvAPI_GSync_GetTopology(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        gsyncGpuCount: *mut NvU32,
        gsyncGPUs: *mut NV_GSYNC_GPU,
        gsyncDisplayCount: *mut NvU32,
        gsyncDisplays: *mut NV_GSYNC_DISPLAY,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Sets a new sync state for the displays in system.\n!\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n! \\param [in]  gsyncDisplayCount-\t\t\tThe number of displays in gsyncDisplays.\n! \\param [in]  pGsyncDisplays-\t\t\tThe caller provides the structure containing all displays that need to be synchronized in the system.\n!\t\t\t\t\t\t\t\t\t\t\tThe displays that are not part of pGsyncDisplays, will be un-synchronized.\n! \\param [in]  flags-\t\t\t\t\t\tReserved for future use.\n!\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API, they are listed below.\n!\n! \\retval ::NVAPI_INVALID_ARGUMENT\t\t\tIf the display topology or count not valid.\n! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND\t\tThe queried Graphics system does not have any Sync Device.\n! \\retval ::NVAPI_INVALID_SYNC_TOPOLOGY       1.If any mosaic grid is partial.\n!                                             2.If timing(HVisible/VVisible/refreshRate) applied of any display is different.\n!                                             3.If There is a across GPU mosaic grid in system and that is not a part of pGsyncDisplays.\n!\n! \\ingroup gsyncapi\n"]
    pub fn NvAPI_GSync_SetSyncStateSettings(
        gsyncDisplayCount: NvU32,
        pGsyncDisplays: *mut NV_GSYNC_DISPLAY,
        flags: NvU32,
    ) -> NvAPI_Status;
}
pub const _NVAPI_GSYNC_POLARITY_NVAPI_GSYNC_POLARITY_RISING_EDGE: _NVAPI_GSYNC_POLARITY = 0;
pub const _NVAPI_GSYNC_POLARITY_NVAPI_GSYNC_POLARITY_FALLING_EDGE: _NVAPI_GSYNC_POLARITY = 1;
pub const _NVAPI_GSYNC_POLARITY_NVAPI_GSYNC_POLARITY_BOTH_EDGES: _NVAPI_GSYNC_POLARITY = 2;
#[doc = "! Source signal edge to be used for output pulse. See NV_GSYNC_CONTROL_PARAMS."]
pub type _NVAPI_GSYNC_POLARITY = ::std::os::raw::c_int;
#[doc = "! Source signal edge to be used for output pulse. See NV_GSYNC_CONTROL_PARAMS."]
pub use self::_NVAPI_GSYNC_POLARITY as NVAPI_GSYNC_POLARITY;
pub const _NVAPI_GSYNC_VIDEO_MODE_NVAPI_GSYNC_VIDEO_MODE_NONE: _NVAPI_GSYNC_VIDEO_MODE = 0;
pub const _NVAPI_GSYNC_VIDEO_MODE_NVAPI_GSYNC_VIDEO_MODE_TTL: _NVAPI_GSYNC_VIDEO_MODE = 1;
pub const _NVAPI_GSYNC_VIDEO_MODE_NVAPI_GSYNC_VIDEO_MODE_NTSCPALSECAM: _NVAPI_GSYNC_VIDEO_MODE = 2;
pub const _NVAPI_GSYNC_VIDEO_MODE_NVAPI_GSYNC_VIDEO_MODE_HDTV: _NVAPI_GSYNC_VIDEO_MODE = 3;
pub const _NVAPI_GSYNC_VIDEO_MODE_NVAPI_GSYNC_VIDEO_MODE_COMPOSITE: _NVAPI_GSYNC_VIDEO_MODE = 4;
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
pub type _NVAPI_GSYNC_VIDEO_MODE = ::std::os::raw::c_int;
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
pub use self::_NVAPI_GSYNC_VIDEO_MODE as NVAPI_GSYNC_VIDEO_MODE;
pub const _NVAPI_GSYNC_SYNC_SOURCE_NVAPI_GSYNC_SYNC_SOURCE_VSYNC: _NVAPI_GSYNC_SYNC_SOURCE = 0;
pub const _NVAPI_GSYNC_SYNC_SOURCE_NVAPI_GSYNC_SYNC_SOURCE_HOUSESYNC: _NVAPI_GSYNC_SYNC_SOURCE = 1;
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
pub type _NVAPI_GSYNC_SYNC_SOURCE = ::std::os::raw::c_int;
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
pub use self::_NVAPI_GSYNC_SYNC_SOURCE as NVAPI_GSYNC_SYNC_SOURCE;
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_DELAY {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< delay to be induced in number of horizontal lines."]
    pub numLines: NvU32,
    #[doc = "!< delay to be induced in number of pixels."]
    pub numPixels: NvU32,
    #[doc = "!< maximum number of lines supported at current display mode to induce delay. Updated by NvAPI_GSync_GetControlParameters(). Read only."]
    pub maxLines: NvU32,
    #[doc = "!< minimum number of pixels required at current display mode to induce delay. Updated by NvAPI_GSync_GetControlParameters(). Read only."]
    pub minPixels: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_DELAY() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GSYNC_DELAY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_DELAY>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_DELAY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_DELAY>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_DELAY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_DELAY),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numLines) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_DELAY),
            "::",
            stringify!(numLines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPixels) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_DELAY),
            "::",
            stringify!(numPixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxLines) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_DELAY),
            "::",
            stringify!(maxLines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minPixels) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_DELAY),
            "::",
            stringify!(minPixels)
        )
    );
}
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
pub type NV_GSYNC_DELAY = _NV_GSYNC_DELAY;
#[doc = "! Used in NvAPI_GSync_GetControlParameters() and NvAPI_GSync_SetControlParameters()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_CONTROL_PARAMS_V1 {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< Leading edge / Falling edge / both"]
    pub polarity: NVAPI_GSYNC_POLARITY,
    #[doc = "!< None, TTL, NTSCPALSECAM, HDTV"]
    pub vmode: NVAPI_GSYNC_VIDEO_MODE,
    #[doc = "!< Number of pulses to wait between framelock signal generation"]
    pub interval: NvU32,
    #[doc = "!< VSync/House sync"]
    pub source: NVAPI_GSYNC_SYNC_SOURCE,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< The time delay between the frame sync signal and the GPUs signal."]
    pub syncSkew: NV_GSYNC_DELAY,
    #[doc = "!< Sync start delay for master."]
    pub startupDelay: NV_GSYNC_DELAY,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_CONTROL_PARAMS_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GSYNC_CONTROL_PARAMS_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_CONTROL_PARAMS_V1>(),
        64usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_CONTROL_PARAMS_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_CONTROL_PARAMS_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_CONTROL_PARAMS_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).polarity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V1),
            "::",
            stringify!(polarity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vmode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V1),
            "::",
            stringify!(vmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V1),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V1),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncSkew) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V1),
            "::",
            stringify!(syncSkew)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startupDelay) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V1),
            "::",
            stringify!(startupDelay)
        )
    );
}
impl _NV_GSYNC_CONTROL_PARAMS_V1 {
    #[inline]
    pub fn interlaceMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interlaceMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syncSourceIsOutput(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_syncSourceIsOutput(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interlaceMode: NvU32,
        syncSourceIsOutput: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interlaceMode: u32 = unsafe { ::std::mem::transmute(interlaceMode) };
            interlaceMode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syncSourceIsOutput: u32 = unsafe { ::std::mem::transmute(syncSourceIsOutput) };
            syncSourceIsOutput as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! Used in NvAPI_GSync_GetControlParameters() and NvAPI_GSync_SetControlParameters()."]
pub type NV_GSYNC_CONTROL_PARAMS_V1 = _NV_GSYNC_CONTROL_PARAMS_V1;
pub const _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE_NVAPI_GSYNC_UNDEFINED_MODE:
    _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE = 0;
pub const _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE_NVAPI_GSYNC_MULTIPLY_MODE:
    _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE = 1;
pub const _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE_NVAPI_GSYNC_DIVIDE_MODE:
    _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE = 2;
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
pub type _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE = ::std::os::raw::c_int;
#[doc = "! Used in NV_GSYNC_CONTROL_PARAMS."]
pub use self::_NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE as NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_CONTROL_PARAMS_V2 {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< Leading edge / Falling edge / both"]
    pub polarity: NVAPI_GSYNC_POLARITY,
    #[doc = "!< None, TTL, NTSCPALSECAM, HDTV"]
    pub vmode: NVAPI_GSYNC_VIDEO_MODE,
    #[doc = "!< Number of pulses to wait between framelock signal generation"]
    pub interval: NvU32,
    #[doc = "!< VSync/House sync"]
    pub source: NVAPI_GSYNC_SYNC_SOURCE,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< The time delay between the frame sync signal and the GPUs signal."]
    pub syncSkew: NV_GSYNC_DELAY,
    #[doc = "!< Sync start delay for master."]
    pub startupDelay: NV_GSYNC_DELAY,
    #[doc = "!< Indicates multiplier/divider mode for the housesync signal.\n!< While setting multiplyDivideMode, source needs to be set as NVAPI_GSYNC_SYNC_SOURCE_HOUSESYNC."]
    pub multiplyDivideMode: NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE,
    #[doc = "!< Indicates the multiplier/divider value for the housesync signal. Only supported if bIsMulDivSupported field of the structure NV_GSYNC_CAPABILITIES is set to 1.\n!< The maximum supported value for this field can be obtained from maxMulDivValue field of the structure NV_GSYNC_CAPABILITIES."]
    pub multiplyDivideValue: NvU8,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_CONTROL_PARAMS_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GSYNC_CONTROL_PARAMS_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_CONTROL_PARAMS_V2>(),
        72usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_CONTROL_PARAMS_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_CONTROL_PARAMS_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_CONTROL_PARAMS_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).polarity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V2),
            "::",
            stringify!(polarity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vmode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V2),
            "::",
            stringify!(vmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V2),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V2),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncSkew) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V2),
            "::",
            stringify!(syncSkew)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startupDelay) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V2),
            "::",
            stringify!(startupDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiplyDivideMode) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V2),
            "::",
            stringify!(multiplyDivideMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiplyDivideValue) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_CONTROL_PARAMS_V2),
            "::",
            stringify!(multiplyDivideValue)
        )
    );
}
impl _NV_GSYNC_CONTROL_PARAMS_V2 {
    #[inline]
    pub fn interlaceMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interlaceMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syncSourceIsOutput(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_syncSourceIsOutput(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interlaceMode: NvU32,
        syncSourceIsOutput: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interlaceMode: u32 = unsafe { ::std::mem::transmute(interlaceMode) };
            interlaceMode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syncSourceIsOutput: u32 = unsafe { ::std::mem::transmute(syncSourceIsOutput) };
            syncSourceIsOutput as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_CONTROL_PARAMS_V2 = _NV_GSYNC_CONTROL_PARAMS_V2;
pub type NV_GSYNC_CONTROL_PARAMS = NV_GSYNC_CONTROL_PARAMS_V2;
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries for sync control parameters as defined in NV_GSYNC_CONTROL_PARAMS.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n! \\param [in]    hNvGSyncDevice-   The caller provides the handle of the Sync device for which to get parameters\n! \\param [inout] *pGsyncControls-  The caller provides the storage space. NvAPI_GSync_GetControlParameters() populates *pGsyncControls with values.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API, they are listed below.\n! \\retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL.\n! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any Sync Device.\n!\n! \\ingroup gsyncapi\n"]
    pub fn NvAPI_GSync_GetControlParameters(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        pGsyncControls: *mut NV_GSYNC_CONTROL_PARAMS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API sets control parameters as defined in NV_SYNC_CONTROL_PARAMS.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n! \\param [in]  hNvGSyncDevice-   The caller provides the handle of the Sync device for which to get parameters\n! \\param [inout]  *pGsyncControls-  The caller provides NV_GSYNC_CONTROL_PARAMS. skew and startDelay will be updated to the applied values.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API, they are listed below.\n! \\retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL.\n! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any Sync Device.\n! \\retval ::NVAPI_SYNC_MASTER_NOT_FOUND     Control Parameters can only be set if there is a Sync Master enabled on the Gsync card.\n!\n! \\ingroup gsyncapi\n"]
    pub fn NvAPI_GSync_SetControlParameters(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        pGsyncControls: *mut NV_GSYNC_CONTROL_PARAMS,
    ) -> NvAPI_Status;
}
pub const _NVAPI_GSYNC_DELAY_TYPE_NVAPI_GSYNC_DELAY_TYPE_UNKNOWN: _NVAPI_GSYNC_DELAY_TYPE = 0;
pub const _NVAPI_GSYNC_DELAY_TYPE_NVAPI_GSYNC_DELAY_TYPE_SYNC_SKEW: _NVAPI_GSYNC_DELAY_TYPE = 1;
pub const _NVAPI_GSYNC_DELAY_TYPE_NVAPI_GSYNC_DELAY_TYPE_STARTUP: _NVAPI_GSYNC_DELAY_TYPE = 2;
#[doc = "! Used in NvAPI_GSync_AdjustSyncDelay()"]
pub type _NVAPI_GSYNC_DELAY_TYPE = ::std::os::raw::c_int;
#[doc = "! Used in NvAPI_GSync_AdjustSyncDelay()"]
pub use self::_NVAPI_GSYNC_DELAY_TYPE as NVAPI_GSYNC_DELAY_TYPE;
extern "C" {
    #[doc = "!   DESCRIPTION: This API adjusts the skew and startDelay to the closest possible values. Use this API before calling NvAPI_GSync_SetControlParameters for skew or startDelay.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 319\n!\n! \\param [in]  hNvGSyncDevice-   \tThe caller provides the handle of the Sync device for which to get parameters\n! \\param [in]  delayType-   \t\tSpecifies whether the delay is syncSkew or startupDelay.\n! \\param [inout]  *pGsyncDelay-  \tThe caller provides NV_GSYNC_DELAY. skew and startDelay will be adjusted and updated to the closest values.\n! \\param [out]  *syncSteps-  \t\tThis parameter is optional. It returns the sync delay in unit steps. If 0, it means either the NV_GSYNC_DELAY::numPixels is less than NV_GSYNC_DELAY::minPixels or NV_GSYNC_DELAY::numOfLines exceeds the NV_GSYNC_DELAY::maxLines.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API, they are listed below.\n!\n! \\ingroup gsyncapi\n"]
    pub fn NvAPI_GSync_AdjustSyncDelay(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        delayType: NVAPI_GSYNC_DELAY_TYPE,
        pGsyncDelay: *mut NV_GSYNC_DELAY,
        syncSteps: *mut NvU32,
    ) -> NvAPI_Status;
}
#[doc = "! Used in NvAPI_GSync_GetSyncStatus()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_STATUS {
    #[doc = "!< Version of the structure"]
    pub version: NvU32,
    #[doc = "!< Is timing in sync?"]
    pub bIsSynced: NvU32,
    #[doc = "!< Does the phase of the timing signal from the GPU = the phase of the master sync signal?"]
    pub bIsStereoSynced: NvU32,
    #[doc = "!< Is the sync signal available?"]
    pub bIsSyncSignalAvailable: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_STATUS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GSYNC_STATUS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_STATUS>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_STATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_STATUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsSynced) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS),
            "::",
            stringify!(bIsSynced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsStereoSynced) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS),
            "::",
            stringify!(bIsStereoSynced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsSyncSignalAvailable) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS),
            "::",
            stringify!(bIsSyncSignalAvailable)
        )
    );
}
#[doc = "! Used in NvAPI_GSync_GetSyncStatus()."]
pub type NV_GSYNC_STATUS = _NV_GSYNC_STATUS;
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries the sync status of a GPU - timing, stereosync and sync signal availability.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n! \\param [in]  hNvGSyncDevice-     Handle of the Sync device\n! \\param [in]  hPhysicalGpu-       GPU to be queried for sync status.\n! \\param [out] *status-            The caller provides the storage space. NvAPI_GSync_GetSyncStatus() populates *status with\n!                                  values - timing, stereosync and signal availability. On error, *status is set to NULL.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API, they are listed below.\n! \\retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL / SyncTarget is NULL.\n! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.\n!\n! \\ingroup gsyncapi\n"]
    pub fn NvAPI_GSync_GetSyncStatus(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        hPhysicalGpu: NvPhysicalGpuHandle,
        status: *mut NV_GSYNC_STATUS,
    ) -> NvAPI_Status;
}
pub const _NVAPI_GSYNC_RJ45_IO_NVAPI_GSYNC_RJ45_OUTPUT: _NVAPI_GSYNC_RJ45_IO = 0;
pub const _NVAPI_GSYNC_RJ45_IO_NVAPI_GSYNC_RJ45_INPUT: _NVAPI_GSYNC_RJ45_IO = 1;
#[doc = "!< This field is used to notify that the framelock is not actually present."]
pub const _NVAPI_GSYNC_RJ45_IO_NVAPI_GSYNC_RJ45_UNUSED: _NVAPI_GSYNC_RJ45_IO = 2;
#[doc = "! Used in NV_GSYNC_STATUS_PARAMS."]
pub type _NVAPI_GSYNC_RJ45_IO = ::std::os::raw::c_int;
#[doc = "! Used in NV_GSYNC_STATUS_PARAMS."]
pub use self::_NVAPI_GSYNC_RJ45_IO as NVAPI_GSYNC_RJ45_IO;
#[doc = "! \\ingroup gsyncapi\n! Used in NvAPI_GSync_GetStatusParameters()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_STATUS_PARAMS_V1 {
    pub version: NvU32,
    #[doc = "!< The refresh rate"]
    pub refreshRate: NvU32,
    #[doc = "!< Configured as input / output"]
    pub RJ45_IO: [NVAPI_GSYNC_RJ45_IO; 2usize],
    #[doc = "!< Connected to ethernet hub? [ERRONEOUSLY CONNECTED!]"]
    pub RJ45_Ethernet: [NvU32; 2usize],
    #[doc = "!< Incoming house sync frequency in Hz"]
    pub houseSyncIncoming: NvU32,
    #[doc = "!< Is house sync connected?"]
    pub bHouseSync: NvU32,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_STATUS_PARAMS_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GSYNC_STATUS_PARAMS_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_STATUS_PARAMS_V1>(),
        32usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_STATUS_PARAMS_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_STATUS_PARAMS_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_STATUS_PARAMS_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS_PARAMS_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refreshRate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS_PARAMS_V1),
            "::",
            stringify!(refreshRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RJ45_IO) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS_PARAMS_V1),
            "::",
            stringify!(RJ45_IO)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RJ45_Ethernet) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS_PARAMS_V1),
            "::",
            stringify!(RJ45_Ethernet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).houseSyncIncoming) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS_PARAMS_V1),
            "::",
            stringify!(houseSyncIncoming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bHouseSync) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS_PARAMS_V1),
            "::",
            stringify!(bHouseSync)
        )
    );
}
#[doc = "! \\ingroup gsyncapi\n! Used in NvAPI_GSync_GetStatusParameters()."]
pub type NV_GSYNC_STATUS_PARAMS_V1 = _NV_GSYNC_STATUS_PARAMS_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GSYNC_STATUS_PARAMS_V2 {
    pub version: NvU32,
    #[doc = "!< The refresh rate"]
    pub refreshRate: NvU32,
    #[doc = "!< Configured as input / output"]
    pub RJ45_IO: [NVAPI_GSYNC_RJ45_IO; 2usize],
    #[doc = "!< Connected to ethernet hub? [ERRONEOUSLY CONNECTED!]"]
    pub RJ45_Ethernet: [NvU32; 2usize],
    #[doc = "!< Incoming house sync frequency in Hz"]
    pub houseSyncIncoming: NvU32,
    #[doc = "!< Is house sync connected?"]
    pub bHouseSync: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_GSYNC_STATUS_PARAMS_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GSYNC_STATUS_PARAMS_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GSYNC_STATUS_PARAMS_V2>(),
        36usize,
        concat!("Size of: ", stringify!(_NV_GSYNC_STATUS_PARAMS_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GSYNC_STATUS_PARAMS_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GSYNC_STATUS_PARAMS_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS_PARAMS_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refreshRate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS_PARAMS_V2),
            "::",
            stringify!(refreshRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RJ45_IO) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS_PARAMS_V2),
            "::",
            stringify!(RJ45_IO)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RJ45_Ethernet) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS_PARAMS_V2),
            "::",
            stringify!(RJ45_Ethernet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).houseSyncIncoming) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS_PARAMS_V2),
            "::",
            stringify!(houseSyncIncoming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bHouseSync) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GSYNC_STATUS_PARAMS_V2),
            "::",
            stringify!(bHouseSync)
        )
    );
}
impl _NV_GSYNC_STATUS_PARAMS_V2 {
    #[inline]
    pub fn bInternalSlave(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bInternalSlave(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bInternalSlave: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bInternalSlave: u32 = unsafe { ::std::mem::transmute(bInternalSlave) };
            bInternalSlave as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_STATUS_PARAMS_V2 = _NV_GSYNC_STATUS_PARAMS_V2;
pub type NV_GSYNC_STATUS_PARAMS = NV_GSYNC_STATUS_PARAMS_V2;
extern "C" {
    #[doc = "!   DESCRIPTION: This API queries for sync status parameters as defined in NV_GSYNC_STATUS_PARAMS.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 313\n!\n! \\param [in]  hNvGSyncDevice   The caller provides the handle of the GSync device for which to get parameters\n! \\param [out] *pStatusParams   The caller provides the storage space. NvAPI_GSync_GetStatusParameters populates *pStatusParams with\n!                               values.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!          If there are return error codes with specific meaning for this API, they are listed below.\n! \\retval ::NVAPI_INVALID_ARGUMENT            hNvGSyncDevice is NULL / pStatusParams is NULL.\n! \\retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND     The queried Graphics system does not have any GSync Device.\n!\n! \\ingroup gsyncapi\n"]
    pub fn NvAPI_GSync_GetStatusParameters(
        hNvGSyncDevice: NvGSyncDeviceHandle,
        pStatusParams: *mut NV_GSYNC_STATUS_PARAMS,
    ) -> NvAPI_Status;
}
#[doc = "!< Fall back to the default settings"]
pub const NVAPI_VSYNC_MODE_NVAPI_VSYNC_DEFAULT: NVAPI_VSYNC_MODE = 0;
#[doc = "!< Force vertical sync off when performance is more important than image quality and for benchmarking\""]
pub const NVAPI_VSYNC_MODE_NVAPI_VSYNC_OFF: NVAPI_VSYNC_MODE = 1;
#[doc = "!< Force vertical sync on when image quality is more important than performance"]
pub const NVAPI_VSYNC_MODE_NVAPI_VSYNC_ON: NVAPI_VSYNC_MODE = 2;
#[doc = "!< Select adaptive to turn vertical sync on or off based on the frame rate."]
pub const NVAPI_VSYNC_MODE_NVAPI_VSYNC_ADAPTIVE: NVAPI_VSYNC_MODE = 3;
#[doc = "!<"]
pub const NVAPI_VSYNC_MODE_NVAPI_VSYNC_ADAPTIVE_HALF_REFRESH_RATE: NVAPI_VSYNC_MODE = 4;
#[doc = "! \\ingroup dx"]
pub type NVAPI_VSYNC_MODE = ::std::os::raw::c_int;
pub const _NV_RESOLVE_MODE_NV_RESOLVE_MODE_SAMPLE_0: _NV_RESOLVE_MODE = 0;
#[doc = "! \\ingroup dx\n! Valid modes for NvAPI_D3D11_ResolveSubresourceRegion() and NvAPI_D3D12_ResolveSubresourceRegion"]
pub type _NV_RESOLVE_MODE = ::std::os::raw::c_int;
#[doc = "! \\ingroup dx\n! Valid modes for NvAPI_D3D11_ResolveSubresourceRegion() and NvAPI_D3D12_ResolveSubresourceRegion"]
pub use self::_NV_RESOLVE_MODE as NV_RESOLVE_MODE;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to query the support of Single Pass Stereo HW feature\n! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1 {
    pub version: NvU32,
    pub bSinglePassStereoSupported: NvU32,
}
#[test]
fn bindgen_test_layout__NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSinglePassStereoSupported) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1),
            "::",
            stringify!(bSinglePassStereoSupported)
        )
    );
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to query the support of Single Pass Stereo HW feature\n! \\ingroup dx"]
pub type NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1 =
    _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2),
            "::",
            stringify!(version)
        )
    );
}
impl _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2 {
    #[inline]
    pub fn bSinglePassStereoSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSinglePassStereoSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSinglePassStereoXYZWSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSinglePassStereoXYZWSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bSinglePassStereoSupported: NvU32,
        bSinglePassStereoXYZWSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bSinglePassStereoSupported: u32 =
                unsafe { ::std::mem::transmute(bSinglePassStereoSupported) };
            bSinglePassStereoSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSinglePassStereoXYZWSupported: u32 =
                unsafe { ::std::mem::transmute(bSinglePassStereoXYZWSupported) };
            bSinglePassStereoXYZWSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2 =
    _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2;
pub type NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS = NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to query the support of MultiView HW feature\n! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1),
            "::",
            stringify!(version)
        )
    );
}
impl _NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1 {
    #[inline]
    pub fn bMultiViewSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bMultiViewSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSinglePassStereoSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSinglePassStereoSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSinglePassStereoXYZWSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSinglePassStereoXYZWSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bMultiViewSupported: NvU32,
        bSinglePassStereoSupported: NvU32,
        bSinglePassStereoXYZWSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bMultiViewSupported: u32 = unsafe { ::std::mem::transmute(bMultiViewSupported) };
            bMultiViewSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSinglePassStereoSupported: u32 =
                unsafe { ::std::mem::transmute(bSinglePassStereoSupported) };
            bSinglePassStereoSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bSinglePassStereoXYZWSupported: u32 =
                unsafe { ::std::mem::transmute(bSinglePassStereoXYZWSupported) };
            bSinglePassStereoXYZWSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to query the support of MultiView HW feature\n! \\ingroup dx"]
pub type NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1 = _NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to query the support of MultiView HW feature\n! \\ingroup dx"]
pub type NV_QUERY_MULTIVIEW_SUPPORT_PARAMS = NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used for setting the Mode for MultiView HW Feature.\n! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MULTIVIEW_PARAMS_V1 {
    pub version: NvU32,
    pub numViews: NvU32,
    pub renderTargetIndexOffset: [NvU32; 4usize],
    pub independentViewportMaskEnable: NvU8,
}
#[test]
fn bindgen_test_layout__NV_MULTIVIEW_PARAMS_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MULTIVIEW_PARAMS_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MULTIVIEW_PARAMS_V1>(),
        28usize,
        concat!("Size of: ", stringify!(_NV_MULTIVIEW_PARAMS_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MULTIVIEW_PARAMS_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MULTIVIEW_PARAMS_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MULTIVIEW_PARAMS_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numViews) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MULTIVIEW_PARAMS_V1),
            "::",
            stringify!(numViews)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).renderTargetIndexOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MULTIVIEW_PARAMS_V1),
            "::",
            stringify!(renderTargetIndexOffset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).independentViewportMaskEnable) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MULTIVIEW_PARAMS_V1),
            "::",
            stringify!(independentViewportMaskEnable)
        )
    );
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used for setting the Mode for MultiView HW Feature.\n! \\ingroup dx"]
pub type NV_MULTIVIEW_PARAMS_V1 = _NV_MULTIVIEW_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used for setting the Mode for MultiView HW Feature.\n! \\ingroup dx"]
pub type NV_MULTIVIEW_PARAMS = NV_MULTIVIEW_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to query the support of Lens Matched Shading HW feature\n! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_QUERY_MODIFIED_W_SUPPORT_PARAMS {
    pub version: NvU32,
    pub bModifiedWSupported: NvU32,
}
#[test]
fn bindgen_test_layout__NV_QUERY_MODIFIED_W_SUPPORT_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bModifiedWSupported) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_QUERY_MODIFIED_W_SUPPORT_PARAMS),
            "::",
            stringify!(bModifiedWSupported)
        )
    );
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to query the support of Lens Matched Shading HW feature\n! \\ingroup dx"]
pub type NV_QUERY_MODIFIED_W_SUPPORT_PARAMS_V1 = _NV_QUERY_MODIFIED_W_SUPPORT_PARAMS;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to query the support of Lens Matched Shading HW feature\n! \\ingroup dx"]
pub type NV_QUERY_MODIFIED_W_SUPPORT_PARAMS = NV_QUERY_MODIFIED_W_SUPPORT_PARAMS_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MODIFIED_W_COEFFICIENTS {
    pub fA: f32,
    pub fB: f32,
    pub fAReserved: f32,
    pub fBReserved: f32,
    pub fReserved: [f32; 2usize],
}
#[test]
fn bindgen_test_layout__NV_MODIFIED_W_COEFFICIENTS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MODIFIED_W_COEFFICIENTS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MODIFIED_W_COEFFICIENTS>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_MODIFIED_W_COEFFICIENTS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MODIFIED_W_COEFFICIENTS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MODIFIED_W_COEFFICIENTS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MODIFIED_W_COEFFICIENTS),
            "::",
            stringify!(fA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fB) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MODIFIED_W_COEFFICIENTS),
            "::",
            stringify!(fB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAReserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MODIFIED_W_COEFFICIENTS),
            "::",
            stringify!(fAReserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fBReserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MODIFIED_W_COEFFICIENTS),
            "::",
            stringify!(fBReserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fReserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MODIFIED_W_COEFFICIENTS),
            "::",
            stringify!(fReserved)
        )
    );
}
pub type NV_MODIFIED_W_COEFFICIENTS = _NV_MODIFIED_W_COEFFICIENTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MODIFIED_W_PARAMS {
    pub version: NvU32,
    pub numEntries: NvU32,
    pub modifiedWCoefficients: [NV_MODIFIED_W_COEFFICIENTS; 16usize],
    pub id: NvU32,
    pub reserved: [NvU32; 16usize],
}
#[test]
fn bindgen_test_layout__NV_MODIFIED_W_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_MODIFIED_W_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_MODIFIED_W_PARAMS>(),
        460usize,
        concat!("Size of: ", stringify!(_NV_MODIFIED_W_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MODIFIED_W_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_MODIFIED_W_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MODIFIED_W_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numEntries) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MODIFIED_W_PARAMS),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modifiedWCoefficients) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MODIFIED_W_PARAMS),
            "::",
            stringify!(modifiedWCoefficients)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MODIFIED_W_PARAMS),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MODIFIED_W_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
pub type NV_MODIFIED_W_PARAMS_V1 = _NV_MODIFIED_W_PARAMS;
pub type NV_MODIFIED_W_PARAMS = NV_MODIFIED_W_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to get sleep status\n! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GET_SLEEP_STATUS_PARAMS {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    #[doc = "!< (OUT) Is low latency mode enabled?"]
    pub bLowLatencyMode: NvBool,
    #[doc = "!< (OUT) Is fullscreen VRR enabled?"]
    pub bFsVrr: NvBool,
    #[doc = "!< (OUT) Is Control Panel overriding VSYNC ON?"]
    pub bCplVsyncOn: NvBool,
    #[doc = "!< (IN) Reserved. Must be set to 0s."]
    pub rsvd: [NvU8; 126usize],
}
#[test]
fn bindgen_test_layout__NV_GET_SLEEP_STATUS_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GET_SLEEP_STATUS_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GET_SLEEP_STATUS_PARAMS>(),
        136usize,
        concat!("Size of: ", stringify!(_NV_GET_SLEEP_STATUS_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GET_SLEEP_STATUS_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_GET_SLEEP_STATUS_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_SLEEP_STATUS_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bLowLatencyMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_SLEEP_STATUS_PARAMS),
            "::",
            stringify!(bLowLatencyMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bFsVrr) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_SLEEP_STATUS_PARAMS),
            "::",
            stringify!(bFsVrr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bCplVsyncOn) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_SLEEP_STATUS_PARAMS),
            "::",
            stringify!(bCplVsyncOn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GET_SLEEP_STATUS_PARAMS),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to get sleep status\n! \\ingroup dx"]
pub type NV_GET_SLEEP_STATUS_PARAMS_V1 = _NV_GET_SLEEP_STATUS_PARAMS;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to get sleep status\n! \\ingroup dx"]
pub type NV_GET_SLEEP_STATUS_PARAMS = NV_GET_SLEEP_STATUS_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to set sleep mode\n! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_SET_SLEEP_MODE_PARAMS {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    #[doc = "!< (IN) Low latency mode enable/disable."]
    pub bLowLatencyMode: NvBool,
    #[doc = "!< (IN) Request maximum GPU clock frequency regardless of workload."]
    pub bLowLatencyBoost: NvBool,
    #[doc = "!< (IN) Minimum frame interval in microseconds. 0 = no frame rate limit."]
    pub minimumIntervalUs: NvU32,
    #[doc = "!< (IN) Allow latency markers to be used for runtime optimizations."]
    pub bUseMarkersToOptimize: NvBool,
    #[doc = "!< (IN) Reserved. Must be set to 0s."]
    pub rsvd: [NvU8; 31usize],
}
#[test]
fn bindgen_test_layout__NV_SET_SLEEP_MODE_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_SET_SLEEP_MODE_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_SET_SLEEP_MODE_PARAMS>(),
        44usize,
        concat!("Size of: ", stringify!(_NV_SET_SLEEP_MODE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SET_SLEEP_MODE_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_SET_SLEEP_MODE_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_SLEEP_MODE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bLowLatencyMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_SLEEP_MODE_PARAMS),
            "::",
            stringify!(bLowLatencyMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bLowLatencyBoost) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_SLEEP_MODE_PARAMS),
            "::",
            stringify!(bLowLatencyBoost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimumIntervalUs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_SLEEP_MODE_PARAMS),
            "::",
            stringify!(minimumIntervalUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bUseMarkersToOptimize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_SLEEP_MODE_PARAMS),
            "::",
            stringify!(bUseMarkersToOptimize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_SLEEP_MODE_PARAMS),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to set sleep mode\n! \\ingroup dx"]
pub type NV_SET_SLEEP_MODE_PARAMS_V1 = _NV_SET_SLEEP_MODE_PARAMS;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to set sleep mode\n! \\ingroup dx"]
pub type NV_SET_SLEEP_MODE_PARAMS = NV_SET_SLEEP_MODE_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 10 and higher\n!\n! Used to send Reflex Sync data to UMD\n! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_SET_REFLEX_SYNC_PARAMS {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< (IN) Interval between VBLANKs in microseconds. (0 means N/A)"]
    pub vblankIntervalUs: NvU32,
    #[doc = "!< (IN) Amount of time in the completed frame queue. Can be negative. (0 means N/A)"]
    pub timeInQueueUs: NvS32,
    #[doc = "!< (IN) Target amount of time in the completed frame queue. (0 means N/A)"]
    pub timeInQueueUsTarget: NvU32,
    #[doc = "!< (IN) Reserved. Must be set to 0s."]
    pub rsvd: [NvU8; 28usize],
}
#[test]
fn bindgen_test_layout__NV_SET_REFLEX_SYNC_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_SET_REFLEX_SYNC_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_SET_REFLEX_SYNC_PARAMS>(),
        48usize,
        concat!("Size of: ", stringify!(_NV_SET_REFLEX_SYNC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_SET_REFLEX_SYNC_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_SET_REFLEX_SYNC_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_REFLEX_SYNC_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vblankIntervalUs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_REFLEX_SYNC_PARAMS),
            "::",
            stringify!(vblankIntervalUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeInQueueUs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_REFLEX_SYNC_PARAMS),
            "::",
            stringify!(timeInQueueUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeInQueueUsTarget) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_REFLEX_SYNC_PARAMS),
            "::",
            stringify!(timeInQueueUsTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_SET_REFLEX_SYNC_PARAMS),
            "::",
            stringify!(rsvd)
        )
    );
}
impl _NV_SET_REFLEX_SYNC_PARAMS {
    #[inline]
    pub fn bEnable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bEnable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bDisable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flagsRsvd(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_flagsRsvd(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bEnable: NvU32,
        bDisable: NvU32,
        flagsRsvd: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bEnable: u32 = unsafe { ::std::mem::transmute(bEnable) };
            bEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bDisable: u32 = unsafe { ::std::mem::transmute(bDisable) };
            bDisable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let flagsRsvd: u32 = unsafe { ::std::mem::transmute(flagsRsvd) };
            flagsRsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! SUPPORTED OS:  Windows 10 and higher\n!\n! Used to send Reflex Sync data to UMD\n! \\ingroup dx"]
pub type NV_SET_REFLEX_SYNC_PARAMS_V1 = _NV_SET_REFLEX_SYNC_PARAMS;
#[doc = "! SUPPORTED OS:  Windows 10 and higher\n!\n! Used to send Reflex Sync data to UMD\n! \\ingroup dx"]
pub type NV_SET_REFLEX_SYNC_PARAMS = NV_SET_REFLEX_SYNC_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to get latency report.\n! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LATENCY_RESULT_PARAMS {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    pub frameReport: [_NV_LATENCY_RESULT_PARAMS_FrameReport; 64usize],
    pub rsvd: [NvU8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LATENCY_RESULT_PARAMS_FrameReport {
    pub frameID: NvU64,
    pub inputSampleTime: NvU64,
    pub simStartTime: NvU64,
    pub simEndTime: NvU64,
    pub renderSubmitStartTime: NvU64,
    pub renderSubmitEndTime: NvU64,
    pub presentStartTime: NvU64,
    pub presentEndTime: NvU64,
    pub driverStartTime: NvU64,
    pub driverEndTime: NvU64,
    pub osRenderQueueStartTime: NvU64,
    pub osRenderQueueEndTime: NvU64,
    pub gpuRenderStartTime: NvU64,
    pub gpuRenderEndTime: NvU64,
    #[doc = "!< (OUT) Difference between gpuRenderStartTime and gpuRenderEndTime, excluding the idles in between, in microseconds."]
    pub gpuActiveRenderTimeUs: NvU32,
    #[doc = "!< (OUT) Difference between previous and current frame's gpuRenderEndTime, in microseconds."]
    pub gpuFrameTimeUs: NvU32,
    pub rsvd: [NvU8; 120usize],
}
#[test]
fn bindgen_test_layout__NV_LATENCY_RESULT_PARAMS_FrameReport() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LATENCY_RESULT_PARAMS_FrameReport> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LATENCY_RESULT_PARAMS_FrameReport>(),
        240usize,
        concat!(
            "Size of: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LATENCY_RESULT_PARAMS_FrameReport>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(frameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputSampleTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(inputSampleTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).simStartTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(simStartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).simEndTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(simEndTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).renderSubmitStartTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(renderSubmitStartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).renderSubmitEndTime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(renderSubmitEndTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).presentStartTime) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(presentStartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).presentEndTime) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(presentEndTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driverStartTime) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(driverStartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driverEndTime) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(driverEndTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).osRenderQueueStartTime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(osRenderQueueStartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).osRenderQueueEndTime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(osRenderQueueEndTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuRenderStartTime) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(gpuRenderStartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuRenderEndTime) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(gpuRenderEndTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuActiveRenderTimeUs) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(gpuActiveRenderTimeUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuFrameTimeUs) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(gpuFrameTimeUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS_FrameReport),
            "::",
            stringify!(rsvd)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_LATENCY_RESULT_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LATENCY_RESULT_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LATENCY_RESULT_PARAMS>(),
        15400usize,
        concat!("Size of: ", stringify!(_NV_LATENCY_RESULT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LATENCY_RESULT_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_LATENCY_RESULT_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameReport) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS),
            "::",
            stringify!(frameReport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        15368usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_RESULT_PARAMS),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to get latency report.\n! \\ingroup dx"]
pub type NV_LATENCY_RESULT_PARAMS_V1 = _NV_LATENCY_RESULT_PARAMS;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used to get latency report.\n! \\ingroup dx"]
pub type NV_LATENCY_RESULT_PARAMS = NV_LATENCY_RESULT_PARAMS_V1;
pub const NV_LATENCY_MARKER_TYPE_SIMULATION_START: NV_LATENCY_MARKER_TYPE = 0;
pub const NV_LATENCY_MARKER_TYPE_SIMULATION_END: NV_LATENCY_MARKER_TYPE = 1;
pub const NV_LATENCY_MARKER_TYPE_RENDERSUBMIT_START: NV_LATENCY_MARKER_TYPE = 2;
pub const NV_LATENCY_MARKER_TYPE_RENDERSUBMIT_END: NV_LATENCY_MARKER_TYPE = 3;
pub const NV_LATENCY_MARKER_TYPE_PRESENT_START: NV_LATENCY_MARKER_TYPE = 4;
pub const NV_LATENCY_MARKER_TYPE_PRESENT_END: NV_LATENCY_MARKER_TYPE = 5;
pub const NV_LATENCY_MARKER_TYPE_INPUT_SAMPLE: NV_LATENCY_MARKER_TYPE = 6;
pub const NV_LATENCY_MARKER_TYPE_TRIGGER_FLASH: NV_LATENCY_MARKER_TYPE = 7;
pub const NV_LATENCY_MARKER_TYPE_PC_LATENCY_PING: NV_LATENCY_MARKER_TYPE = 8;
pub const NV_LATENCY_MARKER_TYPE_OUT_OF_BAND_RENDERSUBMIT_START: NV_LATENCY_MARKER_TYPE = 9;
pub const NV_LATENCY_MARKER_TYPE_OUT_OF_BAND_RENDERSUBMIT_END: NV_LATENCY_MARKER_TYPE = 10;
pub const NV_LATENCY_MARKER_TYPE_OUT_OF_BAND_PRESENT_START: NV_LATENCY_MARKER_TYPE = 11;
pub const NV_LATENCY_MARKER_TYPE_OUT_OF_BAND_PRESENT_END: NV_LATENCY_MARKER_TYPE = 12;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used define latency marker type\n! \\ingroup dx"]
pub type NV_LATENCY_MARKER_TYPE = ::std::os::raw::c_int;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used set latency markers\n! \\ingroup dx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_LATENCY_MARKER_PARAMS {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    pub frameID: NvU64,
    pub markerType: NV_LATENCY_MARKER_TYPE,
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_LATENCY_MARKER_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_LATENCY_MARKER_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_LATENCY_MARKER_PARAMS>(),
        88usize,
        concat!("Size of: ", stringify!(_NV_LATENCY_MARKER_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_LATENCY_MARKER_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_LATENCY_MARKER_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_MARKER_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_MARKER_PARAMS),
            "::",
            stringify!(frameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).markerType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_MARKER_PARAMS),
            "::",
            stringify!(markerType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_LATENCY_MARKER_PARAMS),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used set latency markers\n! \\ingroup dx"]
pub type NV_LATENCY_MARKER_PARAMS_V1 = _NV_LATENCY_MARKER_PARAMS;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used set latency markers\n! \\ingroup dx"]
pub type NV_LATENCY_MARKER_PARAMS = NV_LATENCY_MARKER_PARAMS_V1;
#[doc = "! Used in NvAPI_D3D12_SetAsyncFrameMarker\n! \\ingroup dx"]
pub type NV_ASYNC_FRAME_MARKER_PARAMS_V1 = NV_LATENCY_MARKER_PARAMS_V1;
#[doc = "! SUPPORTED OS:  Windows 7 and higher\n!\n! Used set latency markers\n! \\ingroup dx"]
pub type NV_ASYNC_FRAME_MARKER_PARAMS = NV_ASYNC_FRAME_MARKER_PARAMS_V1;
pub const NV_OUT_OF_BAND_CQ_TYPE_OUT_OF_BAND_RENDER: NV_OUT_OF_BAND_CQ_TYPE = 0;
pub const NV_OUT_OF_BAND_CQ_TYPE_OUT_OF_BAND_PRESENT: NV_OUT_OF_BAND_CQ_TYPE = 1;
#[doc = "! SUPPORTED OS:  Windows 10 and higher\n!\n! Used in NvAPI_D3D12_NotifyOutOfBandCommandQueue\n! \\ingroup dx"]
pub type NV_OUT_OF_BAND_CQ_TYPE = ::std::os::raw::c_int;
pub const _NV_D3D12_WORKSTATION_FEATURE_TYPE_NV_D3D12_WORKSTATION_FEATURE_TYPE_PRESENT_BARRIER:
    _NV_D3D12_WORKSTATION_FEATURE_TYPE = 1;
pub const _NV_D3D12_WORKSTATION_FEATURE_TYPE_NV_D3D12_WORKSTATION_FEATURE_TYPE_RDMA_BAR1_SUPPORT:
    _NV_D3D12_WORKSTATION_FEATURE_TYPE = 2;
#[doc = "! \\ingroup DX"]
pub type _NV_D3D12_WORKSTATION_FEATURE_TYPE = ::std::os::raw::c_int;
#[doc = "! \\ingroup DX"]
pub use self::_NV_D3D12_WORKSTATION_FEATURE_TYPE as NV_D3D12_WORKSTATION_FEATURE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES {
    pub rdmaHeapSize: NvU64,
}
#[test]
fn bindgen_test_layout__NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdmaHeapSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES),
            "::",
            stringify!(rdmaHeapSize)
        )
    );
}
pub type NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES =
    _NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D12_WORKSTATION_FEATURE_PROPERTIES {
    #[doc = "!< (IN) Structure version"]
    pub version: NvU32,
    #[doc = "!< (IN) the type of workstation feature to be queried"]
    pub workstationFeatureType: NV_D3D12_WORKSTATION_FEATURE_TYPE,
    #[doc = "!< (OUT) boolean returning if feature is supported"]
    pub supported: NvBool,
    pub __bindgen_anon_1: _NV_D3D12_WORKSTATION_FEATURE_PROPERTIES__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_D3D12_WORKSTATION_FEATURE_PROPERTIES__bindgen_ty_1 {
    #[doc = "!< (OUT) RDMA feature related information, returned only if\n!<       workstationFeatureType is NV_D3D12_WORKSTATION_FEATURE_TYPE_RDMA_BAR1_SUPPORT"]
    pub rdmaInfo: NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES,
}
#[test]
fn bindgen_test_layout__NV_D3D12_WORKSTATION_FEATURE_PROPERTIES__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdmaInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES__bindgen_ty_1),
            "::",
            stringify!(rdmaInfo)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_D3D12_WORKSTATION_FEATURE_PROPERTIES() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).workstationFeatureType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES),
            "::",
            stringify!(workstationFeatureType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_D3D12_WORKSTATION_FEATURE_PROPERTIES),
            "::",
            stringify!(supported)
        )
    );
}
pub type NVAPI_D3D12_WORKSTATION_FEATURE_PROPERTIES_PARAMS_V1 =
    _NV_D3D12_WORKSTATION_FEATURE_PROPERTIES;
#[doc = "! \\ingroup vidio\n! Unique identifier for VIO owner (process identifier or NVVIOOWNERID_NONE)"]
pub type NVVIOOWNERID = NvU32;
#[doc = "!<  No owner for the device"]
pub const _NVVIOOWNERTYPE_NVVIOOWNERTYPE_NONE: _NVVIOOWNERTYPE = 0;
#[doc = "!<  Application owns the device"]
pub const _NVVIOOWNERTYPE_NVVIOOWNERTYPE_APPLICATION: _NVVIOOWNERTYPE = 1;
#[doc = "!<  Desktop transparent mode owns the device (not applicable for video input)"]
pub const _NVVIOOWNERTYPE_NVVIOOWNERTYPE_DESKTOP: _NVVIOOWNERTYPE = 2;
#[doc = "! Owner type for device"]
pub type _NVVIOOWNERTYPE = ::std::os::raw::c_int;
#[doc = "! Owner type for device"]
pub use self::_NVVIOOWNERTYPE as NVVIOOWNERTYPE;
#[doc = "!< Invalid signal format"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_NONE: _NVVIOSIGNALFORMAT = 0;
#[doc = "!< 01  487i    59.94Hz  (SMPTE259) NTSC"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_487I_59_94_SMPTE259_NTSC: _NVVIOSIGNALFORMAT = 1;
#[doc = "!< 02  576i    50.00Hz  (SMPTE259) PAL"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_576I_50_00_SMPTE259_PAL: _NVVIOSIGNALFORMAT = 2;
#[doc = "!< 03  1035i   60.00Hz  (SMPTE260)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1035I_60_00_SMPTE260: _NVVIOSIGNALFORMAT = 3;
#[doc = "!< 04  1035i   59.94Hz  (SMPTE260)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1035I_59_94_SMPTE260: _NVVIOSIGNALFORMAT = 4;
#[doc = "!< 05  1080i   50.00Hz  (SMPTE295)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_50_00_SMPTE295: _NVVIOSIGNALFORMAT = 5;
#[doc = "!< 06  1080i   60.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_60_00_SMPTE274: _NVVIOSIGNALFORMAT = 6;
#[doc = "!< 07  1080i   59.94Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_59_94_SMPTE274: _NVVIOSIGNALFORMAT = 7;
#[doc = "!< 08  1080i   50.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_50_00_SMPTE274: _NVVIOSIGNALFORMAT = 8;
#[doc = "!< 09  1080p   30.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_30_00_SMPTE274: _NVVIOSIGNALFORMAT = 9;
#[doc = "!< 10  1080p   29.97Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_29_97_SMPTE274: _NVVIOSIGNALFORMAT = 10;
#[doc = "!< 11  1080p   25.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_25_00_SMPTE274: _NVVIOSIGNALFORMAT = 11;
#[doc = "!< 12  1080p   24.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_24_00_SMPTE274: _NVVIOSIGNALFORMAT = 12;
#[doc = "!< 13  1080p   23.976Hz (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_23_976_SMPTE274: _NVVIOSIGNALFORMAT = 13;
#[doc = "!< 14  720p    60.00Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_60_00_SMPTE296: _NVVIOSIGNALFORMAT = 14;
#[doc = "!< 15  720p    59.94Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_59_94_SMPTE296: _NVVIOSIGNALFORMAT = 15;
#[doc = "!< 16  720p    50.00Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_50_00_SMPTE296: _NVVIOSIGNALFORMAT = 16;
#[doc = "!< 17  1080I   48.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_48_00_SMPTE274: _NVVIOSIGNALFORMAT = 17;
#[doc = "!< 18  1080I   47.96Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_47_96_SMPTE274: _NVVIOSIGNALFORMAT = 18;
#[doc = "!< 19  720p    30.00Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_30_00_SMPTE296: _NVVIOSIGNALFORMAT = 19;
#[doc = "!< 20  720p    29.97Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_29_97_SMPTE296: _NVVIOSIGNALFORMAT = 20;
#[doc = "!< 21  720p    25.00Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_25_00_SMPTE296: _NVVIOSIGNALFORMAT = 21;
#[doc = "!< 22  720p    24.00Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_24_00_SMPTE296: _NVVIOSIGNALFORMAT = 22;
#[doc = "!< 23  720p    23.98Hz  (SMPTE296)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_720P_23_98_SMPTE296: _NVVIOSIGNALFORMAT = 23;
#[doc = "!< 24  2048p   30.00Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_30_00_SMPTE372: _NVVIOSIGNALFORMAT = 24;
#[doc = "!< 25  2048p   29.97Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_29_97_SMPTE372: _NVVIOSIGNALFORMAT = 25;
#[doc = "!< 26  2048i   60.00Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_60_00_SMPTE372: _NVVIOSIGNALFORMAT = 26;
#[doc = "!< 27  2048i   59.94Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_59_94_SMPTE372: _NVVIOSIGNALFORMAT = 27;
#[doc = "!< 28  2048p   25.00Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_25_00_SMPTE372: _NVVIOSIGNALFORMAT = 28;
#[doc = "!< 29  2048i   50.00Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_50_00_SMPTE372: _NVVIOSIGNALFORMAT = 29;
#[doc = "!< 30  2048p   24.00Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_24_00_SMPTE372: _NVVIOSIGNALFORMAT = 30;
#[doc = "!< 31  2048p   23.98Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_23_98_SMPTE372: _NVVIOSIGNALFORMAT = 31;
#[doc = "!< 32  2048i   48.00Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_48_00_SMPTE372: _NVVIOSIGNALFORMAT = 32;
#[doc = "!< 33  2048i   47.96Hz  (SMPTE372)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_47_96_SMPTE372: _NVVIOSIGNALFORMAT = 33;
#[doc = "!< 34  1080PsF 25.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080PSF_25_00_SMPTE274: _NVVIOSIGNALFORMAT = 34;
#[doc = "!< 35  1080PsF 29.97Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080PSF_29_97_SMPTE274: _NVVIOSIGNALFORMAT = 35;
#[doc = "!< 36  1080PsF 30.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080PSF_30_00_SMPTE274: _NVVIOSIGNALFORMAT = 36;
#[doc = "!< 37  1080PsF 24.00Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080PSF_24_00_SMPTE274: _NVVIOSIGNALFORMAT = 37;
#[doc = "!< 38  1080PsF 23.98Hz  (SMPTE274)"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080PSF_23_98_SMPTE274: _NVVIOSIGNALFORMAT = 38;
#[doc = "!< 39  1080P   50.00Hz  (SMPTE274) 3G Level A"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_50_00_SMPTE274_3G_LEVEL_A: _NVVIOSIGNALFORMAT =
    39;
#[doc = "!< 40  1080P   59.94Hz  (SMPTE274) 3G Level A"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_59_94_SMPTE274_3G_LEVEL_A: _NVVIOSIGNALFORMAT =
    40;
#[doc = "!< 41  1080P   60.00Hz  (SMPTE274) 3G Level A"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_60_00_SMPTE274_3G_LEVEL_A: _NVVIOSIGNALFORMAT =
    41;
#[doc = "!< 42  1080p   60.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_60_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    42;
#[doc = "!< 43  1080i   60.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_60_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    43;
#[doc = "!< 44  2048i   60.00Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_60_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    44;
#[doc = "!< 45  1080p   50.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_50_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    45;
#[doc = "!< 46  1080i   50.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_50_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    46;
#[doc = "!< 47  2048i   50.00Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_50_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    47;
#[doc = "!< 48  1080p   30.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_30_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    48;
#[doc = "!< 49  2048p   30.00Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_30_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    49;
#[doc = "!< 50  1080p   25.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_25_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    50;
#[doc = "!< 51  2048p   25.00Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_25_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    51;
#[doc = "!< 52  1080p   24.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_24_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    52;
#[doc = "!< 53  2048p   24.00Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_24_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    53;
#[doc = "!< 54  1080i   48.00Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_48_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    54;
#[doc = "!< 55  2048i   48.00Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_48_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    55;
#[doc = "!< 56  1080p   59.94Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_59_94_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    56;
#[doc = "!< 57  1080i   59.94Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_59_94_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    57;
#[doc = "!< 58  2048i   59.94Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_59_94_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    58;
#[doc = "!< 59  1080p   29.97Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_29_97_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    59;
#[doc = "!< 60  2048p   29.97Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_29_97_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    60;
#[doc = "!< 61  1080p   29.98Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080P_23_98_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    61;
#[doc = "!< 62  2048p   29.98Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048P_23_98_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    62;
#[doc = "!< 63  1080i   47.96Hz  (SMPTE274) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_1080I_47_96_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    63;
#[doc = "!< 64  2048i   47.96Hz  (SMPTE372) 3G Level B"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_2048I_47_96_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
    64;
#[doc = "!< 65  To indicate end of signal format list"]
pub const _NVVIOSIGNALFORMAT_NVVIOSIGNALFORMAT_END: _NVVIOSIGNALFORMAT = 65;
#[doc = "! Video signal format and resolution"]
pub type _NVVIOSIGNALFORMAT = ::std::os::raw::c_int;
#[doc = "! Video signal format and resolution"]
pub use self::_NVVIOSIGNALFORMAT as NVVIOSIGNALFORMAT;
#[doc = "!< SMPTE259"]
pub const _NVVIOVIDEOSTANDARD_NVVIOVIDEOSTANDARD_SMPTE259: _NVVIOVIDEOSTANDARD = 0;
#[doc = "!< SMPTE260"]
pub const _NVVIOVIDEOSTANDARD_NVVIOVIDEOSTANDARD_SMPTE260: _NVVIOVIDEOSTANDARD = 1;
#[doc = "!< SMPTE274"]
pub const _NVVIOVIDEOSTANDARD_NVVIOVIDEOSTANDARD_SMPTE274: _NVVIOVIDEOSTANDARD = 2;
#[doc = "!< SMPTE295"]
pub const _NVVIOVIDEOSTANDARD_NVVIOVIDEOSTANDARD_SMPTE295: _NVVIOVIDEOSTANDARD = 3;
#[doc = "!< SMPTE296"]
pub const _NVVIOVIDEOSTANDARD_NVVIOVIDEOSTANDARD_SMPTE296: _NVVIOVIDEOSTANDARD = 4;
#[doc = "!< SMPTE372"]
pub const _NVVIOVIDEOSTANDARD_NVVIOVIDEOSTANDARD_SMPTE372: _NVVIOVIDEOSTANDARD = 5;
#[doc = "! SMPTE standards format"]
pub type _NVVIOVIDEOSTANDARD = ::std::os::raw::c_int;
#[doc = "! SMPTE standards format"]
pub use self::_NVVIOVIDEOSTANDARD as NVVIOVIDEOSTANDARD;
#[doc = "!< Standard-definition (SD)"]
pub const _NVVIOVIDEOTYPE_NVVIOVIDEOTYPE_SD: _NVVIOVIDEOTYPE = 0;
#[doc = "!< High-definition     (HD)"]
pub const _NVVIOVIDEOTYPE_NVVIOVIDEOTYPE_HD: _NVVIOVIDEOTYPE = 1;
#[doc = "! HD or SD video type"]
pub type _NVVIOVIDEOTYPE = ::std::os::raw::c_int;
#[doc = "! HD or SD video type"]
pub use self::_NVVIOVIDEOTYPE as NVVIOVIDEOTYPE;
#[doc = "!< Progressive               (p)"]
pub const _NVVIOINTERLACEMODE_NVVIOINTERLACEMODE_PROGRESSIVE: _NVVIOINTERLACEMODE = 0;
#[doc = "!< Interlace                 (i)"]
pub const _NVVIOINTERLACEMODE_NVVIOINTERLACEMODE_INTERLACE: _NVVIOINTERLACEMODE = 1;
#[doc = "!< Progressive Segment Frame (psf)"]
pub const _NVVIOINTERLACEMODE_NVVIOINTERLACEMODE_PSF: _NVVIOINTERLACEMODE = 2;
#[doc = "! Interlace mode"]
pub type _NVVIOINTERLACEMODE = ::std::os::raw::c_int;
#[doc = "! Interlace mode"]
pub use self::_NVVIOINTERLACEMODE as NVVIOINTERLACEMODE;
#[doc = "!< Invalid DataFormat"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_UNKNOWN: _NVVIODATAFORMAT = -1;
#[doc = "!< R8:G8:B8                => YCrCb  (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R8G8B8_TO_YCRCB444: _NVVIODATAFORMAT = 0;
#[doc = "!< R8:G8:B8:A8             => YCrCbA (4:4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4444: _NVVIODATAFORMAT = 1;
#[doc = "!< R8:G8:B8:Z10            => YCrCbZ (4:4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4444: _NVVIODATAFORMAT = 2;
#[doc = "!< R8:G8:B8                => YCrCb  (4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R8G8B8_TO_YCRCB422: _NVVIODATAFORMAT = 3;
#[doc = "!< R8:G8:B8:A8             => YCrCbA (4:2:2:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4224: _NVVIODATAFORMAT = 4;
#[doc = "!< R8:G8:B8:Z10            => YCrCbZ (4:2:2:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4224: _NVVIODATAFORMAT = 5;
#[doc = "!< R8:G8:B8                => RGB    (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X8X8X8_444_PASSTHRU: _NVVIODATAFORMAT = 6;
#[doc = "!< R8:G8:B8:A8             => RGBA   (4:4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X8X8X8A8_4444_PASSTHRU: _NVVIODATAFORMAT = 7;
#[doc = "!< R8:G8:B8:Z10            => RGBZ   (4:4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X8X8X8Z10_4444_PASSTHRU: _NVVIODATAFORMAT = 8;
#[doc = "!< Y10:CR10:CB10           => YCrCb  (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X10X10X10_444_PASSTHRU: _NVVIODATAFORMAT = 9;
#[doc = "!< Y10:CR8:CB8             => YCrCb  (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X10X8X8_444_PASSTHRU: _NVVIODATAFORMAT = 10;
#[doc = "!< Y10:CR8:CB8:A10         => YCrCbA (4:4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X10X8X8A10_4444_PASSTHRU: _NVVIODATAFORMAT = 11;
#[doc = "!< Y10:CR8:CB8:Z10         => YCrCbZ (4:4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X10X8X8Z10_4444_PASSTHRU: _NVVIODATAFORMAT = 12;
#[doc = "!< R8:G8:B8 + R8:G8:B8     => YCrCb  (4:2:2 + 4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_DUAL_R8G8B8_TO_DUAL_YCRCB422: _NVVIODATAFORMAT = 13;
#[doc = "!< Y8:CR8:CB8 + Y8:CR8:CB8 => YCrCb  (4:2:2 + 4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_DUAL_X8X8X8_TO_DUAL_422_PASSTHRU: _NVVIODATAFORMAT = 14;
#[doc = "!< R10:G10:B10             => YCrCb  (4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R10G10B10_TO_YCRCB422: _NVVIODATAFORMAT = 15;
#[doc = "!< R10:G10:B10             => YCrCb  (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R10G10B10_TO_YCRCB444: _NVVIODATAFORMAT = 16;
#[doc = "!< X12:X12:X12             => XXX    (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X12X12X12_444_PASSTHRU: _NVVIODATAFORMAT = 17;
#[doc = "!< X12:X12:X12             => XXX    (4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_X12X12X12_422_PASSTHRU: _NVVIODATAFORMAT = 18;
#[doc = "!< Y10:CR10:CB10           => YCrCb  (4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_Y10CR10CB10_TO_YCRCB422: _NVVIODATAFORMAT = 19;
#[doc = "!< Y8:CR8:CB8              => YCrCb  (4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_Y8CR8CB8_TO_YCRCB422: _NVVIODATAFORMAT = 20;
#[doc = "!< Y10:CR8:CB8:A10         => YCrCbA (4:2:2:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_Y10CR8CB8A10_TO_YCRCBA4224: _NVVIODATAFORMAT = 21;
#[doc = "!< R10:G10:B10             => RGB    (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R10G10B10_TO_RGB444: _NVVIODATAFORMAT = 22;
#[doc = "!< R12:G12:B12             => YCrCb  (4:4:4)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R12G12B12_TO_YCRCB444: _NVVIODATAFORMAT = 23;
#[doc = "!< R12:G12:B12             => YCrCb  (4:2:2)"]
pub const _NVVIODATAFORMAT_NVVIODATAFORMAT_R12G12B12_TO_YCRCB422: _NVVIODATAFORMAT = 24;
#[doc = "! Video data format"]
pub type _NVVIODATAFORMAT = ::std::os::raw::c_int;
#[doc = "! Video data format"]
pub use self::_NVVIODATAFORMAT as NVVIODATAFORMAT;
#[doc = "!< Output to entire video resolution (full size)"]
pub const _NVVIOOUTPUTAREA_NVVIOOUTPUTAREA_FULLSIZE: _NVVIOOUTPUTAREA = 0;
#[doc = "!< Output to centered 90% of video resolution (safe action)"]
pub const _NVVIOOUTPUTAREA_NVVIOOUTPUTAREA_SAFEACTION: _NVVIOOUTPUTAREA = 1;
#[doc = "!< Output to centered 80% of video resolution (safe title)"]
pub const _NVVIOOUTPUTAREA_NVVIOOUTPUTAREA_SAFETITLE: _NVVIOOUTPUTAREA = 2;
#[doc = "! Video output area"]
pub type _NVVIOOUTPUTAREA = ::std::os::raw::c_int;
#[doc = "! Video output area"]
pub use self::_NVVIOOUTPUTAREA as NVVIOOUTPUTAREA;
#[doc = "!< SDI Sync  (Digital input)"]
pub const _NVVIOSYNCSOURCE_NVVIOSYNCSOURCE_SDISYNC: _NVVIOSYNCSOURCE = 0;
#[doc = "!< COMP Sync (Composite input)"]
pub const _NVVIOSYNCSOURCE_NVVIOSYNCSOURCE_COMPSYNC: _NVVIOSYNCSOURCE = 1;
#[doc = "! Synchronization source"]
pub type _NVVIOSYNCSOURCE = ::std::os::raw::c_int;
#[doc = "! Synchronization source"]
pub use self::_NVVIOSYNCSOURCE as NVVIOSYNCSOURCE;
#[doc = "!< Auto-detect"]
pub const _NVVIOCOMPSYNCTYPE_NVVIOCOMPSYNCTYPE_AUTO: _NVVIOCOMPSYNCTYPE = 0;
#[doc = "!< Bi-level signal"]
pub const _NVVIOCOMPSYNCTYPE_NVVIOCOMPSYNCTYPE_BILEVEL: _NVVIOCOMPSYNCTYPE = 1;
#[doc = "!< Tri-level signal"]
pub const _NVVIOCOMPSYNCTYPE_NVVIOCOMPSYNCTYPE_TRILEVEL: _NVVIOCOMPSYNCTYPE = 2;
#[doc = "! Composite synchronization type"]
pub type _NVVIOCOMPSYNCTYPE = ::std::os::raw::c_int;
#[doc = "! Composite synchronization type"]
pub use self::_NVVIOCOMPSYNCTYPE as NVVIOCOMPSYNCTYPE;
#[doc = "!< Not in use"]
pub const _NVVIOINPUTOUTPUTSTATUS_NVINPUTOUTPUTSTATUS_OFF: _NVVIOINPUTOUTPUTSTATUS = 0;
#[doc = "!< Error detected"]
pub const _NVVIOINPUTOUTPUTSTATUS_NVINPUTOUTPUTSTATUS_ERROR: _NVVIOINPUTOUTPUTSTATUS = 1;
#[doc = "!< SDI (standard-definition)"]
pub const _NVVIOINPUTOUTPUTSTATUS_NVINPUTOUTPUTSTATUS_SDI_SD: _NVVIOINPUTOUTPUTSTATUS = 2;
#[doc = "!< SDI (high-definition)"]
pub const _NVVIOINPUTOUTPUTSTATUS_NVINPUTOUTPUTSTATUS_SDI_HD: _NVVIOINPUTOUTPUTSTATUS = 3;
#[doc = "! Video input output status"]
pub type _NVVIOINPUTOUTPUTSTATUS = ::std::os::raw::c_int;
#[doc = "! Video input output status"]
pub use self::_NVVIOINPUTOUTPUTSTATUS as NVVIOINPUTOUTPUTSTATUS;
#[doc = "!< Sync not detected"]
pub const _NVVIOSYNCSTATUS_NVVIOSYNCSTATUS_OFF: _NVVIOSYNCSTATUS = 0;
#[doc = "!< Error detected"]
pub const _NVVIOSYNCSTATUS_NVVIOSYNCSTATUS_ERROR: _NVVIOSYNCSTATUS = 1;
#[doc = "!< Genlock in use, format mismatch with output"]
pub const _NVVIOSYNCSTATUS_NVVIOSYNCSTATUS_SYNCLOSS: _NVVIOSYNCSTATUS = 2;
#[doc = "!< Composite sync"]
pub const _NVVIOSYNCSTATUS_NVVIOSYNCSTATUS_COMPOSITE: _NVVIOSYNCSTATUS = 3;
#[doc = "!< SDI sync (standard-definition)"]
pub const _NVVIOSYNCSTATUS_NVVIOSYNCSTATUS_SDI_SD: _NVVIOSYNCSTATUS = 4;
#[doc = "!< SDI sync (high-definition)"]
pub const _NVVIOSYNCSTATUS_NVVIOSYNCSTATUS_SDI_HD: _NVVIOSYNCSTATUS = 5;
#[doc = "! Synchronization input status"]
pub type _NVVIOSYNCSTATUS = ::std::os::raw::c_int;
#[doc = "! Synchronization input status"]
pub use self::_NVVIOSYNCSTATUS as NVVIOSYNCSTATUS;
#[doc = "!< Sync not detected"]
pub const _NVVIOCAPTURESTATUS_NVVIOSTATUS_STOPPED: _NVVIOCAPTURESTATUS = 0;
#[doc = "!< Error detected"]
pub const _NVVIOCAPTURESTATUS_NVVIOSTATUS_RUNNING: _NVVIOCAPTURESTATUS = 1;
#[doc = "!< Genlock in use, format mismatch with output"]
pub const _NVVIOCAPTURESTATUS_NVVIOSTATUS_ERROR: _NVVIOCAPTURESTATUS = 2;
#[doc = "! Video Capture Status"]
pub type _NVVIOCAPTURESTATUS = ::std::os::raw::c_int;
#[doc = "! Video Capture Status"]
pub use self::_NVVIOCAPTURESTATUS as NVVIOCAPTURESTATUS;
#[doc = "!< Input Status"]
pub const _NVVIOSTATUSTYPE_NVVIOSTATUSTYPE_IN: _NVVIOSTATUSTYPE = 0;
#[doc = "!< Output Status"]
pub const _NVVIOSTATUSTYPE_NVVIOSTATUSTYPE_OUT: _NVVIOSTATUSTYPE = 1;
#[doc = "! Video Capture Status"]
pub type _NVVIOSTATUSTYPE = ::std::os::raw::c_int;
#[doc = "! Video Capture Status"]
pub use self::_NVVIOSTATUSTYPE as NVVIOSTATUSTYPE;
#[doc = "!< Input Status"]
pub const _NVVIOCONFIGTYPE_NVVIOCONFIGTYPE_IN: _NVVIOCONFIGTYPE = 0;
#[doc = "!< Output Status"]
pub const _NVVIOCONFIGTYPE_NVVIOCONFIGTYPE_OUT: _NVVIOCONFIGTYPE = 1;
#[doc = "! Device configuration"]
pub type _NVVIOCONFIGTYPE = ::std::os::raw::c_int;
#[doc = "! Device configuration"]
pub use self::_NVVIOCONFIGTYPE as NVVIOCONFIGTYPE;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_UNKNOWN: _NVVIOCOLORSPACE = 0;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_YCBCR: _NVVIOCOLORSPACE = 1;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_YCBCRA: _NVVIOCOLORSPACE = 2;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_YCBCRD: _NVVIOCOLORSPACE = 3;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_GBR: _NVVIOCOLORSPACE = 4;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_GBRA: _NVVIOCOLORSPACE = 5;
pub const _NVVIOCOLORSPACE_NVVIOCOLORSPACE_GBRD: _NVVIOCOLORSPACE = 6;
pub type _NVVIOCOLORSPACE = ::std::os::raw::c_int;
pub use self::_NVVIOCOLORSPACE as NVVIOCOLORSPACE;
pub const _NVVIOCOMPONENTSAMPLING_NVVIOCOMPONENTSAMPLING_UNKNOWN: _NVVIOCOMPONENTSAMPLING = 0;
pub const _NVVIOCOMPONENTSAMPLING_NVVIOCOMPONENTSAMPLING_4444: _NVVIOCOMPONENTSAMPLING = 1;
pub const _NVVIOCOMPONENTSAMPLING_NVVIOCOMPONENTSAMPLING_4224: _NVVIOCOMPONENTSAMPLING = 2;
pub const _NVVIOCOMPONENTSAMPLING_NVVIOCOMPONENTSAMPLING_444: _NVVIOCOMPONENTSAMPLING = 3;
pub const _NVVIOCOMPONENTSAMPLING_NVVIOCOMPONENTSAMPLING_422: _NVVIOCOMPONENTSAMPLING = 4;
#[doc = "! Component sampling"]
pub type _NVVIOCOMPONENTSAMPLING = ::std::os::raw::c_int;
#[doc = "! Component sampling"]
pub use self::_NVVIOCOMPONENTSAMPLING as NVVIOCOMPONENTSAMPLING;
pub const _NVVIOBITSPERCOMPONENT_NVVIOBITSPERCOMPONENT_UNKNOWN: _NVVIOBITSPERCOMPONENT = 0;
pub const _NVVIOBITSPERCOMPONENT_NVVIOBITSPERCOMPONENT_8: _NVVIOBITSPERCOMPONENT = 1;
pub const _NVVIOBITSPERCOMPONENT_NVVIOBITSPERCOMPONENT_10: _NVVIOBITSPERCOMPONENT = 2;
pub const _NVVIOBITSPERCOMPONENT_NVVIOBITSPERCOMPONENT_12: _NVVIOBITSPERCOMPONENT = 3;
pub type _NVVIOBITSPERCOMPONENT = ::std::os::raw::c_int;
pub use self::_NVVIOBITSPERCOMPONENT as NVVIOBITSPERCOMPONENT;
pub const _NVVIOLINKID_NVVIOLINKID_UNKNOWN: _NVVIOLINKID = 0;
pub const _NVVIOLINKID_NVVIOLINKID_A: _NVVIOLINKID = 1;
pub const _NVVIOLINKID_NVVIOLINKID_B: _NVVIOLINKID = 2;
pub const _NVVIOLINKID_NVVIOLINKID_C: _NVVIOLINKID = 3;
pub const _NVVIOLINKID_NVVIOLINKID_D: _NVVIOLINKID = 4;
pub type _NVVIOLINKID = ::std::os::raw::c_int;
pub use self::_NVVIOLINKID as NVVIOLINKID;
pub const _NVVIOANCPARITYCOMPUTATION_NVVIOANCPARITYCOMPUTATION_AUTO: _NVVIOANCPARITYCOMPUTATION = 0;
pub const _NVVIOANCPARITYCOMPUTATION_NVVIOANCPARITYCOMPUTATION_ON: _NVVIOANCPARITYCOMPUTATION = 1;
pub const _NVVIOANCPARITYCOMPUTATION_NVVIOANCPARITYCOMPUTATION_OFF: _NVVIOANCPARITYCOMPUTATION = 2;
pub type _NVVIOANCPARITYCOMPUTATION = ::std::os::raw::c_int;
pub use self::_NVVIOANCPARITYCOMPUTATION as NVVIOANCPARITYCOMPUTATION;
#[doc = "! Device capabilities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOCAPS {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Graphics adapter name"]
    pub adapterName: NvAPI_String,
    #[doc = "!< Graphics adapter classes (NVVIOCLASS_SDI mask)"]
    pub adapterClass: NvU32,
    #[doc = "!< Graphics adapter capabilities (NVVIOCAPS_* mask)"]
    pub adapterCaps: NvU32,
    #[doc = "!< On-board DIP switch settings bits"]
    pub dipSwitch: NvU32,
    #[doc = "!< On-board DIP switch settings reserved bits"]
    pub dipSwitchReserved: NvU32,
    #[doc = "!< Board ID"]
    pub boardID: NvU32,
    pub driver: _NVVIOCAPS__bindgen_ty_1,
    pub firmWare: _NVVIOCAPS__bindgen_ty_2,
    #[doc = "!< Unique identifier for owner of video output (NVVIOOWNERID_INVALID if free running)"]
    pub ownerId: NVVIOOWNERID,
    #[doc = "!< Owner type (OpenGL application or Desktop mode)"]
    pub ownerType: NVVIOOWNERTYPE,
}
#[doc = "! Driver version"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOCAPS__bindgen_ty_1 {
    #[doc = "!< Major version. For GVI, majorVersion contains MajorVersion(HIWORD) And MinorVersion(LOWORD)"]
    pub majorVersion: NvU32,
    #[doc = "!< Minor version. For GVI, minorVersion contains Revison(HIWORD) And Build(LOWORD)"]
    pub minorVersion: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOCAPS__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOCAPS__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCAPS__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NVVIOCAPS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCAPS__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCAPS__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).majorVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS__bindgen_ty_1),
            "::",
            stringify!(majorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minorVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS__bindgen_ty_1),
            "::",
            stringify!(minorVersion)
        )
    );
}
#[doc = "! Firmware version"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOCAPS__bindgen_ty_2 {
    #[doc = "!< Major version. In version 2, for both GVI and GVO, majorVersion contains MajorVersion(HIWORD) And MinorVersion(LOWORD)"]
    pub majorVersion: NvU32,
    #[doc = "!< Minor version. In version 2, for both GVI and GVO, minorVersion contains Revison(HIWORD) And Build(LOWORD)"]
    pub minorVersion: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOCAPS__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOCAPS__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCAPS__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_NVVIOCAPS__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCAPS__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCAPS__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).majorVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS__bindgen_ty_2),
            "::",
            stringify!(majorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minorVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS__bindgen_ty_2),
            "::",
            stringify!(minorVersion)
        )
    );
}
#[test]
fn bindgen_test_layout__NVVIOCAPS() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOCAPS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCAPS>(),
        4144usize,
        concat!("Size of: ", stringify!(_NVVIOCAPS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCAPS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCAPS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adapterName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS),
            "::",
            stringify!(adapterName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adapterClass) as usize - ptr as usize },
        4100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS),
            "::",
            stringify!(adapterClass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adapterCaps) as usize - ptr as usize },
        4104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS),
            "::",
            stringify!(adapterCaps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dipSwitch) as usize - ptr as usize },
        4108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS),
            "::",
            stringify!(dipSwitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dipSwitchReserved) as usize - ptr as usize },
        4112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS),
            "::",
            stringify!(dipSwitchReserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boardID) as usize - ptr as usize },
        4116usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS),
            "::",
            stringify!(boardID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver) as usize - ptr as usize },
        4120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmWare) as usize - ptr as usize },
        4128usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS),
            "::",
            stringify!(firmWare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ownerId) as usize - ptr as usize },
        4136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS),
            "::",
            stringify!(ownerId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ownerType) as usize - ptr as usize },
        4140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCAPS),
            "::",
            stringify!(ownerType)
        )
    );
}
#[doc = "! Device capabilities"]
pub type NVVIOCAPS = _NVVIOCAPS;
#[doc = "! Input channel status"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOCHANNELSTATUS {
    #[doc = "!< 4-byte SMPTE 352 video payload identifier"]
    pub smpte352: NvU32,
    #[doc = "!< Signal format"]
    pub signalFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Bits per component"]
    pub bitsPerComponent: NVVIOBITSPERCOMPONENT,
    #[doc = "!< Sampling format"]
    pub samplingFormat: NVVIOCOMPONENTSAMPLING,
    #[doc = "!< Color space"]
    pub colorSpace: NVVIOCOLORSPACE,
    #[doc = "!< Link ID"]
    pub linkID: NVVIOLINKID,
}
#[test]
fn bindgen_test_layout__NVVIOCHANNELSTATUS() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOCHANNELSTATUS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCHANNELSTATUS>(),
        24usize,
        concat!("Size of: ", stringify!(_NVVIOCHANNELSTATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCHANNELSTATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCHANNELSTATUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smpte352) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCHANNELSTATUS),
            "::",
            stringify!(smpte352)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signalFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCHANNELSTATUS),
            "::",
            stringify!(signalFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitsPerComponent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCHANNELSTATUS),
            "::",
            stringify!(bitsPerComponent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplingFormat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCHANNELSTATUS),
            "::",
            stringify!(samplingFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorSpace) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCHANNELSTATUS),
            "::",
            stringify!(colorSpace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linkID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCHANNELSTATUS),
            "::",
            stringify!(linkID)
        )
    );
}
#[doc = "! Input channel status"]
pub type NVVIOCHANNELSTATUS = _NVVIOCHANNELSTATUS;
#[doc = "! Input device status"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOINPUTSTATUS {
    #[doc = "!< Video input status per channel within a jack"]
    pub vidIn: [[NVVIOCHANNELSTATUS; 2usize]; 4usize],
    #[doc = "!< status of video capture"]
    pub captureStatus: NVVIOCAPTURESTATUS,
}
#[test]
fn bindgen_test_layout__NVVIOINPUTSTATUS() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOINPUTSTATUS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOINPUTSTATUS>(),
        196usize,
        concat!("Size of: ", stringify!(_NVVIOINPUTSTATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOINPUTSTATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOINPUTSTATUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vidIn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOINPUTSTATUS),
            "::",
            stringify!(vidIn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).captureStatus) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOINPUTSTATUS),
            "::",
            stringify!(captureStatus)
        )
    );
}
#[doc = "! Input device status"]
pub type NVVIOINPUTSTATUS = _NVVIOINPUTSTATUS;
#[doc = "! Output device status"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOOUTPUTSTATUS {
    #[doc = "!< Video 1 output status"]
    pub vid1Out: NVVIOINPUTOUTPUTSTATUS,
    #[doc = "!< Video 2 output status"]
    pub vid2Out: NVVIOINPUTOUTPUTSTATUS,
    #[doc = "!< SDI sync input status"]
    pub sdiSyncIn: NVVIOSYNCSTATUS,
    #[doc = "!< Composite sync input status"]
    pub compSyncIn: NVVIOSYNCSTATUS,
    #[doc = "!< Sync enable (TRUE if using syncSource)"]
    pub syncEnable: NvU32,
    #[doc = "!< Sync source"]
    pub syncSource: NVVIOSYNCSOURCE,
    #[doc = "!< Sync format"]
    pub syncFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Framelock enable flag"]
    pub frameLockEnable: NvU32,
    #[doc = "!< Output locked status"]
    pub outputVideoLocked: NvU32,
    #[doc = "!< Data integrity check error count"]
    pub dataIntegrityCheckErrorCount: NvU32,
    #[doc = "!< Data integrity check status enabled"]
    pub dataIntegrityCheckEnabled: NvU32,
    #[doc = "!< Data integrity check status failed"]
    pub dataIntegrityCheckFailed: NvU32,
    #[doc = "!< genlocked to framelocked to ref signal"]
    pub uSyncSourceLocked: NvU32,
    #[doc = "!< TRUE: indicates there is sufficient power"]
    pub uPowerOn: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOOUTPUTSTATUS() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOOUTPUTSTATUS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOOUTPUTSTATUS>(),
        56usize,
        concat!("Size of: ", stringify!(_NVVIOOUTPUTSTATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOOUTPUTSTATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOOUTPUTSTATUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vid1Out) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(vid1Out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vid2Out) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(vid2Out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sdiSyncIn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(sdiSyncIn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compSyncIn) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(compSyncIn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncEnable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(syncEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncSource) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(syncSource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncFormat) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(syncFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameLockEnable) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(frameLockEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputVideoLocked) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(outputVideoLocked)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dataIntegrityCheckErrorCount) as usize - ptr as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(dataIntegrityCheckErrorCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataIntegrityCheckEnabled) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(dataIntegrityCheckEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataIntegrityCheckFailed) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(dataIntegrityCheckFailed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uSyncSourceLocked) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(uSyncSourceLocked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uPowerOn) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTSTATUS),
            "::",
            stringify!(uPowerOn)
        )
    );
}
#[doc = "! Output device status"]
pub type NVVIOOUTPUTSTATUS = _NVVIOOUTPUTSTATUS;
#[doc = "! Video device status."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOSTATUS {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Input or Output status"]
    pub nvvioStatusType: NVVIOSTATUSTYPE,
    pub vioStatus: _NVVIOSTATUS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOSTATUS__bindgen_ty_1 {
    #[doc = "!<  Input device status"]
    pub inStatus: NVVIOINPUTSTATUS,
    #[doc = "!<  Output device status"]
    pub outStatus: NVVIOOUTPUTSTATUS,
}
#[test]
fn bindgen_test_layout__NVVIOSTATUS__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOSTATUS__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOSTATUS__bindgen_ty_1>(),
        196usize,
        concat!("Size of: ", stringify!(_NVVIOSTATUS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOSTATUS__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOSTATUS__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSTATUS__bindgen_ty_1),
            "::",
            stringify!(inStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSTATUS__bindgen_ty_1),
            "::",
            stringify!(outStatus)
        )
    );
}
#[test]
fn bindgen_test_layout__NVVIOSTATUS() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOSTATUS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOSTATUS>(),
        204usize,
        concat!("Size of: ", stringify!(_NVVIOSTATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOSTATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOSTATUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSTATUS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvvioStatusType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSTATUS),
            "::",
            stringify!(nvvioStatusType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vioStatus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSTATUS),
            "::",
            stringify!(vioStatus)
        )
    );
}
#[doc = "! Video device status."]
pub type NVVIOSTATUS = _NVVIOSTATUS;
#[doc = "! Output region"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOOUTPUTREGION {
    #[doc = "!< Horizontal origin in pixels"]
    pub x: NvU32,
    #[doc = "!< Vertical origin in pixels"]
    pub y: NvU32,
    #[doc = "!< Width of region in pixels"]
    pub width: NvU32,
    #[doc = "!< Height of region in pixels"]
    pub height: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOOUTPUTREGION() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOOUTPUTREGION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOOUTPUTREGION>(),
        16usize,
        concat!("Size of: ", stringify!(_NVVIOOUTPUTREGION))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOOUTPUTREGION>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOOUTPUTREGION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTREGION),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTREGION),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTREGION),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTREGION),
            "::",
            stringify!(height)
        )
    );
}
#[doc = "! Output region"]
pub type NVVIOOUTPUTREGION = _NVVIOOUTPUTREGION;
#[doc = "! Gamma ramp (8-bit index)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOGAMMARAMP8 {
    #[doc = "!< Red channel gamma ramp (8-bit index, 16-bit values)"]
    pub uRed: [NvU16; 256usize],
    #[doc = "!< Green channel gamma ramp (8-bit index, 16-bit values)"]
    pub uGreen: [NvU16; 256usize],
    #[doc = "!< Blue channel gamma ramp (8-bit index, 16-bit values)"]
    pub uBlue: [NvU16; 256usize],
}
#[test]
fn bindgen_test_layout__NVVIOGAMMARAMP8() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOGAMMARAMP8> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOGAMMARAMP8>(),
        1536usize,
        concat!("Size of: ", stringify!(_NVVIOGAMMARAMP8))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOGAMMARAMP8>(),
        2usize,
        concat!("Alignment of ", stringify!(_NVVIOGAMMARAMP8))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uRed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMARAMP8),
            "::",
            stringify!(uRed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uGreen) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMARAMP8),
            "::",
            stringify!(uGreen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uBlue) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMARAMP8),
            "::",
            stringify!(uBlue)
        )
    );
}
#[doc = "! Gamma ramp (8-bit index)"]
pub type NVVIOGAMMARAMP8 = _NVVIOGAMMARAMP8;
#[doc = "! Gamma ramp (10-bit index)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOGAMMARAMP10 {
    #[doc = "!< Red channel gamma ramp (10-bit index, 16-bit values)"]
    pub uRed: [NvU16; 1024usize],
    #[doc = "!< Green channel gamma ramp (10-bit index, 16-bit values)"]
    pub uGreen: [NvU16; 1024usize],
    #[doc = "!< Blue channel gamma ramp (10-bit index, 16-bit values)"]
    pub uBlue: [NvU16; 1024usize],
}
#[test]
fn bindgen_test_layout__NVVIOGAMMARAMP10() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOGAMMARAMP10> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOGAMMARAMP10>(),
        6144usize,
        concat!("Size of: ", stringify!(_NVVIOGAMMARAMP10))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOGAMMARAMP10>(),
        2usize,
        concat!("Alignment of ", stringify!(_NVVIOGAMMARAMP10))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uRed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMARAMP10),
            "::",
            stringify!(uRed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uGreen) as usize - ptr as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMARAMP10),
            "::",
            stringify!(uGreen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uBlue) as usize - ptr as usize },
        4096usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMARAMP10),
            "::",
            stringify!(uBlue)
        )
    );
}
#[doc = "! Gamma ramp (10-bit index)"]
pub type NVVIOGAMMARAMP10 = _NVVIOGAMMARAMP10;
#[doc = "! Sync delay"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOSYNCDELAY {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Horizontal delay in pixels"]
    pub horizontalDelay: NvU32,
    #[doc = "!< Vertical delay in lines"]
    pub verticalDelay: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOSYNCDELAY() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOSYNCDELAY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOSYNCDELAY>(),
        12usize,
        concat!("Size of: ", stringify!(_NVVIOSYNCDELAY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOSYNCDELAY>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOSYNCDELAY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSYNCDELAY),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).horizontalDelay) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSYNCDELAY),
            "::",
            stringify!(horizontalDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verticalDelay) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSYNCDELAY),
            "::",
            stringify!(verticalDelay)
        )
    );
}
#[doc = "! Sync delay"]
pub type NVVIOSYNCDELAY = _NVVIOSYNCDELAY;
#[doc = "! Video mode information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOVIDEOMODE {
    #[doc = "!< Horizontal resolution (in pixels)"]
    pub horizontalPixels: NvU32,
    #[doc = "!< Vertical resolution for frame (in lines)"]
    pub verticalLines: NvU32,
    #[doc = "!< Frame rate"]
    pub fFrameRate: f32,
    #[doc = "!< Interlace mode"]
    pub interlaceMode: NVVIOINTERLACEMODE,
    #[doc = "!< SMPTE standards format"]
    pub videoStandard: NVVIOVIDEOSTANDARD,
    #[doc = "!< HD or SD signal classification"]
    pub videoType: NVVIOVIDEOTYPE,
}
#[test]
fn bindgen_test_layout__NVVIOVIDEOMODE() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOVIDEOMODE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOVIDEOMODE>(),
        24usize,
        concat!("Size of: ", stringify!(_NVVIOVIDEOMODE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOVIDEOMODE>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOVIDEOMODE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).horizontalPixels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOVIDEOMODE),
            "::",
            stringify!(horizontalPixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verticalLines) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOVIDEOMODE),
            "::",
            stringify!(verticalLines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFrameRate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOVIDEOMODE),
            "::",
            stringify!(fFrameRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlaceMode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOVIDEOMODE),
            "::",
            stringify!(interlaceMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).videoStandard) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOVIDEOMODE),
            "::",
            stringify!(videoStandard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).videoType) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOVIDEOMODE),
            "::",
            stringify!(videoType)
        )
    );
}
#[doc = "! Video mode information"]
pub type NVVIOVIDEOMODE = _NVVIOVIDEOMODE;
#[doc = "! Signal format details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOSIGNALFORMATDETAIL {
    #[doc = "!< Signal format enumerated value"]
    pub signalFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Video mode for signal format"]
    pub videoMode: NVVIOVIDEOMODE,
}
#[test]
fn bindgen_test_layout__NVVIOSIGNALFORMATDETAIL() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOSIGNALFORMATDETAIL> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOSIGNALFORMATDETAIL>(),
        28usize,
        concat!("Size of: ", stringify!(_NVVIOSIGNALFORMATDETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOSIGNALFORMATDETAIL>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOSIGNALFORMATDETAIL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signalFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSIGNALFORMATDETAIL),
            "::",
            stringify!(signalFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).videoMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSIGNALFORMATDETAIL),
            "::",
            stringify!(videoMode)
        )
    );
}
#[doc = "! Signal format details"]
pub type NVVIOSIGNALFORMATDETAIL = _NVVIOSIGNALFORMATDETAIL;
#[doc = "! Data format details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIODATAFORMATDETAIL {
    #[doc = "!< Data format enumerated value"]
    pub dataFormat: NVVIODATAFORMAT,
    #[doc = "!< Data format capabilities (NVVIOCAPS_* mask)"]
    pub vioCaps: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIODATAFORMATDETAIL() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIODATAFORMATDETAIL> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIODATAFORMATDETAIL>(),
        8usize,
        concat!("Size of: ", stringify!(_NVVIODATAFORMATDETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIODATAFORMATDETAIL>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIODATAFORMATDETAIL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIODATAFORMATDETAIL),
            "::",
            stringify!(dataFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vioCaps) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIODATAFORMATDETAIL),
            "::",
            stringify!(vioCaps)
        )
    );
}
#[doc = "! Data format details"]
pub type NVVIODATAFORMATDETAIL = _NVVIODATAFORMATDETAIL;
#[doc = "! Colorspace conversion"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOCOLORCONVERSION {
    #[doc = "!<  Structure version"]
    pub version: NvU32,
    #[doc = "!<  Output[n] ="]
    pub colorMatrix: [[f32; 3usize]; 3usize],
    #[doc = "!<  Input[0] * colorMatrix[n][0] +"]
    pub colorOffset: [f32; 3usize],
    #[doc = "!<  Input[1] * colorMatrix[n][1] +\n!<  Input[2] * colorMatrix[n][2] +\n!<  OutputRange * colorOffset[n]\n!<  where OutputRange is the standard magnitude of\n!<  Output[n][n] and colorMatrix and colorOffset\n!<  values are within the range -1.0 to +1.0"]
    pub colorScale: [f32; 3usize],
    #[doc = "!<  compositeSafe constrains luminance range when using composite output"]
    pub compositeSafe: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOCOLORCONVERSION() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOCOLORCONVERSION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCOLORCONVERSION>(),
        68usize,
        concat!("Size of: ", stringify!(_NVVIOCOLORCONVERSION))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCOLORCONVERSION>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCOLORCONVERSION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCOLORCONVERSION),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorMatrix) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCOLORCONVERSION),
            "::",
            stringify!(colorMatrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorOffset) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCOLORCONVERSION),
            "::",
            stringify!(colorOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorScale) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCOLORCONVERSION),
            "::",
            stringify!(colorScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compositeSafe) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCOLORCONVERSION),
            "::",
            stringify!(compositeSafe)
        )
    );
}
#[doc = "! Colorspace conversion"]
pub type NVVIOCOLORCONVERSION = _NVVIOCOLORCONVERSION;
#[doc = "! Gamma correction"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOGAMMACORRECTION {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Gamma correction type (8-bit or 10-bit)"]
    pub vioGammaCorrectionType: NvU32,
    pub gammaRamp: _NVVIOGAMMACORRECTION__bindgen_ty_1,
    #[doc = "!< Red Gamma value within gamma ranges. 0.5 - 6.0"]
    pub fGammaValueR: f32,
    #[doc = "!< Green Gamma value within gamma ranges. 0.5 - 6.0"]
    pub fGammaValueG: f32,
    #[doc = "!< Blue Gamma value within gamma ranges. 0.5 - 6.0"]
    pub fGammaValueB: f32,
}
#[doc = "! Gamma correction:"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOGAMMACORRECTION__bindgen_ty_1 {
    #[doc = "!< Gamma ramp (8-bit index, 16-bit values)"]
    pub gammaRamp8: NVVIOGAMMARAMP8,
    #[doc = "!< Gamma ramp (10-bit index, 16-bit values)"]
    pub gammaRamp10: NVVIOGAMMARAMP10,
}
#[test]
fn bindgen_test_layout__NVVIOGAMMACORRECTION__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOGAMMACORRECTION__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOGAMMACORRECTION__bindgen_ty_1>(),
        6144usize,
        concat!("Size of: ", stringify!(_NVVIOGAMMACORRECTION__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOGAMMACORRECTION__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_NVVIOGAMMACORRECTION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gammaRamp8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMACORRECTION__bindgen_ty_1),
            "::",
            stringify!(gammaRamp8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gammaRamp10) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMACORRECTION__bindgen_ty_1),
            "::",
            stringify!(gammaRamp10)
        )
    );
}
#[test]
fn bindgen_test_layout__NVVIOGAMMACORRECTION() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOGAMMACORRECTION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOGAMMACORRECTION>(),
        6164usize,
        concat!("Size of: ", stringify!(_NVVIOGAMMACORRECTION))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOGAMMACORRECTION>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOGAMMACORRECTION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMACORRECTION),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vioGammaCorrectionType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMACORRECTION),
            "::",
            stringify!(vioGammaCorrectionType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gammaRamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMACORRECTION),
            "::",
            stringify!(gammaRamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fGammaValueR) as usize - ptr as usize },
        6152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMACORRECTION),
            "::",
            stringify!(fGammaValueR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fGammaValueG) as usize - ptr as usize },
        6156usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMACORRECTION),
            "::",
            stringify!(fGammaValueG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fGammaValueB) as usize - ptr as usize },
        6160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOGAMMACORRECTION),
            "::",
            stringify!(fGammaValueB)
        )
    );
}
#[doc = "! Gamma correction"]
pub type NVVIOGAMMACORRECTION = _NVVIOGAMMACORRECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOCOMPOSITERANGE {
    pub uRange: NvU32,
    pub uEnabled: NvU32,
    pub uMin: NvU32,
    pub uMax: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOCOMPOSITERANGE() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOCOMPOSITERANGE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCOMPOSITERANGE>(),
        16usize,
        concat!("Size of: ", stringify!(_NVVIOCOMPOSITERANGE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCOMPOSITERANGE>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCOMPOSITERANGE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uRange) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCOMPOSITERANGE),
            "::",
            stringify!(uRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uEnabled) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCOMPOSITERANGE),
            "::",
            stringify!(uEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uMin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCOMPOSITERANGE),
            "::",
            stringify!(uMin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uMax) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCOMPOSITERANGE),
            "::",
            stringify!(uMax)
        )
    );
}
pub type NVVIOCOMPOSITERANGE = _NVVIOCOMPOSITERANGE;
#[doc = "! Output device configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOOUTPUTCONFIG_V1 {
    #[doc = "!< Signal format for video output"]
    pub signalFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Data format for video output"]
    pub dataFormat: NVVIODATAFORMAT,
    #[doc = "!< Region for video output (Desktop mode)"]
    pub outputRegion: NVVIOOUTPUTREGION,
    #[doc = "!< Usable resolution for video output (safe area)"]
    pub outputArea: NVVIOOUTPUTAREA,
    #[doc = "!< Color conversion."]
    pub colorConversion: NVVIOCOLORCONVERSION,
    pub gammaCorrection: NVVIOGAMMACORRECTION,
    #[doc = "!< Sync enable (TRUE to use syncSource)"]
    pub syncEnable: NvU32,
    #[doc = "!< Sync source"]
    pub syncSource: NVVIOSYNCSOURCE,
    #[doc = "!< Sync delay"]
    pub syncDelay: NVVIOSYNCDELAY,
    #[doc = "!< Composite sync type"]
    pub compositeSyncType: NVVIOCOMPSYNCTYPE,
    #[doc = "!< Flag indicating whether framelock was on/off"]
    pub frameLockEnable: NvU32,
    #[doc = "!< Indicates whether contained format is PSF Signal format"]
    pub psfSignalFormat: NvU32,
    #[doc = "!< Enables/Disables 4:2:2 filter"]
    pub enable422Filter: NvU32,
    #[doc = "!< Composite termination"]
    pub compositeTerminate: NvU32,
    #[doc = "!< Enable data integrity check: true - enable, false - disable"]
    pub enableDataIntegrityCheck: NvU32,
    #[doc = "!< Use provided CSC color matrix to overwrite"]
    pub cscOverride: NvU32,
    #[doc = "!< Number of buffers used for the internal flipqueue"]
    pub flipQueueLength: NvU32,
    #[doc = "!< Enable SDI ANC time code generation"]
    pub enableANCTimeCodeGeneration: NvU32,
    #[doc = "!< Enable composite"]
    pub enableComposite: NvU32,
    #[doc = "!< Enable Alpha key composite"]
    pub enableAlphaKeyComposite: NvU32,
    #[doc = "!< Composite ranges"]
    pub compRange: NVVIOCOMPOSITERANGE,
    #[doc = "!< Inicates last stored SDI output state TRUE-ON / FALSE-OFF"]
    pub reservedData: [NvU8; 256usize],
    #[doc = "!< Flag indicating Full Color Range"]
    pub enableFullColorRange: NvU32,
    #[doc = "!< Indicates data is in RGB format"]
    pub enableRGBData: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOOUTPUTCONFIG_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOOUTPUTCONFIG_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOOUTPUTCONFIG_V1>(),
        6604usize,
        concat!("Size of: ", stringify!(_NVVIOOUTPUTCONFIG_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOOUTPUTCONFIG_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOOUTPUTCONFIG_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signalFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(signalFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(dataFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputRegion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(outputRegion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputArea) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(outputArea)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorConversion) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(colorConversion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gammaCorrection) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(gammaCorrection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncEnable) as usize - ptr as usize },
        6260usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(syncEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncSource) as usize - ptr as usize },
        6264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(syncSource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncDelay) as usize - ptr as usize },
        6268usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(syncDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compositeSyncType) as usize - ptr as usize },
        6280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(compositeSyncType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameLockEnable) as usize - ptr as usize },
        6284usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(frameLockEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psfSignalFormat) as usize - ptr as usize },
        6288usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(psfSignalFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable422Filter) as usize - ptr as usize },
        6292usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(enable422Filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compositeTerminate) as usize - ptr as usize },
        6296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(compositeTerminate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableDataIntegrityCheck) as usize - ptr as usize },
        6300usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(enableDataIntegrityCheck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cscOverride) as usize - ptr as usize },
        6304usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(cscOverride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flipQueueLength) as usize - ptr as usize },
        6308usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(flipQueueLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableANCTimeCodeGeneration) as usize - ptr as usize },
        6312usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(enableANCTimeCodeGeneration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableComposite) as usize - ptr as usize },
        6316usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(enableComposite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableAlphaKeyComposite) as usize - ptr as usize },
        6320usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(enableAlphaKeyComposite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compRange) as usize - ptr as usize },
        6324usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(compRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedData) as usize - ptr as usize },
        6340usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(reservedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableFullColorRange) as usize - ptr as usize },
        6596usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(enableFullColorRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableRGBData) as usize - ptr as usize },
        6600usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V1),
            "::",
            stringify!(enableRGBData)
        )
    );
}
#[doc = "! Output device configuration"]
pub type NVVIOOUTPUTCONFIG_V1 = _NVVIOOUTPUTCONFIG_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOOUTPUTCONFIG_V2 {
    #[doc = "!< Signal format for video output"]
    pub signalFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Data format for video output"]
    pub dataFormat: NVVIODATAFORMAT,
    #[doc = "!< Region for video output (Desktop mode)"]
    pub outputRegion: NVVIOOUTPUTREGION,
    #[doc = "!< Usable resolution for video output (safe area)"]
    pub outputArea: NVVIOOUTPUTAREA,
    #[doc = "!< Color conversion."]
    pub colorConversion: NVVIOCOLORCONVERSION,
    pub gammaCorrection: NVVIOGAMMACORRECTION,
    #[doc = "!< Sync enable (TRUE to use syncSource)"]
    pub syncEnable: NvU32,
    #[doc = "!< Sync source"]
    pub syncSource: NVVIOSYNCSOURCE,
    #[doc = "!< Sync delay"]
    pub syncDelay: NVVIOSYNCDELAY,
    #[doc = "!< Composite sync type"]
    pub compositeSyncType: NVVIOCOMPSYNCTYPE,
    #[doc = "!< Flag indicating whether framelock was on/off"]
    pub frameLockEnable: NvU32,
    #[doc = "!< Indicates whether contained format is PSF Signal format"]
    pub psfSignalFormat: NvU32,
    #[doc = "!< Enables/Disables 4:2:2 filter"]
    pub enable422Filter: NvU32,
    #[doc = "!< Composite termination"]
    pub compositeTerminate: NvU32,
    #[doc = "!< Enable data integrity check: true - enable, false - disable"]
    pub enableDataIntegrityCheck: NvU32,
    #[doc = "!< Use provided CSC color matrix to overwrite"]
    pub cscOverride: NvU32,
    #[doc = "!< Number of buffers used for the internal flip queue"]
    pub flipQueueLength: NvU32,
    #[doc = "!< Enable SDI ANC time code generation"]
    pub enableANCTimeCodeGeneration: NvU32,
    #[doc = "!< Enable composite"]
    pub enableComposite: NvU32,
    #[doc = "!< Enable Alpha key composite"]
    pub enableAlphaKeyComposite: NvU32,
    #[doc = "!< Composite ranges"]
    pub compRange: NVVIOCOMPOSITERANGE,
    #[doc = "!< Indicates last stored SDI output state TRUE-ON / FALSE-OFF"]
    pub reservedData: [NvU8; 256usize],
    #[doc = "!< Flag indicating Full Color Range"]
    pub enableFullColorRange: NvU32,
    #[doc = "!< Indicates data is in RGB format"]
    pub enableRGBData: NvU32,
    #[doc = "!< Enable HW ANC parity bit computation (auto/on/off)"]
    pub ancParityComputation: NVVIOANCPARITYCOMPUTATION,
}
#[test]
fn bindgen_test_layout__NVVIOOUTPUTCONFIG_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOOUTPUTCONFIG_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOOUTPUTCONFIG_V2>(),
        6608usize,
        concat!("Size of: ", stringify!(_NVVIOOUTPUTCONFIG_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOOUTPUTCONFIG_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOOUTPUTCONFIG_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signalFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(signalFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(dataFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputRegion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(outputRegion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputArea) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(outputArea)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorConversion) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(colorConversion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gammaCorrection) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(gammaCorrection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncEnable) as usize - ptr as usize },
        6260usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(syncEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncSource) as usize - ptr as usize },
        6264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(syncSource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncDelay) as usize - ptr as usize },
        6268usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(syncDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compositeSyncType) as usize - ptr as usize },
        6280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(compositeSyncType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameLockEnable) as usize - ptr as usize },
        6284usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(frameLockEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psfSignalFormat) as usize - ptr as usize },
        6288usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(psfSignalFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable422Filter) as usize - ptr as usize },
        6292usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(enable422Filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compositeTerminate) as usize - ptr as usize },
        6296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(compositeTerminate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableDataIntegrityCheck) as usize - ptr as usize },
        6300usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(enableDataIntegrityCheck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cscOverride) as usize - ptr as usize },
        6304usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(cscOverride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flipQueueLength) as usize - ptr as usize },
        6308usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(flipQueueLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableANCTimeCodeGeneration) as usize - ptr as usize },
        6312usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(enableANCTimeCodeGeneration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableComposite) as usize - ptr as usize },
        6316usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(enableComposite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableAlphaKeyComposite) as usize - ptr as usize },
        6320usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(enableAlphaKeyComposite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compRange) as usize - ptr as usize },
        6324usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(compRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedData) as usize - ptr as usize },
        6340usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(reservedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableFullColorRange) as usize - ptr as usize },
        6596usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(enableFullColorRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableRGBData) as usize - ptr as usize },
        6600usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(enableRGBData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ancParityComputation) as usize - ptr as usize },
        6604usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V2),
            "::",
            stringify!(ancParityComputation)
        )
    );
}
pub type NVVIOOUTPUTCONFIG_V2 = _NVVIOOUTPUTCONFIG_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOOUTPUTCONFIG_V3 {
    #[doc = "!< Signal format for video output"]
    pub signalFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Data format for video output"]
    pub dataFormat: NVVIODATAFORMAT,
    #[doc = "!< Region for video output (Desktop mode)"]
    pub outputRegion: NVVIOOUTPUTREGION,
    #[doc = "!< Usable resolution for video output (safe area)"]
    pub outputArea: NVVIOOUTPUTAREA,
    #[doc = "!< Color conversion."]
    pub colorConversion: NVVIOCOLORCONVERSION,
    pub gammaCorrection: NVVIOGAMMACORRECTION,
    #[doc = "!< Sync enable (TRUE to use syncSource)"]
    pub syncEnable: NvU32,
    #[doc = "!< Sync source"]
    pub syncSource: NVVIOSYNCSOURCE,
    #[doc = "!< Sync delay"]
    pub syncDelay: NVVIOSYNCDELAY,
    #[doc = "!< Composite sync type"]
    pub compositeSyncType: NVVIOCOMPSYNCTYPE,
    #[doc = "!< Flag indicating whether framelock was on/off"]
    pub frameLockEnable: NvU32,
    #[doc = "!< Indicates whether contained format is PSF Signal format"]
    pub psfSignalFormat: NvU32,
    #[doc = "!< Enables/Disables 4:2:2 filter"]
    pub enable422Filter: NvU32,
    #[doc = "!< Composite termination"]
    pub compositeTerminate: NvU32,
    #[doc = "!< Enable data integrity check: true - enable, false - disable"]
    pub enableDataIntegrityCheck: NvU32,
    #[doc = "!< Use provided CSC color matrix to overwrite"]
    pub cscOverride: NvU32,
    #[doc = "!< Number of buffers used for the internal flip queue"]
    pub flipQueueLength: NvU32,
    #[doc = "!< Enable SDI ANC time code generation"]
    pub enableANCTimeCodeGeneration: NvU32,
    #[doc = "!< Enable composite"]
    pub enableComposite: NvU32,
    #[doc = "!< Enable Alpha key composite"]
    pub enableAlphaKeyComposite: NvU32,
    #[doc = "!< Composite ranges"]
    pub compRange: NVVIOCOMPOSITERANGE,
    #[doc = "!< Indicates last stored SDI output state TRUE-ON / FALSE-OFF"]
    pub reservedData: [NvU8; 256usize],
    #[doc = "!< Flag indicating Full Color Range"]
    pub enableFullColorRange: NvU32,
    #[doc = "!< Indicates data is in RGB format"]
    pub enableRGBData: NvU32,
    #[doc = "!< Enable HW ANC parity bit computation (auto/on/off)"]
    pub ancParityComputation: NVVIOANCPARITYCOMPUTATION,
    #[doc = "!< Enable HANC audio blanking on repeat frames"]
    pub enableAudioBlanking: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOOUTPUTCONFIG_V3() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOOUTPUTCONFIG_V3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOOUTPUTCONFIG_V3>(),
        6612usize,
        concat!("Size of: ", stringify!(_NVVIOOUTPUTCONFIG_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOOUTPUTCONFIG_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOOUTPUTCONFIG_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signalFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(signalFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(dataFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputRegion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(outputRegion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputArea) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(outputArea)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorConversion) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(colorConversion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gammaCorrection) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(gammaCorrection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncEnable) as usize - ptr as usize },
        6260usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(syncEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncSource) as usize - ptr as usize },
        6264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(syncSource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncDelay) as usize - ptr as usize },
        6268usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(syncDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compositeSyncType) as usize - ptr as usize },
        6280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(compositeSyncType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameLockEnable) as usize - ptr as usize },
        6284usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(frameLockEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psfSignalFormat) as usize - ptr as usize },
        6288usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(psfSignalFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable422Filter) as usize - ptr as usize },
        6292usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(enable422Filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compositeTerminate) as usize - ptr as usize },
        6296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(compositeTerminate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableDataIntegrityCheck) as usize - ptr as usize },
        6300usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(enableDataIntegrityCheck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cscOverride) as usize - ptr as usize },
        6304usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(cscOverride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flipQueueLength) as usize - ptr as usize },
        6308usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(flipQueueLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableANCTimeCodeGeneration) as usize - ptr as usize },
        6312usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(enableANCTimeCodeGeneration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableComposite) as usize - ptr as usize },
        6316usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(enableComposite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableAlphaKeyComposite) as usize - ptr as usize },
        6320usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(enableAlphaKeyComposite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compRange) as usize - ptr as usize },
        6324usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(compRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedData) as usize - ptr as usize },
        6340usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(reservedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableFullColorRange) as usize - ptr as usize },
        6596usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(enableFullColorRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableRGBData) as usize - ptr as usize },
        6600usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(enableRGBData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ancParityComputation) as usize - ptr as usize },
        6604usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(ancParityComputation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableAudioBlanking) as usize - ptr as usize },
        6608usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOOUTPUTCONFIG_V3),
            "::",
            stringify!(enableAudioBlanking)
        )
    );
}
pub type NVVIOOUTPUTCONFIG_V3 = _NVVIOOUTPUTCONFIG_V3;
#[doc = "! Stream configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOSTREAM {
    #[doc = "!< Bits per component"]
    pub bitsPerComponent: NvU32,
    #[doc = "!< Sampling"]
    pub sampling: NVVIOCOMPONENTSAMPLING,
    #[doc = "!< Enable/disable 4:2:2->4:4:4 expansion"]
    pub expansionEnable: NvU32,
    #[doc = "!< Number of active links"]
    pub numLinks: NvU32,
    pub links: [_NVVIOSTREAM__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOSTREAM__bindgen_ty_1 {
    #[doc = "!< This stream's link[i] will use the specified (0-based) channel within the"]
    pub jack: NvU32,
    #[doc = "!< specified (0-based) jack"]
    pub channel: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOSTREAM__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOSTREAM__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOSTREAM__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NVVIOSTREAM__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOSTREAM__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOSTREAM__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSTREAM__bindgen_ty_1),
            "::",
            stringify!(jack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSTREAM__bindgen_ty_1),
            "::",
            stringify!(channel)
        )
    );
}
#[test]
fn bindgen_test_layout__NVVIOSTREAM() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOSTREAM> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOSTREAM>(),
        32usize,
        concat!("Size of: ", stringify!(_NVVIOSTREAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOSTREAM>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOSTREAM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitsPerComponent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSTREAM),
            "::",
            stringify!(bitsPerComponent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampling) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSTREAM),
            "::",
            stringify!(sampling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expansionEnable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSTREAM),
            "::",
            stringify!(expansionEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numLinks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSTREAM),
            "::",
            stringify!(numLinks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).links) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOSTREAM),
            "::",
            stringify!(links)
        )
    );
}
#[doc = "! Stream configuration"]
pub type NVVIOSTREAM = _NVVIOSTREAM;
#[doc = "! Input device configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOINPUTCONFIG {
    #[doc = "!< numRawCaptureImages is the number of frames to keep in the capture queue.\n!< must be between NVAPI_GVI_MIN_RAW_CAPTURE_IMAGES and NVAPI_GVI_MAX_RAW_CAPTURE_IMAGES,"]
    pub numRawCaptureImages: NvU32,
    #[doc = "!< Signal format.\n!< Please note that both numRawCaptureImages and signalFormat should be set together."]
    pub signalFormat: NVVIOSIGNALFORMAT,
    #[doc = "!< Number of active streams."]
    pub numStreams: NvU32,
    #[doc = "!< Stream configurations"]
    pub streams: [NVVIOSTREAM; 4usize],
    #[doc = "!< This attribute controls the GVI test mode.\n!< Possible values 0/1. When testmode enabled, the\n!< GVI device will generate fake data as quickly as possible."]
    pub bTestMode: NvU32,
}
#[test]
fn bindgen_test_layout__NVVIOINPUTCONFIG() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOINPUTCONFIG> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOINPUTCONFIG>(),
        144usize,
        concat!("Size of: ", stringify!(_NVVIOINPUTCONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOINPUTCONFIG>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOINPUTCONFIG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRawCaptureImages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOINPUTCONFIG),
            "::",
            stringify!(numRawCaptureImages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signalFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOINPUTCONFIG),
            "::",
            stringify!(signalFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numStreams) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOINPUTCONFIG),
            "::",
            stringify!(numStreams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streams) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOINPUTCONFIG),
            "::",
            stringify!(streams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bTestMode) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOINPUTCONFIG),
            "::",
            stringify!(bTestMode)
        )
    );
}
#[doc = "! Input device configuration"]
pub type NVVIOINPUTCONFIG = _NVVIOINPUTCONFIG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCONFIG_V1 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Caller sets to NVVIOCONFIG_* mask for fields to use"]
    pub fields: NvU32,
    #[doc = "!< Input or Output configuration"]
    pub nvvioConfigType: NVVIOCONFIGTYPE,
    pub vioConfig: _NVVIOCONFIG_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOCONFIG_V1__bindgen_ty_1 {
    #[doc = "!<  Input device configuration"]
    pub inConfig: NVVIOINPUTCONFIG,
    #[doc = "!<  Output device configuration"]
    pub outConfig: NVVIOOUTPUTCONFIG_V1,
}
#[test]
fn bindgen_test_layout__NVVIOCONFIG_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOCONFIG_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCONFIG_V1__bindgen_ty_1>(),
        6604usize,
        concat!("Size of: ", stringify!(_NVVIOCONFIG_V1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCONFIG_V1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCONFIG_V1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V1__bindgen_ty_1),
            "::",
            stringify!(inConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V1__bindgen_ty_1),
            "::",
            stringify!(outConfig)
        )
    );
}
#[test]
fn bindgen_test_layout__NVVIOCONFIG_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOCONFIG_V1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCONFIG_V1>(),
        6616usize,
        concat!("Size of: ", stringify!(_NVVIOCONFIG_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCONFIG_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCONFIG_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V1),
            "::",
            stringify!(fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvvioConfigType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V1),
            "::",
            stringify!(nvvioConfigType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vioConfig) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V1),
            "::",
            stringify!(vioConfig)
        )
    );
}
pub type NVVIOCONFIG_V1 = _NVVIOCONFIG_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCONFIG_V2 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Caller sets to NVVIOCONFIG_* mask for fields to use"]
    pub fields: NvU32,
    #[doc = "!< Input or Output configuration"]
    pub nvvioConfigType: NVVIOCONFIGTYPE,
    pub vioConfig: _NVVIOCONFIG_V2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOCONFIG_V2__bindgen_ty_1 {
    #[doc = "!< Input device configuration"]
    pub inConfig: NVVIOINPUTCONFIG,
    #[doc = "!< Output device configuration"]
    pub outConfig: NVVIOOUTPUTCONFIG_V2,
}
#[test]
fn bindgen_test_layout__NVVIOCONFIG_V2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOCONFIG_V2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCONFIG_V2__bindgen_ty_1>(),
        6608usize,
        concat!("Size of: ", stringify!(_NVVIOCONFIG_V2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCONFIG_V2__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCONFIG_V2__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V2__bindgen_ty_1),
            "::",
            stringify!(inConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V2__bindgen_ty_1),
            "::",
            stringify!(outConfig)
        )
    );
}
#[test]
fn bindgen_test_layout__NVVIOCONFIG_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOCONFIG_V2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCONFIG_V2>(),
        6620usize,
        concat!("Size of: ", stringify!(_NVVIOCONFIG_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCONFIG_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCONFIG_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V2),
            "::",
            stringify!(fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvvioConfigType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V2),
            "::",
            stringify!(nvvioConfigType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vioConfig) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V2),
            "::",
            stringify!(vioConfig)
        )
    );
}
pub type NVVIOCONFIG_V2 = _NVVIOCONFIG_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCONFIG_V3 {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< Caller sets to NVVIOCONFIG_* mask for fields to use"]
    pub fields: NvU32,
    #[doc = "!< Input or Output configuration"]
    pub nvvioConfigType: NVVIOCONFIGTYPE,
    pub vioConfig: _NVVIOCONFIG_V3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOCONFIG_V3__bindgen_ty_1 {
    #[doc = "!< Input device configuration"]
    pub inConfig: NVVIOINPUTCONFIG,
    #[doc = "!< Output device configuration"]
    pub outConfig: NVVIOOUTPUTCONFIG_V3,
}
#[test]
fn bindgen_test_layout__NVVIOCONFIG_V3__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOCONFIG_V3__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCONFIG_V3__bindgen_ty_1>(),
        6612usize,
        concat!("Size of: ", stringify!(_NVVIOCONFIG_V3__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCONFIG_V3__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCONFIG_V3__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V3__bindgen_ty_1),
            "::",
            stringify!(inConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V3__bindgen_ty_1),
            "::",
            stringify!(outConfig)
        )
    );
}
#[test]
fn bindgen_test_layout__NVVIOCONFIG_V3() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOCONFIG_V3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOCONFIG_V3>(),
        6624usize,
        concat!("Size of: ", stringify!(_NVVIOCONFIG_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOCONFIG_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOCONFIG_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V3),
            "::",
            stringify!(fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvvioConfigType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V3),
            "::",
            stringify!(nvvioConfigType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vioConfig) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOCONFIG_V3),
            "::",
            stringify!(vioConfig)
        )
    );
}
pub type NVVIOCONFIG_V3 = _NVVIOCONFIG_V3;
pub type NVVIOOUTPUTCONFIG = NVVIOOUTPUTCONFIG_V3;
pub type NVVIOCONFIG = NVVIOCONFIG_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NVVIOTOPOLOGYTARGET {
    #[doc = "!< Handle to Physical GPU (This could be NULL for GVI device if its not binded)"]
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    #[doc = "!<handle to SDI Input/Output device"]
    pub hVioHandle: NvVioHandle,
    #[doc = "!<device Id of SDI Input/Output device"]
    pub vioId: NvU32,
    #[doc = "!<deviceMask of the SDI display connected to GVO device.\n!<outputId will be 0 for GVI device."]
    pub outputId: NvU32,
}
#[test]
fn bindgen_test_layout_NVVIOTOPOLOGYTARGET() {
    const UNINIT: ::std::mem::MaybeUninit<NVVIOTOPOLOGYTARGET> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NVVIOTOPOLOGYTARGET>(),
        24usize,
        concat!("Size of: ", stringify!(NVVIOTOPOLOGYTARGET))
    );
    assert_eq!(
        ::std::mem::align_of::<NVVIOTOPOLOGYTARGET>(),
        8usize,
        concat!("Alignment of ", stringify!(NVVIOTOPOLOGYTARGET))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hPhysicalGpu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVVIOTOPOLOGYTARGET),
            "::",
            stringify!(hPhysicalGpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hVioHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NVVIOTOPOLOGYTARGET),
            "::",
            stringify!(hVioHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vioId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NVVIOTOPOLOGYTARGET),
            "::",
            stringify!(vioId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputId) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NVVIOTOPOLOGYTARGET),
            "::",
            stringify!(outputId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_VIO_TOPOLOGY {
    pub version: NvU32,
    #[doc = "!<How many video I/O targets are valid"]
    pub vioTotalDeviceCount: NvU32,
    #[doc = "!<Array of video I/O targets"]
    pub vioTarget: [NVVIOTOPOLOGYTARGET; 8usize],
}
#[test]
fn bindgen_test_layout__NV_VIO_TOPOLOGY() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_VIO_TOPOLOGY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_VIO_TOPOLOGY>(),
        200usize,
        concat!("Size of: ", stringify!(_NV_VIO_TOPOLOGY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_VIO_TOPOLOGY>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_VIO_TOPOLOGY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_VIO_TOPOLOGY),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vioTotalDeviceCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_VIO_TOPOLOGY),
            "::",
            stringify!(vioTotalDeviceCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vioTarget) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_VIO_TOPOLOGY),
            "::",
            stringify!(vioTarget)
        )
    );
}
pub type NV_VIO_TOPOLOGY = _NV_VIO_TOPOLOGY;
pub type NVVIOTOPOLOGY = _NV_VIO_TOPOLOGY;
extern "C" {
    #[doc = "! \\addtogroup vidio\n! @{\n\n!\n!   Function:    NvAPI_VIO_GetCapabilities\n!\n!   Description: This API determine the graphics adapter video I/O capabilities.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle   The caller provides the SDI device handle as input.\n! \\param [out] pAdapterCaps  Pointer to receive capabilities\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_GetCapabilities(
        hVioHandle: NvVioHandle,
        pAdapterCaps: *mut NVVIOCAPS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_Open\n!\n!   Description: This API opens the graphics adapter for video I/O operations\n!                using the OpenGL application interface.  Read operations\n!                are permitted in this mode by multiple clients, but Write\n!                operations are application exclusive.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle      The caller provides the SDI output device handle as input.\n! \\param [in]  vioClass         Class interface (NVVIOCLASS_* value)\n! \\param [in]  ownerType        Specify NVVIOOWNERTYPE_APPLICATION or NVVIOOWNERTYPE_DESKTOP.\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_Open(
        hVioHandle: NvVioHandle,
        vioClass: NvU32,
        ownerType: NVVIOOWNERTYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_Close\n!\n!   Description: This API closes the graphics adapter for graphics-to-video operations\n!                using the OpenGL application interface.  Closing an\n!                OpenGL handle releases the device.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle   The caller provides the SDI output device handle as input.\n! \\param [in]  bRelease      boolean value to either keep or release ownership\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_Close(hVioHandle: NvVioHandle, bRelease: NvU32) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_Status\n!\n!   Description: This API gets the Video I/O LED status.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle   The caller provides the SDI device handle as input.\n! \\param [out] pStatus       Return pointer to NVVIOSTATUS\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_Status(hVioHandle: NvVioHandle, pStatus: *mut NVVIOSTATUS) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_SyncFormatDetect\n!\n!   Description: This API detects the Video I/O incoming sync video format.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle  The caller provides the SDI device handle as input.\n! \\param [out] pWait        Pointer to receive how many milliseconds will lapse\n!                           before VIOStatus returns the detected syncFormat.\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_SyncFormatDetect(hVioHandle: NvVioHandle, pWait: *mut NvU32) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_GetConfig\n!\n!   Description: This API gets the graphics-to-video configuration.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle   The caller provides the SDI device handle as input.\n! \\param [out] pConfig       Pointer to the graphics-to-video configuration\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_GetConfig(hVioHandle: NvVioHandle, pConfig: *mut NVVIOCONFIG) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_SetConfig\n!\n!   Description: This API sets the graphics-to-video configuration.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle      The caller provides the SDI device handle as input.\n! \\param [in]  pConfig          Pointer to Graphics-to-Video configuration\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_SetConfig(
        hVioHandle: NvVioHandle,
        pConfig: *const NVVIOCONFIG,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_SetCSC\n!\n!   Description: This API sets the colorspace conversion parameters.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle      The caller provides the SDI device handle as input.\n! \\param [in]  pCSC             Pointer to CSC parameters\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n----"]
    pub fn NvAPI_VIO_SetCSC(
        hVioHandle: NvVioHandle,
        pCSC: *mut NVVIOCOLORCONVERSION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_GetCSC\n!\n!   Description: This API gets the colorspace conversion parameters.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle      The caller provides the SDI device handle as input.\n! \\param [out] pCSC             Pointer to CSC parameters\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_GetCSC(
        hVioHandle: NvVioHandle,
        pCSC: *mut NVVIOCOLORCONVERSION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_SetGamma\n!\n!   Description: This API sets the gamma conversion parameters.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle       The caller provides the SDI device handle as input.\n! \\param [in]  pGamma            Pointer to gamma parameters\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_SetGamma(
        hVioHandle: NvVioHandle,
        pGamma: *mut NVVIOGAMMACORRECTION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_GetGamma\n!\n!   Description: This API gets the gamma conversion parameters.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle      The caller provides the SDI device handle as input.\n! \\param [out] pGamma           Pointer to gamma parameters\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_GetGamma(
        hVioHandle: NvVioHandle,
        pGamma: *mut NVVIOGAMMACORRECTION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_SetSyncDelay\n!\n!   Description: This API sets the sync delay parameters.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle   The caller provides the SDI device handle as input.\n! \\param [in]  pSyncDelay    Pointer to sync delay parameters\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_SetSyncDelay(
        hVioHandle: NvVioHandle,
        pSyncDelay: *const NVVIOSYNCDELAY,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_GetSyncDelay\n!\n!   Description: This API gets the sync delay parameters.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle      The caller provides the SDI device handle as input.\n! \\param [out] pSyncDelay       Pointer to sync delay parameters\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_GetSyncDelay(
        hVioHandle: NvVioHandle,
        pSyncDelay: *mut NVVIOSYNCDELAY,
    ) -> NvAPI_Status;
}
pub const _NVVIOPCILINKRATE_NVVIOPCILINKRATE_UNKNOWN: _NVVIOPCILINKRATE = 0;
pub const _NVVIOPCILINKRATE_NVVIOPCILINKRATE_GEN1: _NVVIOPCILINKRATE = 1;
pub const _NVVIOPCILINKRATE_NVVIOPCILINKRATE_GEN2: _NVVIOPCILINKRATE = 2;
pub const _NVVIOPCILINKRATE_NVVIOPCILINKRATE_GEN3: _NVVIOPCILINKRATE = 3;
pub type _NVVIOPCILINKRATE = ::std::os::raw::c_int;
pub use self::_NVVIOPCILINKRATE as NVVIOPCILINKRATE;
pub const _NVVIOPCILINKWIDTH_NVVIOPCILINKWIDTH_UNKNOWN: _NVVIOPCILINKWIDTH = 0;
pub const _NVVIOPCILINKWIDTH_NVVIOPCILINKWIDTH_x1: _NVVIOPCILINKWIDTH = 1;
pub const _NVVIOPCILINKWIDTH_NVVIOPCILINKWIDTH_x2: _NVVIOPCILINKWIDTH = 2;
pub const _NVVIOPCILINKWIDTH_NVVIOPCILINKWIDTH_x4: _NVVIOPCILINKWIDTH = 4;
pub const _NVVIOPCILINKWIDTH_NVVIOPCILINKWIDTH_x8: _NVVIOPCILINKWIDTH = 8;
pub const _NVVIOPCILINKWIDTH_NVVIOPCILINKWIDTH_x16: _NVVIOPCILINKWIDTH = 16;
pub type _NVVIOPCILINKWIDTH = ::std::os::raw::c_int;
pub use self::_NVVIOPCILINKWIDTH as NVVIOPCILINKWIDTH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVVIOPCIINFO {
    #[doc = "!< Structure version"]
    pub version: NvU32,
    #[doc = "!< specifies the internal PCI device identifier for the GVI."]
    pub pciDeviceId: NvU32,
    #[doc = "!< specifies the internal PCI subsystem identifier for the GVI."]
    pub pciSubSystemId: NvU32,
    #[doc = "!< specifies the internal PCI device-specific revision identifier for the GVI."]
    pub pciRevisionId: NvU32,
    #[doc = "!< specifies the PCI domain of the GVI device."]
    pub pciDomain: NvU32,
    #[doc = "!< specifies the PCI bus number of the GVI device."]
    pub pciBus: NvU32,
    #[doc = "!< specifies the PCI slot number of the GVI device."]
    pub pciSlot: NvU32,
    #[doc = "!< specifies the the negotiated PCIE link width."]
    pub pciLinkWidth: NVVIOPCILINKWIDTH,
    #[doc = "!< specifies the the negotiated PCIE link rate."]
    pub pciLinkRate: NVVIOPCILINKRATE,
}
#[test]
fn bindgen_test_layout__NVVIOPCIINFO() {
    const UNINIT: ::std::mem::MaybeUninit<_NVVIOPCIINFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVVIOPCIINFO>(),
        36usize,
        concat!("Size of: ", stringify!(_NVVIOPCIINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVVIOPCIINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVVIOPCIINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOPCIINFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciDeviceId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOPCIINFO),
            "::",
            stringify!(pciDeviceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciSubSystemId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOPCIINFO),
            "::",
            stringify!(pciSubSystemId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciRevisionId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOPCIINFO),
            "::",
            stringify!(pciRevisionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciDomain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOPCIINFO),
            "::",
            stringify!(pciDomain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciBus) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOPCIINFO),
            "::",
            stringify!(pciBus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciSlot) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOPCIINFO),
            "::",
            stringify!(pciSlot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciLinkWidth) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOPCIINFO),
            "::",
            stringify!(pciLinkWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciLinkRate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVVIOPCIINFO),
            "::",
            stringify!(pciLinkRate)
        )
    );
}
pub type NVVIOPCIINFO_V1 = _NVVIOPCIINFO;
pub type NVVIOPCIINFO = NVVIOPCIINFO_V1;
extern "C" {
    pub fn NvAPI_VIO_GetPCIInfo(
        hVioHandle: NvVioHandle,
        pVioPCIInfo: *mut NVVIOPCIINFO,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_IsRunning\n!\n!   Description: This API determines if Video I/O is running.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle[IN]          The caller provides the SDI device handle as input.\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_IsRunning(hVioHandle: NvVioHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_Start\n!\n!   Description: This API starts Video I/O.\n!              This API should be called for NVVIOOWNERTYPE_DESKTOP only and will not work for OGL applications.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle[IN]     The caller provides the SDI device handle as input.\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_Start(hVioHandle: NvVioHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_Stop\n!\n!   Description: This API stops Video I/O.\n!              This API should be called for NVVIOOWNERTYPE_DESKTOP only and will not work for OGL applications.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle[IN]     The caller provides the SDI device handle as input.\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_Stop(hVioHandle: NvVioHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_IsFrameLockModeCompatible\n!\n!   Description: This API checks whether modes are compatible in frame lock mode.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]   NvVioHandle          The caller provides the SDI device handle as input.\n! \\param [in]   srcEnumIndex         Source Enumeration index\n! \\param [in]   destEnumIndex        Destination Enumeration index\n! \\param [out]  pbCompatible         Pointer to receive compatibility\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_IsFrameLockModeCompatible(
        hVioHandle: NvVioHandle,
        srcEnumIndex: NvU32,
        destEnumIndex: NvU32,
        pbCompatible: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_EnumDevices\n!\n!   Description: This API enumerate all VIO devices connected to the system.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [out]  NvVioHandle                  User passes the pointer of NvVioHandle[] array to get handles to\n!                                            all the connected video I/O devices.\n! \\param [out]  vioDeviceCount               User gets total number of VIO devices connected to the system.\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_EnumDevices(
        hVioHandle: *mut NvVioHandle,
        vioDeviceCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_QueryTopology\n!\n!   Description: This API queries the valid SDI topologies.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [out] pNvVIOTopology     User passes the pointer to NVVIOTOPOLOGY to fetch all valid SDI topologies.\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_QueryTopology(pNvVIOTopology: *mut NV_VIO_TOPOLOGY) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_EnumSignalFormats\n!\n!   Description: This API enumerates signal formats supported by Video I/O.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]   NvVioHandle          The caller provides the SDI device handle as input.\n! \\param [in]   enumIndex            Enumeration index\n! \\param [out]  pSignalFormatDetail  Pointer to receive detail or NULL\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_EnumSignalFormats(
        hVioHandle: NvVioHandle,
        enumIndex: NvU32,
        pSignalFormatDetail: *mut NVVIOSIGNALFORMATDETAIL,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "\n!   Function:    NvAPI_VIO_EnumDataFormats\n!\n!   Description: This API enumerates data formats supported by Video I/O.\n!\n! \\deprecated  Do not use this function - it is deprecated in release 440.\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 190\n!\n! \\param [in]  NvVioHandle         The caller provides the SDI device handle as input.\n! \\param [in]  enumIndex           Enumeration index\n! \\param [out] pDataFormatDetail   Pointer to receive detail or NULL\n!\n! \\retval :: NVAPI_NOT_SUPPORTED   API is not supported\n!\n"]
    pub fn NvAPI_VIO_EnumDataFormats(
        hVioHandle: NvVioHandle,
        enumIndex: NvU32,
        pDataFormatDetail: *mut NVVIODATAFORMATDETAIL,
    ) -> NvAPI_Status;
}
#[doc = "!< Default registry configuration profile."]
pub const _NV_StereoRegistryProfileType_NVAPI_STEREO_DEFAULT_REGISTRY_PROFILE:
    _NV_StereoRegistryProfileType = 0;
#[doc = "!< Separate registry configuration profile for a DirectX 9 executable."]
pub const _NV_StereoRegistryProfileType_NVAPI_STEREO_DX9_REGISTRY_PROFILE:
    _NV_StereoRegistryProfileType = 1;
#[doc = "!< Separate registry configuration profile for a DirectX 10 executable."]
pub const _NV_StereoRegistryProfileType_NVAPI_STEREO_DX10_REGISTRY_PROFILE:
    _NV_StereoRegistryProfileType = 2;
#[doc = "! \\ingroup stereoapi\n! Used in NvAPI_Stereo_CreateConfigurationProfileRegistryKey()"]
pub type _NV_StereoRegistryProfileType = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi\n! Used in NvAPI_Stereo_CreateConfigurationProfileRegistryKey()"]
pub use self::_NV_StereoRegistryProfileType as NV_STEREO_REGISTRY_PROFILE_TYPE;
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_CreateConfigurationProfileRegistryKey(
        registryProfileType: NV_STEREO_REGISTRY_PROFILE_TYPE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   Removes configuration registry key for current application.\n!\n!                If an application already has a configuration profile prior to this function call,\n!                the function attempts to remove the application's configuration profile registry key from the registry.\n!                If there is no configuration profile registry key prior to the function call,\n!                the function does nothing and does not report an error.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]   registryProfileType   Type of profile that the application wants to delete. This should be one of the symbolic\n!                                     constants defined in ::NV_STEREO_REGISTRY_PROFILE_TYPE. Any other value will cause the function\n!                                     to do nothing and return ::NV_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.\n!\n! \\retval ::NVAPI_OK                                           Key does not exist in the registry any more.\n! \\retval ::NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED   This profile type is not supported.\n! \\retval ::NVAPI_STEREO_REGISTRY_ACCESS_FAILED                Access to registry failed.\n! \\retval ::NVAPI_API_NOT_INTIALIZED                           NVAPI is not initialized.\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED                       Stereo part of NVAPI is not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_DeleteConfigurationProfileRegistryKey(
        registryProfileType: NV_STEREO_REGISTRY_PROFILE_TYPE,
    ) -> NvAPI_Status;
}
#[doc = "!< Symbolic constant for convergence registry ID."]
pub const _NV_StereoRegistryID_NVAPI_CONVERGENCE_ID: _NV_StereoRegistryID = 0;
#[doc = "!< Symbolic constant for frustum adjust mode registry ID."]
pub const _NV_StereoRegistryID_NVAPI_FRUSTUM_ADJUST_MODE_ID: _NV_StereoRegistryID = 1;
#[doc = "! \\ingroup stereoapi\n! Used in NvAPI_Stereo_SetConfigurationProfileValue()"]
pub type _NV_StereoRegistryID = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi\n! Used in NvAPI_Stereo_SetConfigurationProfileValue()"]
pub use self::_NV_StereoRegistryID as NV_STEREO_REGISTRY_ID;
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_SetConfigurationProfileValue(
        registryProfileType: NV_STEREO_REGISTRY_PROFILE_TYPE,
        valueRegistryID: NV_STEREO_REGISTRY_ID,
        pValue: *mut ::std::os::raw::c_void,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API removes the given value from the application's configuration profile registry key.\n!                If there is no such value, the function does nothing and does not report an error.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]     registryProfileType   The type of profile the application wants to access. It should be one of the\n!                                       symbolic constants defined in ::NV_STEREO_REGISTRY_PROFILE_TYPE. Any other value will\n!                                       cause function to do nothing and return ::NV_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.\n! \\param [in]     valueRegistryID       ID of the value that is being deleted. It should be one of the symbolic constants defined in\n!                                       ::NV_STEREO_REGISTRY_PROFILE_TYPE. Any other value will cause function to do nothing and return\n!                                       ::NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED.\n!\n! \\retval ::NVAPI_OK                                           Value does not exist in registry any more.\n! \\retval ::NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED   This profile type is not supported.\n! \\retval ::NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED          This value is not supported.\n! \\retval ::NVAPI_STEREO_REGISTRY_ACCESS_FAILED                Access to registry failed.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED                       Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_DeleteConfigurationProfileValue(
        registryProfileType: NV_STEREO_REGISTRY_PROFILE_TYPE,
        valueRegistryID: NV_STEREO_REGISTRY_ID,
    ) -> NvAPI_Status;
}
#[doc = "! \\addtogroup stereoapi\n! @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVAPI_STEREO_CAPS {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved2: [NvU32; 3usize],
}
#[test]
fn bindgen_test_layout__NVAPI_STEREO_CAPS() {
    const UNINIT: ::std::mem::MaybeUninit<_NVAPI_STEREO_CAPS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVAPI_STEREO_CAPS>(),
        20usize,
        concat!("Size of: ", stringify!(_NVAPI_STEREO_CAPS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVAPI_STEREO_CAPS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVAPI_STEREO_CAPS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVAPI_STEREO_CAPS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVAPI_STEREO_CAPS),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NVAPI_STEREO_CAPS {
    #[inline]
    pub fn supportsWindowedModeOff(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supportsWindowedModeOff(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportsWindowedModeAutomatic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supportsWindowedModeAutomatic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportsWindowedModePersistent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supportsWindowedModePersistent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supportsWindowedModeOff: NvU32,
        supportsWindowedModeAutomatic: NvU32,
        supportsWindowedModePersistent: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supportsWindowedModeOff: u32 =
                unsafe { ::std::mem::transmute(supportsWindowedModeOff) };
            supportsWindowedModeOff as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let supportsWindowedModeAutomatic: u32 =
                unsafe { ::std::mem::transmute(supportsWindowedModeAutomatic) };
            supportsWindowedModeAutomatic as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let supportsWindowedModePersistent: u32 =
                unsafe { ::std::mem::transmute(supportsWindowedModePersistent) };
            supportsWindowedModePersistent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "! \\addtogroup stereoapi\n! @{"]
pub type NVAPI_STEREO_CAPS_V1 = _NVAPI_STEREO_CAPS;
#[doc = "! \\addtogroup stereoapi\n! @{"]
pub type NVAPI_STEREO_CAPS = NVAPI_STEREO_CAPS_V1;
extern "C" {
    #[doc = "! DESCRIPTION:  This API checks what kind of stereo support is currently supported on a particular display.\n!               If the the display is prohibited from showing stereo (e.g. secondary in a multi-mon setup), we will\n!               return 0 for all stereo modes (full screen exclusive, automatic windowed, persistent windowed).\n!               Otherwise, we will check which stereo mode is supported. On 120Hz display, this will be what\n!               the user chooses in control panel. On HDMI 1.4 display, persistent windowed mode is always assumed to be\n!               supported. Note that this function does not check if the CURRENT RESOLUTION/REFRESH RATE can support\n!               stereo. For HDMI 1.4, it is the app's responsibility to change the resolution/refresh rate to one that is\n!               3D compatible. For 120Hz, the driver will ALWAYS force 120Hz anyway.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 304\n!\n! \\param [in]     hMonitor handle to monitor that app is going to run on\n! \\param [out]    pCaps    Address where the result of the inquiry will be placed.\n!                          *pCaps is defined in NVAPI_STEREO_CAPS.\n! \\return       This API can return any of the following error codes enumerated in #NvAPI_Status\n! \\retval ::NVAPI_OK\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_GetStereoSupport(
        hMonitor: NvMonitorHandle,
        pCaps: *mut NVAPI_STEREO_CAPS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API decreases separation for the given device interface (just like the Ctrl+F3 hotkey).\n!\n! WHEN TO USE:   After the stereo handle for device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]   stereoHandle  Stereo handle that corresponds to the device interface.\n!\n! \\retval ::NVAPI_OK - Decrease of separation percentage was successfull.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR - Something is wrong (generic error).\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_DecreaseSeparation(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API increases separation for the given device interface (just like the Ctrl+F4 hotkey).\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]    stereoHandle  Stereo handle that corresponds to the device interface.\n!\n! \\retval ::NVAPI_OK                               Increase of separation percentage was successfull.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED               NVAPI not initialized.\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR                            Something is wrong (generic error).\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_IncreaseSeparation(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API decreases convergence for the given device interface (just like the Ctrl+F5 hotkey).\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]     stereoHandle  Stereo handle that corresponds to the device interface.\n!\n! \\retval ::NVAPI_OK - Decrease of convergence was successfull.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR - Something is wrong (generic error).\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_DecreaseConvergence(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API increases convergence for given the device interface (just like the Ctrl+F5 hotkey).\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]    stereoHandle  Stereo handle that corresponds to the device interface.\n!\n! \\retval ::NVAPI_OK                               Increase of convergence was successfull.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_IncreaseConvergence(stereoHandle: StereoHandle) -> NvAPI_Status;
}
#[doc = "!< Do not adjust frustum."]
pub const _NV_FrustumAdjustMode_NVAPI_NO_FRUSTUM_ADJUST: _NV_FrustumAdjustMode = 0;
#[doc = "!< Stretch images in X."]
pub const _NV_FrustumAdjustMode_NVAPI_FRUSTUM_STRETCH: _NV_FrustumAdjustMode = 1;
#[doc = "!< Clear corresponding edges for each eye."]
pub const _NV_FrustumAdjustMode_NVAPI_FRUSTUM_CLEAR_EDGES: _NV_FrustumAdjustMode = 2;
#[doc = "! \\ingroup stereoapi\n! Used in NvAPI_Stereo_GetFrustumAdjustMode()."]
pub type _NV_FrustumAdjustMode = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi\n! Used in NvAPI_Stereo_GetFrustumAdjustMode()."]
pub use self::_NV_FrustumAdjustMode as NV_FRUSTUM_ADJUST_MODE;
extern "C" {
    #[doc = "! \\ingroup stereoapi"]
    pub fn NvAPI_Stereo_GetFrustumAdjustMode(
        stereoHandle: StereoHandle,
        pFrustumAdjustMode: *mut NV_FRUSTUM_ADJUST_MODE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API sets the current frustum adjust mode value.\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]     stereoHandle                Stereo handle that corresponds to the device interface.\n! \\param [in]     newFrustumAdjustModeValue   New value for frustum adjust mode. It should be one of the symbolic constants defined in\n!                                             ::NV_FRUSTUM_ADJUST_MODE. Any other value will cause function to do nothing and return\n!                                             ::NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED.\n!\n! \\retval ::NVAPI_OK                                         Retrieval of frustum adjust mode was successfull.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE            Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED                     Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED   Given frustum adjust mode is not supported.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_SetFrustumAdjustMode(
        stereoHandle: StereoHandle,
        newFrustumAdjustModeValue: NV_FRUSTUM_ADJUST_MODE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API captures the current stereo image in JPEG stereo format with the given quality.\n!                Only the last capture call per flip will be effective.\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]     stereoHandle  Stereo handle that corresponds to the device interface.\n! \\param [in]     quality        Quality of the JPEG image to be captured. Integer value betweeen 0 and 100.\n!\n! \\retval ::NVAPI_OK                              Image captured.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED\n! \\retval ::NVAPI_STEREO_PARAMETER_OUT_OF_RANGE   Given quality is out of [0..100] range.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_CaptureJpegImage(
        stereoHandle: StereoHandle,
        quality: NvU32,
    ) -> NvAPI_Status;
}
pub const _NVAPI_STEREO_INIT_ACTIVATION_FLAGS_NVAPI_STEREO_INIT_ACTIVATION_IMMEDIATE:
    _NVAPI_STEREO_INIT_ACTIVATION_FLAGS = 0;
pub const _NVAPI_STEREO_INIT_ACTIVATION_FLAGS_NVAPI_STEREO_INIT_ACTIVATION_DELAYED:
    _NVAPI_STEREO_INIT_ACTIVATION_FLAGS = 1;
#[doc = "! InitActivation Flags"]
pub type _NVAPI_STEREO_INIT_ACTIVATION_FLAGS = ::std::os::raw::c_int;
#[doc = "! InitActivation Flags"]
pub use self::_NVAPI_STEREO_INIT_ACTIVATION_FLAGS as NVAPI_STEREO_INIT_ACTIVATION_FLAGS;
extern "C" {
    pub fn NvAPI_Stereo_InitActivation(
        hStereoHandle: StereoHandle,
        flags: NVAPI_STEREO_INIT_ACTIVATION_FLAGS,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API allows an application to trigger creation of a stereo desktop,\n!\t\t\t\t   in case the creation was stopped on application launch.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n! \\since Release: 302\n!\n! \\param [in]   stereoHandle   Stereo handle that corresponds to the device interface.\n!\n! \\return This API can return any of the error codes enumerated in #NvAPI_Status.\n!         If there are return error codes with specific meaning for this API,\n!         they are listed below.\n! \\retval ::NVAPI_STEREO_INIT_ACTIVATION_NOT_DONE - Stereo InitActivation not called.\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_Trigger_Activation(hStereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API captures the current stereo image in PNG stereo format.\n!                Only the last capture call per flip will be effective.\n!\n! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n! \\param [in]     stereoHandle  Stereo handle corresponding to the device interface.\n!\n! \\retval ::NVAPI_OK                               Image captured.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_CapturePngImage(stereoHandle: StereoHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API turns on/off reverse stereo blit.\n!\n! HOW TO USE:    Use after the stereo handle for the device interface is created via successfull call to the appropriate\n!                NvAPI_Stereo_CreateHandleFrom() function.\n!                After reversed stereo blit control is turned on, blits from the stereo surface will\n!                produce the right-eye image in the left side of the destination surface and the left-eye\n!                image in the right side of the destination surface.\n!\n!                In DirectX 9, the destination surface must be created as the render target, and StretchRect must be used.\n!                Conditions:\n!                - DstWidth == 2*SrcWidth\n!                - DstHeight == SrcHeight\n!                - Src surface is the stereo surface.\n!                - SrcRect must be {0,0,SrcWidth,SrcHeight}\n!                - DstRect must be {0,0,DstWidth,DstHeight}\n!\n!                In DirectX 10, ResourceCopyRegion must be used.\n!                Conditions:\n!                - DstWidth == 2*SrcWidth\n!                - DstHeight == SrcHeight\n!                - dstX == 0,\n!                - dstY == 0,\n!                - dstZ == 0,\n!                - SrcBox: left=top=front==0; right==SrcWidth; bottom==SrcHeight; back==1;\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 185\n!\n! \\param [in]    stereoHandle  Stereo handle corresponding to the device interface.\n! \\param [in]    TurnOn         != 0 : Turns on \\n\n!                               == 0 : Turns off\n!\n!\n! \\retval ::NVAPI_OK                                Retrieval of frustum adjust mode was successfull.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_ReverseStereoBlitControl(
        hStereoHandle: StereoHandle,
        TurnOn: NvU8,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:   This API is a Setup notification message that the stereo driver uses to notify the application\n!                when the user changes the stereo driver state.\n!\n!                When the user changes the stereo state (Activated or Deactivated, separation or conversion)\n!                the stereo driver posts a defined message with the following parameters:\n!\n!                lParam  is the current conversion. (Actual conversion is *(float*)&lParam )\n!\n!                wParam == MAKEWPARAM(l, h) where\n!                - l == 0 if stereo is deactivated\n!                - l == 1 if stereo is deactivated\n!                - h is the current separation. (Actual separation is float(h*100.f/0xFFFF)\n!\n!                Call this API with NULL hWnd to prohibit notification.\n!\n! WHEN TO USE:   Use after the stereo handle for device interface is created via successful call to appropriate\n!                NvAPI_Stereo_CreateHandleFrom() function.\n!\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 180\n!\n!\n! \\param [in]     stereoHandle  Stereo handle corresponding to the device interface.\n! \\param [in]     hWnd          Window HWND that will be notified when the user changes the stereo driver state.\n!                               Actual HWND must be cast to an NvU64.\n! \\param [in]     messageID     MessageID of the message that will be posted to hWnd\n!\n! \\retval ::NVAPI_OK                                Notification set.\n! \\retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized.\n! \\retval ::NVAPI_ERROR\n!\n! \\ingroup stereoapi\n"]
    pub fn NvAPI_Stereo_SetNotificationMessage(
        hStereoHandle: StereoHandle,
        hWnd: NvU64,
        messageID: NvU64,
    ) -> NvAPI_Status;
}
pub const _NV_StereoSwapChainMode_NVAPI_STEREO_SWAPCHAIN_DEFAULT: _NV_StereoSwapChainMode = 0;
pub const _NV_StereoSwapChainMode_NVAPI_STEREO_SWAPCHAIN_STEREO: _NV_StereoSwapChainMode = 1;
pub const _NV_StereoSwapChainMode_NVAPI_STEREO_SWAPCHAIN_MONO: _NV_StereoSwapChainMode = 2;
#[doc = "! \\ingroup stereoapi"]
pub type _NV_StereoSwapChainMode = ::std::os::raw::c_int;
#[doc = "! \\ingroup stereoapi"]
pub use self::_NV_StereoSwapChainMode as NV_STEREO_SWAPCHAIN_MODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDRSSessionHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvDRSSessionHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvDRSSessionHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDRSSessionHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvDRSSessionHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDRSSessionHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvDRSSessionHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDRSSessionHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvDRSSessionHandle = *mut NvDRSSessionHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDRSProfileHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NvDRSProfileHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<NvDRSProfileHandle__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDRSProfileHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(NvDRSProfileHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDRSProfileHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(NvDRSProfileHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDRSProfileHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type NvDRSProfileHandle = *mut NvDRSProfileHandle__;
pub const _NVDRS_SETTING_TYPE_NVDRS_DWORD_TYPE: _NVDRS_SETTING_TYPE = 0;
pub const _NVDRS_SETTING_TYPE_NVDRS_BINARY_TYPE: _NVDRS_SETTING_TYPE = 1;
pub const _NVDRS_SETTING_TYPE_NVDRS_STRING_TYPE: _NVDRS_SETTING_TYPE = 2;
pub const _NVDRS_SETTING_TYPE_NVDRS_WSTRING_TYPE: _NVDRS_SETTING_TYPE = 3;
pub type _NVDRS_SETTING_TYPE = ::std::os::raw::c_int;
pub use self::_NVDRS_SETTING_TYPE as NVDRS_SETTING_TYPE;
pub const _NVDRS_SETTING_LOCATION_NVDRS_CURRENT_PROFILE_LOCATION: _NVDRS_SETTING_LOCATION = 0;
pub const _NVDRS_SETTING_LOCATION_NVDRS_GLOBAL_PROFILE_LOCATION: _NVDRS_SETTING_LOCATION = 1;
pub const _NVDRS_SETTING_LOCATION_NVDRS_BASE_PROFILE_LOCATION: _NVDRS_SETTING_LOCATION = 2;
pub const _NVDRS_SETTING_LOCATION_NVDRS_DEFAULT_PROFILE_LOCATION: _NVDRS_SETTING_LOCATION = 3;
pub type _NVDRS_SETTING_LOCATION = ::std::os::raw::c_int;
pub use self::_NVDRS_SETTING_LOCATION as NVDRS_SETTING_LOCATION;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_GPU_SUPPORT {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NVDRS_GPU_SUPPORT() {
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_GPU_SUPPORT>(),
        4usize,
        concat!("Size of: ", stringify!(_NVDRS_GPU_SUPPORT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_GPU_SUPPORT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_GPU_SUPPORT))
    );
}
impl _NVDRS_GPU_SUPPORT {
    #[inline]
    pub fn geforce(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_geforce(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quadro(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quadro(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nvs(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nvs(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved13(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved14(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved14(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved22(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved22(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved23(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved23(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved29(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved29(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved30(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved30(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved32(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved32(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        geforce: NvU32,
        quadro: NvU32,
        nvs: NvU32,
        reserved4: NvU32,
        reserved5: NvU32,
        reserved6: NvU32,
        reserved7: NvU32,
        reserved8: NvU32,
        reserved9: NvU32,
        reserved10: NvU32,
        reserved11: NvU32,
        reserved12: NvU32,
        reserved13: NvU32,
        reserved14: NvU32,
        reserved15: NvU32,
        reserved16: NvU32,
        reserved17: NvU32,
        reserved18: NvU32,
        reserved19: NvU32,
        reserved20: NvU32,
        reserved21: NvU32,
        reserved22: NvU32,
        reserved23: NvU32,
        reserved24: NvU32,
        reserved25: NvU32,
        reserved26: NvU32,
        reserved27: NvU32,
        reserved28: NvU32,
        reserved29: NvU32,
        reserved30: NvU32,
        reserved31: NvU32,
        reserved32: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let geforce: u32 = unsafe { ::std::mem::transmute(geforce) };
            geforce as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let quadro: u32 = unsafe { ::std::mem::transmute(quadro) };
            quadro as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let nvs: u32 = unsafe { ::std::mem::transmute(nvs) };
            nvs as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved4: u32 = unsafe { ::std::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reserved5: u32 = unsafe { ::std::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let reserved6: u32 = unsafe { ::std::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let reserved7: u32 = unsafe { ::std::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let reserved9: u32 = unsafe { ::std::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let reserved10: u32 = unsafe { ::std::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let reserved11: u32 = unsafe { ::std::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let reserved12: u32 = unsafe { ::std::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reserved13: u32 = unsafe { ::std::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved14: u32 = unsafe { ::std::mem::transmute(reserved14) };
            reserved14 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let reserved15: u32 = unsafe { ::std::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved16: u32 = unsafe { ::std::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let reserved17: u32 = unsafe { ::std::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let reserved18: u32 = unsafe { ::std::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let reserved19: u32 = unsafe { ::std::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let reserved20: u32 = unsafe { ::std::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let reserved21: u32 = unsafe { ::std::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let reserved22: u32 = unsafe { ::std::mem::transmute(reserved22) };
            reserved22 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let reserved23: u32 = unsafe { ::std::mem::transmute(reserved23) };
            reserved23 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let reserved24: u32 = unsafe { ::std::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let reserved25: u32 = unsafe { ::std::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let reserved26: u32 = unsafe { ::std::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let reserved27: u32 = unsafe { ::std::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let reserved28: u32 = unsafe { ::std::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let reserved29: u32 = unsafe { ::std::mem::transmute(reserved29) };
            reserved29 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let reserved30: u32 = unsafe { ::std::mem::transmute(reserved30) };
            reserved30 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let reserved31: u32 = unsafe { ::std::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved32: u32 = unsafe { ::std::mem::transmute(reserved32) };
            reserved32 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVDRS_GPU_SUPPORT = _NVDRS_GPU_SUPPORT;
#[doc = "! Enum to decide on the datatype of setting value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_BINARY_SETTING {
    #[doc = "!< valueLength should always be in number of bytes."]
    pub valueLength: NvU32,
    pub valueData: [NvU8; 4096usize],
}
#[test]
fn bindgen_test_layout__NVDRS_BINARY_SETTING() {
    const UNINIT: ::std::mem::MaybeUninit<_NVDRS_BINARY_SETTING> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_BINARY_SETTING>(),
        4100usize,
        concat!("Size of: ", stringify!(_NVDRS_BINARY_SETTING))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_BINARY_SETTING>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_BINARY_SETTING))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valueLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_BINARY_SETTING),
            "::",
            stringify!(valueLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valueData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_BINARY_SETTING),
            "::",
            stringify!(valueData)
        )
    );
}
#[doc = "! Enum to decide on the datatype of setting value."]
pub type NVDRS_BINARY_SETTING = _NVDRS_BINARY_SETTING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVDRS_SETTING_VALUES {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< Total number of values available in a setting."]
    pub numSettingValues: NvU32,
    #[doc = "!< Type of setting value."]
    pub settingType: NVDRS_SETTING_TYPE,
    pub __bindgen_anon_1: _NVDRS_SETTING_VALUES__bindgen_ty_1,
    pub settingValues: [_NVDRS_SETTING_VALUES__bindgen_ty_2; 100usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVDRS_SETTING_VALUES__bindgen_ty_1 {
    #[doc = "!< Accessing default DWORD value of this setting."]
    pub u32DefaultValue: NvU32,
    #[doc = "!< Accessing default Binary value of this setting.\n!< Must be allocated by caller with valueLength specifying buffer size, or only valueLength will be filled in."]
    pub binaryDefaultValue: NVDRS_BINARY_SETTING,
    #[doc = "!< Accessing default unicode string value of this setting."]
    pub wszDefaultValue: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_SETTING_VALUES__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVDRS_SETTING_VALUES__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_SETTING_VALUES__bindgen_ty_1>(),
        4100usize,
        concat!("Size of: ", stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_SETTING_VALUES__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32DefaultValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_1),
            "::",
            stringify!(u32DefaultValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binaryDefaultValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_1),
            "::",
            stringify!(binaryDefaultValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wszDefaultValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_1),
            "::",
            stringify!(wszDefaultValue)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVDRS_SETTING_VALUES__bindgen_ty_2 {
    #[doc = "!< All possible DWORD values for a setting"]
    pub u32Value: NvU32,
    #[doc = "!< All possible Binary values for a setting"]
    pub binaryValue: NVDRS_BINARY_SETTING,
    #[doc = "!< Accessing current unicode string value of this setting."]
    pub wszValue: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_SETTING_VALUES__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_NVDRS_SETTING_VALUES__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_SETTING_VALUES__bindgen_ty_2>(),
        4100usize,
        concat!("Size of: ", stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_SETTING_VALUES__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_2),
            "::",
            stringify!(u32Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binaryValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_2),
            "::",
            stringify!(binaryValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wszValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_VALUES__bindgen_ty_2),
            "::",
            stringify!(wszValue)
        )
    );
}
#[test]
fn bindgen_test_layout__NVDRS_SETTING_VALUES() {
    const UNINIT: ::std::mem::MaybeUninit<_NVDRS_SETTING_VALUES> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_SETTING_VALUES>(),
        414112usize,
        concat!("Size of: ", stringify!(_NVDRS_SETTING_VALUES))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_SETTING_VALUES>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_SETTING_VALUES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_VALUES),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numSettingValues) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_VALUES),
            "::",
            stringify!(numSettingValues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).settingType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_VALUES),
            "::",
            stringify!(settingType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).settingValues) as usize - ptr as usize },
        4112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_VALUES),
            "::",
            stringify!(settingValues)
        )
    );
}
pub type NVDRS_SETTING_VALUES = _NVDRS_SETTING_VALUES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVDRS_SETTING_V1 {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< String name of setting"]
    pub settingName: NvAPI_UnicodeString,
    #[doc = "!< 32 bit setting Id"]
    pub settingId: NvU32,
    #[doc = "!< Type of setting value."]
    pub settingType: NVDRS_SETTING_TYPE,
    #[doc = "!< Describes where the value in CurrentValue comes from."]
    pub settingLocation: NVDRS_SETTING_LOCATION,
    #[doc = "!< It is different than 0 if the currentValue is a predefined Value,\n!< 0 if the currentValue is a user value."]
    pub isCurrentPredefined: NvU32,
    #[doc = "!< It is different than 0 if the PredefinedValue union contains a valid value."]
    pub isPredefinedValid: NvU32,
    pub __bindgen_anon_1: _NVDRS_SETTING_V1__bindgen_ty_1,
    pub __bindgen_anon_2: _NVDRS_SETTING_V1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVDRS_SETTING_V1__bindgen_ty_1 {
    #[doc = "!< Accessing default DWORD value of this setting."]
    pub u32PredefinedValue: NvU32,
    #[doc = "!< Accessing default Binary value of this setting.\n!< Must be allocated by caller with valueLength specifying buffer size,\n!< or only valueLength will be filled in."]
    pub binaryPredefinedValue: NVDRS_BINARY_SETTING,
    #[doc = "!< Accessing default unicode string value of this setting."]
    pub wszPredefinedValue: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_SETTING_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVDRS_SETTING_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_SETTING_V1__bindgen_ty_1>(),
        4100usize,
        concat!("Size of: ", stringify!(_NVDRS_SETTING_V1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_SETTING_V1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_SETTING_V1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32PredefinedValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1__bindgen_ty_1),
            "::",
            stringify!(u32PredefinedValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binaryPredefinedValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1__bindgen_ty_1),
            "::",
            stringify!(binaryPredefinedValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wszPredefinedValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1__bindgen_ty_1),
            "::",
            stringify!(wszPredefinedValue)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVDRS_SETTING_V1__bindgen_ty_2 {
    #[doc = "!< Accessing current DWORD value of this setting."]
    pub u32CurrentValue: NvU32,
    #[doc = "!< Accessing current Binary value of this setting.\n!< Must be allocated by caller with valueLength specifying buffer size,\n!< or only valueLength will be filled in."]
    pub binaryCurrentValue: NVDRS_BINARY_SETTING,
    #[doc = "!< Accessing current unicode string value of this setting."]
    pub wszCurrentValue: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_SETTING_V1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_NVDRS_SETTING_V1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_SETTING_V1__bindgen_ty_2>(),
        4100usize,
        concat!("Size of: ", stringify!(_NVDRS_SETTING_V1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_SETTING_V1__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_SETTING_V1__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32CurrentValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1__bindgen_ty_2),
            "::",
            stringify!(u32CurrentValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binaryCurrentValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1__bindgen_ty_2),
            "::",
            stringify!(binaryCurrentValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wszCurrentValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1__bindgen_ty_2),
            "::",
            stringify!(wszCurrentValue)
        )
    );
}
#[test]
fn bindgen_test_layout__NVDRS_SETTING_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVDRS_SETTING_V1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_SETTING_V1>(),
        12320usize,
        concat!("Size of: ", stringify!(_NVDRS_SETTING_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_SETTING_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_SETTING_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).settingName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1),
            "::",
            stringify!(settingName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).settingId) as usize - ptr as usize },
        4100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1),
            "::",
            stringify!(settingId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).settingType) as usize - ptr as usize },
        4104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1),
            "::",
            stringify!(settingType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).settingLocation) as usize - ptr as usize },
        4108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1),
            "::",
            stringify!(settingLocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isCurrentPredefined) as usize - ptr as usize },
        4112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1),
            "::",
            stringify!(isCurrentPredefined)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isPredefinedValid) as usize - ptr as usize },
        4116usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_SETTING_V1),
            "::",
            stringify!(isPredefinedValid)
        )
    );
}
pub type NVDRS_SETTING_V1 = _NVDRS_SETTING_V1;
pub type NVDRS_SETTING = NVDRS_SETTING_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_APPLICATION_V1 {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< Is the application userdefined/predefined"]
    pub isPredefined: NvU32,
    #[doc = "!< String name of the Application"]
    pub appName: NvAPI_UnicodeString,
    #[doc = "!< UserFriendly name of the Application"]
    pub userFriendlyName: NvAPI_UnicodeString,
    #[doc = "!< Indicates the name (if any) of the launcher that starts the application"]
    pub launcher: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_APPLICATION_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVDRS_APPLICATION_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_APPLICATION_V1>(),
        12296usize,
        concat!("Size of: ", stringify!(_NVDRS_APPLICATION_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_APPLICATION_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_APPLICATION_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isPredefined) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V1),
            "::",
            stringify!(isPredefined)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V1),
            "::",
            stringify!(appName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userFriendlyName) as usize - ptr as usize },
        4104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V1),
            "::",
            stringify!(userFriendlyName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launcher) as usize - ptr as usize },
        8200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V1),
            "::",
            stringify!(launcher)
        )
    );
}
pub type NVDRS_APPLICATION_V1 = _NVDRS_APPLICATION_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_APPLICATION_V2 {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< Is the application userdefined/predefined"]
    pub isPredefined: NvU32,
    #[doc = "!< String name of the Application"]
    pub appName: NvAPI_UnicodeString,
    #[doc = "!< UserFriendly name of the Application"]
    pub userFriendlyName: NvAPI_UnicodeString,
    #[doc = "!< Indicates the name (if any) of the launcher that starts the Application"]
    pub launcher: NvAPI_UnicodeString,
    #[doc = "!< Select this application only if this file is found.\n!< When specifying multiple files, separate them using the ':' character."]
    pub fileInFolder: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_APPLICATION_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NVDRS_APPLICATION_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_APPLICATION_V2>(),
        16392usize,
        concat!("Size of: ", stringify!(_NVDRS_APPLICATION_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_APPLICATION_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_APPLICATION_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isPredefined) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V2),
            "::",
            stringify!(isPredefined)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V2),
            "::",
            stringify!(appName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userFriendlyName) as usize - ptr as usize },
        4104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V2),
            "::",
            stringify!(userFriendlyName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launcher) as usize - ptr as usize },
        8200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V2),
            "::",
            stringify!(launcher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileInFolder) as usize - ptr as usize },
        12296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V2),
            "::",
            stringify!(fileInFolder)
        )
    );
}
pub type NVDRS_APPLICATION_V2 = _NVDRS_APPLICATION_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_APPLICATION_V3 {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< Is the application userdefined/predefined"]
    pub isPredefined: NvU32,
    #[doc = "!< String name of the Application"]
    pub appName: NvAPI_UnicodeString,
    #[doc = "!< UserFriendly name of the Application"]
    pub userFriendlyName: NvAPI_UnicodeString,
    #[doc = "!< Indicates the name (if any) of the launcher that starts the Application"]
    pub launcher: NvAPI_UnicodeString,
    #[doc = "!< Select this application only if this file is found.\n!< When specifying multiple files, separate them using the ':' character."]
    pub fileInFolder: NvAPI_UnicodeString,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NVDRS_APPLICATION_V3() {
    const UNINIT: ::std::mem::MaybeUninit<_NVDRS_APPLICATION_V3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_APPLICATION_V3>(),
        16396usize,
        concat!("Size of: ", stringify!(_NVDRS_APPLICATION_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_APPLICATION_V3>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_APPLICATION_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isPredefined) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V3),
            "::",
            stringify!(isPredefined)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V3),
            "::",
            stringify!(appName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userFriendlyName) as usize - ptr as usize },
        4104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V3),
            "::",
            stringify!(userFriendlyName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launcher) as usize - ptr as usize },
        8200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V3),
            "::",
            stringify!(launcher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileInFolder) as usize - ptr as usize },
        12296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V3),
            "::",
            stringify!(fileInFolder)
        )
    );
}
impl _NVDRS_APPLICATION_V3 {
    #[inline]
    pub fn isMetro(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMetro(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isCommandLine(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isCommandLine(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isMetro: NvU32,
        isCommandLine: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isMetro: u32 = unsafe { ::std::mem::transmute(isMetro) };
            isMetro as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isCommandLine: u32 = unsafe { ::std::mem::transmute(isCommandLine) };
            isCommandLine as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVDRS_APPLICATION_V3 = _NVDRS_APPLICATION_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_APPLICATION_V4 {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< Is the application userdefined/predefined"]
    pub isPredefined: NvU32,
    #[doc = "!< String name of the Application"]
    pub appName: NvAPI_UnicodeString,
    #[doc = "!< UserFriendly name of the Application"]
    pub userFriendlyName: NvAPI_UnicodeString,
    #[doc = "!< Indicates the name (if any) of the launcher that starts the Application"]
    pub launcher: NvAPI_UnicodeString,
    #[doc = "!< Select this application only if this file is found.\n!< When specifying multiple files, separate them using the ':' character."]
    pub fileInFolder: NvAPI_UnicodeString,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< If isCommandLine is set to 0 this must be an empty. If isCommandLine is set to 1\n!< this contains application's command line as if it was returned by GetCommandLineW."]
    pub commandLine: NvAPI_UnicodeString,
}
#[test]
fn bindgen_test_layout__NVDRS_APPLICATION_V4() {
    const UNINIT: ::std::mem::MaybeUninit<_NVDRS_APPLICATION_V4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_APPLICATION_V4>(),
        20492usize,
        concat!("Size of: ", stringify!(_NVDRS_APPLICATION_V4))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_APPLICATION_V4>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_APPLICATION_V4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V4),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isPredefined) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V4),
            "::",
            stringify!(isPredefined)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V4),
            "::",
            stringify!(appName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userFriendlyName) as usize - ptr as usize },
        4104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V4),
            "::",
            stringify!(userFriendlyName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launcher) as usize - ptr as usize },
        8200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V4),
            "::",
            stringify!(launcher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileInFolder) as usize - ptr as usize },
        12296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V4),
            "::",
            stringify!(fileInFolder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commandLine) as usize - ptr as usize },
        16396usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_APPLICATION_V4),
            "::",
            stringify!(commandLine)
        )
    );
}
impl _NVDRS_APPLICATION_V4 {
    #[inline]
    pub fn isMetro(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMetro(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isCommandLine(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isCommandLine(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isMetro: NvU32,
        isCommandLine: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isMetro: u32 = unsafe { ::std::mem::transmute(isMetro) };
            isMetro as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isCommandLine: u32 = unsafe { ::std::mem::transmute(isCommandLine) };
            isCommandLine as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVDRS_APPLICATION_V4 = _NVDRS_APPLICATION_V4;
pub type NVDRS_APPLICATION = NVDRS_APPLICATION_V4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVDRS_PROFILE_V1 {
    #[doc = "!< Structure Version"]
    pub version: NvU32,
    #[doc = "!< String name of the Profile"]
    pub profileName: NvAPI_UnicodeString,
    #[doc = "!< This read-only flag indicates the profile support on either\n!< Quadro, or Geforce, or both."]
    pub gpuSupport: NVDRS_GPU_SUPPORT,
    #[doc = "!< Is the Profile user-defined, or predefined"]
    pub isPredefined: NvU32,
    #[doc = "!< Total number of applications that belong to this profile. Read-only"]
    pub numOfApps: NvU32,
    #[doc = "!< Total number of settings applied for this Profile. Read-only"]
    pub numOfSettings: NvU32,
}
#[test]
fn bindgen_test_layout__NVDRS_PROFILE_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NVDRS_PROFILE_V1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVDRS_PROFILE_V1>(),
        4116usize,
        concat!("Size of: ", stringify!(_NVDRS_PROFILE_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVDRS_PROFILE_V1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVDRS_PROFILE_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_PROFILE_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profileName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_PROFILE_V1),
            "::",
            stringify!(profileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuSupport) as usize - ptr as usize },
        4100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_PROFILE_V1),
            "::",
            stringify!(gpuSupport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isPredefined) as usize - ptr as usize },
        4104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_PROFILE_V1),
            "::",
            stringify!(isPredefined)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numOfApps) as usize - ptr as usize },
        4108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_PROFILE_V1),
            "::",
            stringify!(numOfApps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numOfSettings) as usize - ptr as usize },
        4112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVDRS_PROFILE_V1),
            "::",
            stringify!(numOfSettings)
        )
    );
}
pub type NVDRS_PROFILE_V1 = _NVDRS_PROFILE_V1;
pub type NVDRS_PROFILE = NVDRS_PROFILE_V1;
extern "C" {
    pub fn NvAPI_DRS_CreateSession(phSession: *mut NvDRSSessionHandle) -> NvAPI_Status;
}
extern "C" {
    pub fn NvAPI_DRS_DestroySession(hSession: NvDRSSessionHandle) -> NvAPI_Status;
}
extern "C" {
    pub fn NvAPI_DRS_LoadSettings(hSession: NvDRSSessionHandle) -> NvAPI_Status;
}
extern "C" {
    pub fn NvAPI_DRS_SaveSettings(hSession: NvDRSSessionHandle) -> NvAPI_Status;
}
extern "C" {
    pub fn NvAPI_DRS_LoadSettingsFromFile(
        hSession: NvDRSSessionHandle,
        fileName: *mut NvU16,
    ) -> NvAPI_Status;
}
extern "C" {
    pub fn NvAPI_DRS_SaveSettingsToFile(
        hSession: NvDRSSessionHandle,
        fileName: *mut NvU16,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API creates an empty profile.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  hSession        Input to the session handle.\n! \\param [in]  *pProfileInfo   Input pointer to NVDRS_PROFILE.\n! \\param [in]  *phProfile      Returns pointer to profile handle.\n!\n! \\retval ::NVAPI_OK     SUCCESS\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_CreateProfile(
        hSession: NvDRSSessionHandle,
        pProfileInfo: *mut NVDRS_PROFILE,
        phProfile: *mut NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API deletes a profile or sets it back to a predefined value.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in] hSession  Input to the session handle.\n! \\param [in] hProfile  Input profile handle.\n!\n! \\retval ::NVAPI_OK     SUCCESS if the profile is found\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_DeleteProfile(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API sets the current global profile in the driver.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in] hSession                Input to the session handle.\n! \\param [in] wszGlobalProfileName    Input current Global profile name.\n!\n! \\retval ::NVAPI_OK     SUCCESS\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_SetCurrentGlobalProfile(
        hSession: NvDRSSessionHandle,
        wszGlobalProfileName: *mut NvU16,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API returns the handle to the current global profile.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]   hSession     Input to the session handle.\n! \\param [out]  *phProfile   Returns current Global profile handle.\n!\n! \\retval ::NVAPI_OK     SUCCESS\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_GetCurrentGlobalProfile(
        hSession: NvDRSSessionHandle,
        phProfile: *mut NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API gets information about the given profile. User needs to specify the name of the Profile.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  hSession       Input to the session handle.\n! \\param [in]  hProfile       Input profile handle.\n! \\param [out] *pProfileInfo  Return the profile info.\n!\n! \\retval ::NVAPI_OK     SUCCESS\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_GetProfileInfo(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        pProfileInfo: *mut NVDRS_PROFILE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Specifies flags for a given profile. Currently only the NVDRS_GPU_SUPPORT is\n!                used to update the profile. Neither the name, number of settings or applications\n!                or other profile information can be changed with this function.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  hSession       Input to the session handle.\n! \\param [in]  hProfile       Input profile handle.\n! \\param [in]  *pProfileInfo  Input the new profile info.\n!\n! \\retval ::NVAPI_OK     SUCCESS\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_SetProfileInfo(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        pProfileInfo: *mut NVDRS_PROFILE,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API finds a profile in the current session.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]   hSession      Input to the session handle.\n! \\param [in]   profileName   Input profileName.\n! \\param [out]  phProfile     Input profile handle.\n!\n! \\retval ::NVAPI_OK                SUCCESS if the profile is found\n! \\retval ::NVAPI_PROFILE_NOT_FOUND if profile is not found\n! \\retval ::NVAPI_ERROR             For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_FindProfileByName(
        hSession: NvDRSSessionHandle,
        profileName: *mut NvU16,
        phProfile: *mut NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API enumerates through all the profiles in the session.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]   hSession        Input to the session handle.\n! \\param [in]   index           Input the index for enumeration.\n! \\param [out]  *phProfile      Returns profile handle.\n!\n!   RETURN STATUS: NVAPI_OK: SUCCESS if the profile is found\n!                  NVAPI_ERROR: For miscellaneous errors.\n!                  NVAPI_END_ENUMERATION: index exceeds the total number of available Profiles in DB.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_EnumProfiles(
        hSession: NvDRSSessionHandle,
        index: NvU32,
        phProfile: *mut NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API obtains the number of profiles in the current session object.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  hSession       Input to the session handle.\n! \\param out]  *numProfiles   Returns count of profiles in the current hSession.\n!\n! \\retval ::NVAPI_OK                  SUCCESS\n! \\retval ::NVAPI_API_NOT_INTIALIZED  Failed to initialize.\n! \\retval ::NVAPI_INVALID_ARGUMENT    Invalid Arguments.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_GetNumProfiles(
        hSession: NvDRSSessionHandle,
        numProfiles: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API adds an executable name to a profile.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  hSession       Input to the session handle.\n! \\param [in]  hProfile       Input profile handle.\n! \\param [in]  *pApplication  Input NVDRS_APPLICATION struct with the executable name to be added.\n!\n! \\retval ::NVAPI_OK     SUCCESS\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_CreateApplication(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        pApplication: *mut NVDRS_APPLICATION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API removes an executable from a profile.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]   hSession  - Input to the session handle.\n! \\param [in]   hProfile  - Input profile handle.\n! \\param [in]   *pApp     - Input all the information about the application to be removed.\n!\n! \\retval ::NVAPI_OK  SUCCESS\n! \\retval ::NVAPI_ERROR For miscellaneous errors.\n! \\retval ::NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS If the path provided could refer to two different executables,\n!                                              this error will be returned.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_DeleteApplicationEx(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        pApp: *mut NVDRS_APPLICATION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API removes an executable name from a profile.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  hSessionPARAMETERS   Input to the session handle.\n! \\param [in]  hProfile             Input profile handle.\n! \\param [in]  appName              Input the executable name to be removed.\n!\n! \\retval ::NVAPI_OK     SUCCESS\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n! \\retval ::NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS If the path provided could refer to two different executables,\n!                                              this error will be returned\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_DeleteApplication(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        appName: *mut NvU16,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\retval ::NVAPI_EXECUTABLE_NOT_FOUND           No application with that name is found on the profile.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_GetApplicationInfo(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        appName: *mut NvU16,
        pApplication: *mut NVDRS_APPLICATION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API enumerates all the applications in a given profile from the starting index to the maximum length.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]      hSession         Input to the session handle.\n! \\param [in]      hProfile         Input profile handle.\n! \\param [in]      startIndex       Indicates starting index for enumeration.\n! \\param [in,out]  *appCount        Input maximum length of the passed in arrays. Returns the actual length.\n! \\param [out]     *pApplication    Returns NVDRS_APPLICATION struct with all the attributes.\n!\n! \\retval ::NVAPI_OK               SUCCESS\n! \\retval ::NVAPI_ERROR            For miscellaneous errors.\n! \\retval ::NVAPI_END_ENUMERATION  startIndex exceeds the total appCount.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_EnumApplications(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        startIndex: NvU32,
        appCount: *mut NvU32,
        pApplication: *mut NVDRS_APPLICATION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API searches the application and the associated profile for the given application name.\n!                If a fully qualified path is provided, this function will always return the profile\n!                the driver will apply upon running the application (on the path provided).\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]      hSession       Input to the hSession handle\n! \\param [in]      appName        Input appName. For best results, provide a fully qualified path of the type\n!                                 c:/Folder1/Folder2/App.exe\n! \\param [out]     *phProfile     Returns profile handle.\n! \\param [in,out]  *pApplication  Returns NVDRS_APPLICATION struct pointer.\n!\n! \\return  This API can return any of the error codes enumerated in #NvAPI_Status.\n!                  If there are return error codes with specific meaning for this API,\n!                  they are listed below:\n! \\retval ::NVAPI_APPLICATION_NOT_FOUND          If App not found\n! \\retval ::NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS   If the input appName was not fully qualified, this error might return in the case of multiple matches\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_FindApplicationByName(
        hSession: NvDRSSessionHandle,
        appName: *mut NvU16,
        phProfile: *mut NvDRSProfileHandle,
        pApplication: *mut NVDRS_APPLICATION,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API adds/modifies a setting to a profile.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  hSession     Input to the session handle.\n! \\param [in]  hProfile     Input profile handle.\n! \\param [in]   *pSetting   Input NVDRS_SETTING struct pointer.\n!\n! \\retval ::NVAPI_OK     SUCCESS\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_SetSetting(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        pSetting: *mut NVDRS_SETTING,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API gets information about the given setting.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]   hSession   Input to the session handle.\n! \\param [in]   hProfile   Input profile handle.\n! \\param [in]   settingId  Input settingId.\n! \\param [out]  *pSetting  Returns all the setting info\n!\n! \\retval ::NVAPI_OK     SUCCESS\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_GetSetting(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        settingId: NvU32,
        pSetting: *mut NVDRS_SETTING,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API enumerates all the settings of a given profile from startIndex to the maximum length.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]      hSession        Input to the session handle.\n! \\param [in]      hProfile        Input profile handle.\n! \\param [in]      startIndex      Indicates starting index for enumeration.\n! \\param [in,out]  *settingsCount  Input max length of the passed in arrays, Returns the actual length.\n! \\param [out]     *pSetting       Returns all the settings info.\n!\n! \\retval ::NVAPI_OK              SUCCESS\n! \\retval ::NVAPI_ERROR           For miscellaneous errors.\n! \\retval ::NVAPI_END_ENUMERATION startIndex exceeds the total appCount.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_EnumSettings(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        startIndex: NvU32,
        settingsCount: *mut NvU32,
        pSetting: *mut NVDRS_SETTING,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API enumerates all the Ids of all the settings recognized by NVAPI.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [out]    pSettingIds     User-provided array of length *pMaxCount that NVAPI will fill with IDs.\n! \\param [in,out] pMaxCount       Input max length of the passed in array, Returns the actual length.\n!\n! \\retval ::NVAPI_OK     SUCCESS\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!                  NVAPI_END_ENUMERATION: the provided pMaxCount is not enough to hold all settingIds.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_EnumAvailableSettingIds(
        pSettingIds: *mut NvU32,
        pMaxCount: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API enumerates all available setting values for a given setting.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]      settingId          Input settingId.\n! \\param [in,out]  pMaxNumValues      Input max length of the passed in arrays, Returns the actual length.\n! \\param [out]     *pSettingValues    Returns all available setting values and its count.\n!\n! \\retval ::NVAPI_OK     SUCCESS\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_EnumAvailableSettingValues(
        settingId: NvU32,
        pMaxNumValues: *mut NvU32,
        pSettingValues: *mut NVDRS_SETTING_VALUES,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API gets the binary ID of a setting given the setting name.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]   settingName  Input Unicode settingName.\n! \\param [out]  *pSettingId  Returns corresponding settingId.\n!\n! \\retval ::NVAPI_OK                 SUCCESS if the profile is found\n! \\retval ::NVAPI_PROFILE_NOT_FOUND  if profile is not found\n! \\retval ::NVAPI_SETTING_NOT_FOUND  if setting is not found\n! \\retval ::NVAPI_ERROR              For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_GetSettingIdFromName(
        settingName: *mut NvU16,
        pSettingId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API gets the setting name given the binary ID.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  settingId        Input settingId.\n! \\param [in]  *pSettingName    Returns corresponding Unicode settingName.\n!\n! \\retval ::NVAPI_OK                 SUCCESS if the profile is found\n! \\retval ::NVAPI_PROFILE_NOT_FOUND  if profile is not found\n! \\retval ::NVAPI_SETTING_NOT_FOUND  if setting is not found\n! \\retval ::NVAPI_ERROR              For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_GetSettingNameFromId(
        settingId: NvU32,
        pSettingName: *mut NvAPI_UnicodeString,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API deletes a setting or sets it back to predefined value.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  hSession            Input to the session handle.\n! \\param [in]  hProfile            Input profile handle.\n! \\param [in]  settingId           Input settingId to be deleted.\n!\n! \\retval ::NVAPI_OK     SUCCESS if the profile is found\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_DeleteProfileSetting(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        settingId: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API restores the whole system to predefined(default) values.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  hSession  Input to the session handle.\n!\n! \\retval ::NVAPI_OK     SUCCESS if the profile is found\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_RestoreAllDefaults(hSession: NvDRSSessionHandle) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API restores the given profile to predefined(default) values.\n!                Any and all user specified modifications will be removed.\n!                If the whole profile was set by the user, the profile will be removed.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  hSession  Input to the session handle.\n! \\param [in]  hProfile  Input profile handle.\n!\n! \\retval ::NVAPI_OK              SUCCESS if the profile is found\n! \\retval ::NVAPI_ERROR           For miscellaneous errors.\n! \\retval ::NVAPI_PROFILE_REMOVED SUCCESS, and the hProfile is no longer valid.\n! \\retval ::NVAPI_ERROR           For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_RestoreProfileDefault(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: This API restores the given profile setting to predefined(default) values.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  hSession  Input to the session handle.\n! \\param [in]  hProfile  Input profile handle.\n! \\param [in]  settingId Input settingId.\n!\n! \\retval ::NVAPI_OK     SUCCESS if the profile is found\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_RestoreProfileDefaultSetting(
        hSession: NvDRSSessionHandle,
        hProfile: NvDRSProfileHandle,
        settingId: NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "!   DESCRIPTION: Returns the handle to the current global profile.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]  hSession    Input to the session handle.\n! \\param [in]  *phProfile   Returns Base profile handle.\n!\n! \\retval ::NVAPI_OK     SUCCESS if the profile is found\n! \\retval ::NVAPI_ERROR  For miscellaneous errors.\n!\n! \\ingroup drsapi\n"]
    pub fn NvAPI_DRS_GetBaseProfile(
        hSession: NvDRSSessionHandle,
        phProfile: *mut NvDRSProfileHandle,
    ) -> NvAPI_Status;
}
#[doc = "! \\addtogroup sysgeneral\n! @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_CHIPSET_INFO_v4 {
    #[doc = "!< structure version"]
    pub version: NvU32,
    #[doc = "!< Chipset vendor identification"]
    pub vendorId: NvU32,
    #[doc = "!< Chipset device identification"]
    pub deviceId: NvU32,
    #[doc = "!< Chipset vendor Name"]
    pub szVendorName: NvAPI_ShortString,
    #[doc = "!< Chipset device Name"]
    pub szChipsetName: NvAPI_ShortString,
    #[doc = "!< Chipset info flags - obsolete"]
    pub flags: NvU32,
    #[doc = "!< Chipset subsystem vendor identification"]
    pub subSysVendorId: NvU32,
    #[doc = "!< Chipset subsystem device identification"]
    pub subSysDeviceId: NvU32,
    #[doc = "!< subsystem vendor Name"]
    pub szSubSysVendorName: NvAPI_ShortString,
    #[doc = "!< Host bridge vendor identification"]
    pub HBvendorId: NvU32,
    #[doc = "!< Host bridge device identification"]
    pub HBdeviceId: NvU32,
    #[doc = "!< Host bridge subsystem vendor identification"]
    pub HBsubSysVendorId: NvU32,
    #[doc = "!< Host bridge subsystem device identification"]
    pub HBsubSysDeviceId: NvU32,
}
#[test]
fn bindgen_test_layout_NV_CHIPSET_INFO_v4() {
    const UNINIT: ::std::mem::MaybeUninit<NV_CHIPSET_INFO_v4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_CHIPSET_INFO_v4>(),
        232usize,
        concat!("Size of: ", stringify!(NV_CHIPSET_INFO_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_CHIPSET_INFO_v4>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_CHIPSET_INFO_v4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendorId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(vendorId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(deviceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szVendorName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(szVendorName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szChipsetName) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(szChipsetName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subSysVendorId) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(subSysVendorId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subSysDeviceId) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(subSysDeviceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szSubSysVendorName) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(szSubSysVendorName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HBvendorId) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(HBvendorId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HBdeviceId) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(HBdeviceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HBsubSysVendorId) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(HBsubSysVendorId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HBsubSysDeviceId) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v4),
            "::",
            stringify!(HBsubSysDeviceId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_CHIPSET_INFO_v3 {
    #[doc = "!< structure version"]
    pub version: NvU32,
    #[doc = "!< vendor ID"]
    pub vendorId: NvU32,
    #[doc = "!< device ID"]
    pub deviceId: NvU32,
    #[doc = "!< vendor Name"]
    pub szVendorName: NvAPI_ShortString,
    #[doc = "!< device Name"]
    pub szChipsetName: NvAPI_ShortString,
    #[doc = "!< Chipset info flags - obsolete"]
    pub flags: NvU32,
    #[doc = "!< subsystem vendor ID"]
    pub subSysVendorId: NvU32,
    #[doc = "!< subsystem device ID"]
    pub subSysDeviceId: NvU32,
    #[doc = "!< subsystem vendor Name"]
    pub szSubSysVendorName: NvAPI_ShortString,
}
#[test]
fn bindgen_test_layout_NV_CHIPSET_INFO_v3() {
    const UNINIT: ::std::mem::MaybeUninit<NV_CHIPSET_INFO_v3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_CHIPSET_INFO_v3>(),
        216usize,
        concat!("Size of: ", stringify!(NV_CHIPSET_INFO_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_CHIPSET_INFO_v3>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_CHIPSET_INFO_v3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v3),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendorId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v3),
            "::",
            stringify!(vendorId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v3),
            "::",
            stringify!(deviceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szVendorName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v3),
            "::",
            stringify!(szVendorName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szChipsetName) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v3),
            "::",
            stringify!(szChipsetName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v3),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subSysVendorId) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v3),
            "::",
            stringify!(subSysVendorId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subSysDeviceId) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v3),
            "::",
            stringify!(subSysDeviceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szSubSysVendorName) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v3),
            "::",
            stringify!(szSubSysVendorName)
        )
    );
}
pub const NV_CHIPSET_INFO_FLAGS_NV_CHIPSET_INFO_HYBRID: NV_CHIPSET_INFO_FLAGS = 1;
pub type NV_CHIPSET_INFO_FLAGS = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_CHIPSET_INFO_v2 {
    #[doc = "!< structure version"]
    pub version: NvU32,
    #[doc = "!< vendor ID"]
    pub vendorId: NvU32,
    #[doc = "!< device ID"]
    pub deviceId: NvU32,
    #[doc = "!< vendor Name"]
    pub szVendorName: NvAPI_ShortString,
    #[doc = "!< device Name"]
    pub szChipsetName: NvAPI_ShortString,
    #[doc = "!< Chipset info flags"]
    pub flags: NvU32,
}
#[test]
fn bindgen_test_layout_NV_CHIPSET_INFO_v2() {
    const UNINIT: ::std::mem::MaybeUninit<NV_CHIPSET_INFO_v2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_CHIPSET_INFO_v2>(),
        144usize,
        concat!("Size of: ", stringify!(NV_CHIPSET_INFO_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_CHIPSET_INFO_v2>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_CHIPSET_INFO_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendorId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v2),
            "::",
            stringify!(vendorId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v2),
            "::",
            stringify!(deviceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szVendorName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v2),
            "::",
            stringify!(szVendorName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szChipsetName) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v2),
            "::",
            stringify!(szChipsetName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v2),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_CHIPSET_INFO_v1 {
    pub version: NvU32,
    pub vendorId: NvU32,
    pub deviceId: NvU32,
    pub szVendorName: NvAPI_ShortString,
    pub szChipsetName: NvAPI_ShortString,
}
#[test]
fn bindgen_test_layout_NV_CHIPSET_INFO_v1() {
    const UNINIT: ::std::mem::MaybeUninit<NV_CHIPSET_INFO_v1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_CHIPSET_INFO_v1>(),
        140usize,
        concat!("Size of: ", stringify!(NV_CHIPSET_INFO_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_CHIPSET_INFO_v1>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_CHIPSET_INFO_v1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendorId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v1),
            "::",
            stringify!(vendorId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v1),
            "::",
            stringify!(deviceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szVendorName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v1),
            "::",
            stringify!(szVendorName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szChipsetName) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_CHIPSET_INFO_v1),
            "::",
            stringify!(szChipsetName)
        )
    );
}
extern "C" {
    #[doc = "!  This function returns information about the system's chipset.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 95\n!\n! \\retval  NVAPI_INVALID_ARGUMENT              pChipSetInfo is NULL.\n! \\retval  NVAPI_OK                           *pChipSetInfo is now set.\n! \\retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION   NV_CHIPSET_INFO version not compatible with driver.\n! \\ingroup sysgeneral\n"]
    pub fn NvAPI_SYS_GetChipSetInfo(pChipSetInfo: *mut NV_CHIPSET_INFO_v4) -> NvAPI_Status;
}
#[doc = "! \\ingroup sysgeneral\n! Lid and dock information - used in NvAPI_GetLidDockInfo()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NV_LID_DOCK_PARAMS {
    pub version: NvU32,
    #[doc = "! Structure version, constructed from the macro #NV_LID_DOCK_PARAMS_VER"]
    pub currentLidState: NvU32,
    pub currentDockState: NvU32,
    pub currentLidPolicy: NvU32,
    pub currentDockPolicy: NvU32,
    pub forcedLidMechanismPresent: NvU32,
    pub forcedDockMechanismPresent: NvU32,
}
#[test]
fn bindgen_test_layout_NV_LID_DOCK_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<NV_LID_DOCK_PARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NV_LID_DOCK_PARAMS>(),
        28usize,
        concat!("Size of: ", stringify!(NV_LID_DOCK_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<NV_LID_DOCK_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(NV_LID_DOCK_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_LID_DOCK_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentLidState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_LID_DOCK_PARAMS),
            "::",
            stringify!(currentLidState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentDockState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_LID_DOCK_PARAMS),
            "::",
            stringify!(currentDockState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentLidPolicy) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_LID_DOCK_PARAMS),
            "::",
            stringify!(currentLidPolicy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentDockPolicy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_LID_DOCK_PARAMS),
            "::",
            stringify!(currentDockPolicy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forcedLidMechanismPresent) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_LID_DOCK_PARAMS),
            "::",
            stringify!(forcedLidMechanismPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forcedDockMechanismPresent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NV_LID_DOCK_PARAMS),
            "::",
            stringify!(forcedDockMechanismPresent)
        )
    );
}
extern "C" {
    #[doc = "! DESCRIPTION: This function returns the current lid and dock information.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 177\n!\n! \\retval ::NVAPI_OK\n! \\retval ::NVAPI_ERROR\n! \\retval ::NVAPI_NOT_SUPPORTED\n! \\retval ::NVAPI_HANDLE_INVALIDATED\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n!\n! \\ingroup sysgeneral\n"]
    pub fn NvAPI_SYS_GetLidAndDockInfo(pLidAndDock: *mut NV_LID_DOCK_PARAMS) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API converts a Physical GPU handle and output ID to a\n!                  display ID.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]     hPhysicalGpu   Handle to the physical GPU\n! \\param [in]     outputId       Connected display output ID on the\n!                                target GPU - must only have one bit set\n! \\param [out]    displayId      Pointer to an NvU32 which contains\n!                                 the display ID\n!\n! \\retval  ::NVAPI_OK - completed request\n! \\retval  ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized\n! \\retval  ::NVAPI_ERROR - miscellaneous error occurred\n! \\retval  ::NVAPI_INVALID_ARGUMENT - Invalid input parameter.\n!\n! \\ingroup sysgeneral\n"]
    pub fn NvAPI_SYS_GetDisplayIdFromGpuAndOutputId(
        hPhysicalGpu: NvPhysicalGpuHandle,
        outputId: NvU32,
        displayId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! DESCRIPTION:     This API converts a display ID to a Physical GPU handle and output ID.\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\param [in]     displayId       Display ID of display to retrieve\n!                                 GPU and outputId for\n! \\param [out]    hPhysicalGpu    Handle to the physical GPU\n! \\param [out]    outputId )      Connected display output ID on the\n!                                 target GPU will only have one bit set.\n!\n! \\retval ::NVAPI_OK\n! \\retval ::NVAPI_API_NOT_INTIALIZED\n! \\retval ::NVAPI_ID_OUT_OF_RANGE    The DisplayId corresponds to a\n!                                    display which is not within the\n!                                    normal outputId range.\n! \\retval ::NVAPI_ERROR\n! \\retval ::NVAPI_INVALID_ARGUMENT\n!\n! \\ingroup sysgeneral\n"]
    pub fn NvAPI_SYS_GetGpuAndOutputIdFromDisplayId(
        displayId: NvU32,
        hPhysicalGpu: *mut NvPhysicalGpuHandle,
        outputId: *mut NvU32,
    ) -> NvAPI_Status;
}
extern "C" {
    #[doc = "! \\code\n! DESCRIPTION:     This API retrieves the Physical GPU handle of the connected display\n!\n! \\since Release: 313\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! PARAMETERS:      displayId(IN)     - Display ID of display to retrieve\n!                                      GPU handle\n!                  hPhysicalGpu(OUT) - Handle to the physical GPU\n!\n! RETURN STATUS:\n!                  NVAPI_OK - completed request\n!                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized\n!                  NVAPI_ERROR - miscellaneous error occurred\n!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.\n! \\endcode\n! \\ingroup sysgeneral\n"]
    pub fn NvAPI_SYS_GetPhysicalGpuFromDisplayId(
        displayId: NvU32,
        hPhysicalGpu: *mut NvPhysicalGpuHandle,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAY_DRIVER_INFO {
    #[doc = "!< Structure Version."]
    pub version: NvU32,
    #[doc = "!< Contains the driver version after successful return."]
    pub driverVersion: NvU32,
    #[doc = "!< Contains the driver-branch string after successful return."]
    pub szBuildBranch: NvAPI_ShortString,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NV_DISPLAY_DRIVER_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_DISPLAY_DRIVER_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAY_DRIVER_INFO>(),
        76usize,
        concat!("Size of: ", stringify!(_NV_DISPLAY_DRIVER_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAY_DRIVER_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_DISPLAY_DRIVER_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_DRIVER_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driverVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_DRIVER_INFO),
            "::",
            stringify!(driverVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szBuildBranch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_DRIVER_INFO),
            "::",
            stringify!(szBuildBranch)
        )
    );
}
impl _NV_DISPLAY_DRIVER_INFO {
    #[inline]
    pub fn bIsDCHDriver(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsDCHDriver(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIAStudioPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIAStudioPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIAGameReadyPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIAGameReadyPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIARTXProductionBranchPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIARTXProductionBranchPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIARTXNewFeatureBranchPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIARTXNewFeatureBranchPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsDCHDriver: NvU32,
        bIsNVIDIAStudioPackage: NvU32,
        bIsNVIDIAGameReadyPackage: NvU32,
        bIsNVIDIARTXProductionBranchPackage: NvU32,
        bIsNVIDIARTXNewFeatureBranchPackage: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsDCHDriver: u32 = unsafe { ::std::mem::transmute(bIsDCHDriver) };
            bIsDCHDriver as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bIsNVIDIAStudioPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIAStudioPackage) };
            bIsNVIDIAStudioPackage as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bIsNVIDIAGameReadyPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIAGameReadyPackage) };
            bIsNVIDIAGameReadyPackage as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bIsNVIDIARTXProductionBranchPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIARTXProductionBranchPackage) };
            bIsNVIDIARTXProductionBranchPackage as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bIsNVIDIARTXNewFeatureBranchPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIARTXNewFeatureBranchPackage) };
            bIsNVIDIARTXNewFeatureBranchPackage as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_DISPLAY_DRIVER_INFO_V1 = _NV_DISPLAY_DRIVER_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_DISPLAY_DRIVER_INFO_V2 {
    #[doc = "!< Structure Version."]
    pub version: NvU32,
    #[doc = "!< Contains the driver version after successful return."]
    pub driverVersion: NvU32,
    #[doc = "!< Contains the driver-branch string after successful return."]
    pub szBuildBranch: NvAPI_ShortString,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "!< (OUT) Contains the driver base branch string after successful return."]
    pub szBuildBaseBranch: NvAPI_ShortString,
    #[doc = "!< Reserved for future use"]
    pub reservedEx: NvU32,
}
#[test]
fn bindgen_test_layout__NV_DISPLAY_DRIVER_INFO_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_DISPLAY_DRIVER_INFO_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_DISPLAY_DRIVER_INFO_V2>(),
        144usize,
        concat!("Size of: ", stringify!(_NV_DISPLAY_DRIVER_INFO_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_DISPLAY_DRIVER_INFO_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_DISPLAY_DRIVER_INFO_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_DRIVER_INFO_V2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driverVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_DRIVER_INFO_V2),
            "::",
            stringify!(driverVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szBuildBranch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_DRIVER_INFO_V2),
            "::",
            stringify!(szBuildBranch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szBuildBaseBranch) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_DRIVER_INFO_V2),
            "::",
            stringify!(szBuildBaseBranch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedEx) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_DISPLAY_DRIVER_INFO_V2),
            "::",
            stringify!(reservedEx)
        )
    );
}
impl _NV_DISPLAY_DRIVER_INFO_V2 {
    #[inline]
    pub fn bIsDCHDriver(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsDCHDriver(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIAStudioPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIAStudioPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIAGameReadyPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIAGameReadyPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIARTXProductionBranchPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIARTXProductionBranchPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIARTXNewFeatureBranchPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIARTXNewFeatureBranchPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsDCHDriver: NvU32,
        bIsNVIDIAStudioPackage: NvU32,
        bIsNVIDIAGameReadyPackage: NvU32,
        bIsNVIDIARTXProductionBranchPackage: NvU32,
        bIsNVIDIARTXNewFeatureBranchPackage: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsDCHDriver: u32 = unsafe { ::std::mem::transmute(bIsDCHDriver) };
            bIsDCHDriver as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bIsNVIDIAStudioPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIAStudioPackage) };
            bIsNVIDIAStudioPackage as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bIsNVIDIAGameReadyPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIAGameReadyPackage) };
            bIsNVIDIAGameReadyPackage as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bIsNVIDIARTXProductionBranchPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIARTXProductionBranchPackage) };
            bIsNVIDIARTXProductionBranchPackage as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bIsNVIDIARTXNewFeatureBranchPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIARTXNewFeatureBranchPackage) };
            bIsNVIDIARTXNewFeatureBranchPackage as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_DISPLAY_DRIVER_INFO_V2 = _NV_DISPLAY_DRIVER_INFO_V2;
pub type NV_DISPLAY_DRIVER_INFO = NV_DISPLAY_DRIVER_INFO_V2;
extern "C" {
    #[doc = "! DESCRIPTION: This API will return information related to the NVIDIA Display Driver.\n!              Note that out of the driver types - Studio, Game Ready, RTX Production Branch, RTX New Feature Branch - only one driver type can be available in system.\n!              If NVAPI is unable to get the information of particular driver type, we report all flags as 0 (Unknown).\n!\n! SUPPORTED OS:  Windows 7 and higher\n!\n!\n! \\since Release: 396\n!\n! \\param [inout] pDriverInfo - This structure will be filled with required information.\n!\n! \\return  This API can return any of the error codes enumerated in\n!          #NvAPI_Status.  If there are return error codes with specific\n!          meaning for this API, they are listed below.\n!\n! \\ingroup gpu\n"]
    pub fn NvAPI_SYS_GetDisplayDriverInfo(pDriverInfo: *mut NV_DISPLAY_DRIVER_INFO)
        -> NvAPI_Status;
}
#[doc = " Callback settings common to all client callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1 {
    #[doc = " [in] Generic callback parameter which will be passed to the callback."]
    pub pCallbackParam: *mut ::std::os::raw::c_void,
    #[doc = " Reserved bytes for future expansion."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCallbackParam) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1),
            "::",
            stringify!(pCallbackParam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Callback settings common to all client callbacks."]
pub type NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1 = _NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1;
#[doc = " Callback settings common to all client callbacks."]
pub type NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1 = NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1;
#[doc = " Callback settings common to all periodic client callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 {
    #[doc = " [in] Super class data."]
    pub super_: NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1,
    #[doc = " [in] Minimum interval at which callback will be called.\n\n The callback may be invoked slower than this interval if underlying\n sampling rate does not align precisely to the provided period."]
    pub callbackPeriodms: NvU32,
    #[doc = " Reserved bytes for future expansion."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).super_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1),
            "::",
            stringify!(super_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbackPeriodms) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1),
            "::",
            stringify!(callbackPeriodms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Callback settings common to all periodic client callbacks."]
pub type NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 =
    _NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1;
#[doc = " Callback data common to all client callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 {
    #[doc = " [out] Generic callback parameter which was passed in at registration time."]
    pub pCallbackParam: *mut ::std::os::raw::c_void,
    #[doc = " Reserved bytes for future expansion."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCallbackParam) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1),
            "::",
            stringify!(pCallbackParam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Callback data common to all client callbacks."]
pub type NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 = _NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1;
pub const _NV_GPU_CLIENT_UTIL_DOMAIN_ID_NV_GPU_CLIENT_UTIL_DOMAIN_GRAPHICS:
    _NV_GPU_CLIENT_UTIL_DOMAIN_ID = 0;
pub const _NV_GPU_CLIENT_UTIL_DOMAIN_ID_NV_GPU_CLIENT_UTIL_DOMAIN_FRAME_BUFFER:
    _NV_GPU_CLIENT_UTIL_DOMAIN_ID = 1;
pub const _NV_GPU_CLIENT_UTIL_DOMAIN_ID_NV_GPU_CLIENT_UTIL_DOMAIN_VIDEO:
    _NV_GPU_CLIENT_UTIL_DOMAIN_ID = 2;
#[doc = " Reserved for future use."]
pub const _NV_GPU_CLIENT_UTIL_DOMAIN_ID_NV_GPU_CLIENT_UTIL_DOMAIN_RSVD:
    _NV_GPU_CLIENT_UTIL_DOMAIN_ID = 3;
#[doc = " Enumeration of different utilization domains"]
pub type _NV_GPU_CLIENT_UTIL_DOMAIN_ID = ::std::os::raw::c_int;
#[doc = " Enumeration of different utilization domains"]
pub use self::_NV_GPU_CLIENT_UTIL_DOMAIN_ID as NV_GPU_CLIENT_UTIL_DOMAIN_ID;
#[doc = " Data specific to a single utilization domain."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_UTILIZATION_DATA_V1 {
    #[doc = " [out] Utilization domain identifier."]
    pub utilId: NV_GPU_CLIENT_UTIL_DOMAIN_ID,
    #[doc = " [out] Percentage of time where the domain is considered busy since the\n last sample. Units of percent*100; i.e. 5000 = 50%."]
    pub utilizationPercent: NvU32,
    #[doc = " Reserved bytes for future expansion."]
    pub rsvd: [NvU8; 61usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_UTILIZATION_DATA_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_UTILIZATION_DATA_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_UTILIZATION_DATA_V1>(),
        72usize,
        concat!("Size of: ", stringify!(_NV_GPU_CLIENT_UTILIZATION_DATA_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_UTILIZATION_DATA_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_DATA_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utilId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_DATA_V1),
            "::",
            stringify!(utilId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utilizationPercent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_DATA_V1),
            "::",
            stringify!(utilizationPercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_DATA_V1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Data specific to a single utilization domain."]
pub type NV_GPU_CLIENT_UTILIZATION_DATA_V1 = _NV_GPU_CLIENT_UTILIZATION_DATA_V1;
#[doc = " Data passed back to callback registered with\n @ref NvAPI_GPU_ClientRegisterForUtilizationSampleUpdates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1 {
    #[doc = " [out] Super struct."]
    pub super_: NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1,
    #[doc = " [out] Number of valid entries in `utils` array."]
    pub numUtils: NvU32,
    #[doc = " [out] Time at which data was collected. Represented as elapsed\n microseconds since 00:00:00 UTC on January 1, 1970."]
    pub timestamp: NvU64,
    #[doc = " Reserved bytes for future expansion."]
    pub rsvd: [NvU8; 64usize],
    #[doc = " [out] Status data for each utilization domain."]
    pub utils: [NV_GPU_CLIENT_UTILIZATION_DATA_V1; 4usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1>(),
        440usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).super_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1),
            "::",
            stringify!(super_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numUtils) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1),
            "::",
            stringify!(numUtils)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1),
            "::",
            stringify!(rsvd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utils) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1),
            "::",
            stringify!(utils)
        )
    );
}
#[doc = " Data passed back to callback registered with\n @ref NvAPI_GPU_ClientRegisterForUtilizationSampleUpdates."]
pub type NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1 = _NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1;
#[doc = " Function prototype for a periodic utilization data callback that will be registered with NvAPI."]
pub type NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_V1 = ::std::option::Option<
    unsafe extern "C" fn(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pData: *mut NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1,
    ),
>;
#[doc = " Data required to register a periodic callback for utilization data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1 {
    #[doc = " [in] Structure Version, must always be first."]
    pub version: NvU32,
    #[doc = " [in] Generic callback settings. Some data within will be passed to the\n callback when invoked."]
    pub super_: NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1,
    #[doc = " [in] Callback. Pass in NULL or nullptr to indicate request to unregister."]
    pub callback: NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_V1,
    #[doc = " Reserved bytes for future expansion."]
    pub rsvd: [NvU8; 64usize],
}
#[test]
fn bindgen_test_layout__NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1>(),
        224usize,
        concat!(
            "Size of: ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).super_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1),
            "::",
            stringify!(super_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1),
            "::",
            stringify!(rsvd)
        )
    );
}
#[doc = " Data required to register a periodic callback for utilization data."]
pub type NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1 =
    _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1;
#[doc = " Data required to register a periodic callback for utilization data."]
pub type NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS =
    NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1;
extern "C" {
    #[doc = "! \\fn NvAPI_GPU_ClientRegisterForUtilizationSampleUpdates()\n! \\code\n!   DESCRIPTION: Register to receive samples of utilization data periodically\n!                via a function pointer callback.\n!\n! SUPPORTED OS:  Windows 10 and higher\n!\n!\n! \\since Release 455\n!\n! \\return        NVAPI_OK                          - Registration was successful\n!                NVAPI_API_NOT_INITIALIZED         - NVAPI not initialized\n!                NVAPI_INCOMPATIBLE_STRUCT_VERSION - Invalid structure version specified\n!                NVAPI_INVALID_CONFIGURATION       - Invalid software environment configuration\n!                NVAPI_TIMEOUT                     - Registration request timed out\n!                NVAPI_ERROR                       - Unknown underlying error\n!\n! \\endcode\n! \\ingroup nvtopps\n"]
    pub fn NvAPI_GPU_ClientRegisterForUtilizationSampleUpdates(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pCallbackSettings: *mut NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS,
    ) -> NvAPI_Status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
